Index: squid/configure.in
diff -c squid/configure.in:1.251.2.84 squid/configure.in:1.251.2.86
*** squid/configure.in:1.251.2.84	Fri Mar 18 18:31:35 2005
--- squid/configure.in	Sat Mar 26 14:58:19 2005
***************
*** 747,752 ****
--- 747,821 ----
    fi
  ])
  
+ dnl Enable Large file support
+ buildmodel=""
+ needlargefiles=
+ 
+ AC_ARG_WITH(large-files,
+ [  --with-large-files      Enable support for large files (logs etc).],
+ [ if test "$withval" = yes; then
+ 	needlargefiles=1
+   fi
+ ])
+ 
+ AC_ARG_ENABLE(large-cache-files,
+ [  --enable-large-cache-files
+                           Enable support for large cache files (>2GB).
+                           WARNING: on-disk cache format is changed by this option],
+ [ if test "$enableval" = "yes" ; then
+ 	echo "Large cache file support enabled"
+ 	AC_DEFINE(LARGE_CACHE_FILES, 1, [Support large cache files > 2GB])
+ dnl	needlargefiles=1
+   fi
+ ])
+ 
+ dnl UNIX Build environment
+ AC_ARG_WITH(build-environment,
+ [  --with-build-environment=model
+                           The build environment to use. Normally one of
+                           POSIX_V6_ILP32_OFF32   32 bits
+                           POSIX_V6_ILP32_OFFBIG  32 bits with large file support
+                           POSIX_V6_LP64_OFF64    64 bits
+                           POSIX_V6_LPBIG_OFFBIG  large pointers and files
+                           XBS5_ILP32_OFF32       32 bits (legacy)
+                           XBS5_ILP32_OFFBIG      32 bits with large file support (legacy)
+                           XBS5_LP64_OFF64        64 bits (legacy)
+                           XBS5_LPBIG_OFFBIG      large pointers and files (legacy)
+                           default                The default for your OS],
+ [ case "$enableval" in
+   yes|no)
+ 	echo "--with-build-environment expects a build environment string as used by getconf"
+ 	exit 1
+ 	;;
+   _*)
+ 	buildmodel="$enableval"
+ 	;;
+   *)
+ 	buildmodel="_$enableval"
+ 	;;
+   esac
+ ])
+ 
+ if test $needlargefiles && test -z "$buildmodel"; then
+ 	for model in POSIX_V6_ILP32_OFFBIG XBS5_ILP32_OFFBIG POSIX_V6_LP64_OFF64 XBS5_LP64_OFF64 POSIX_V6_LPBIG_OFFBIG XBS5_LPBIG_OFFBIG; do
+ 		if test "`getconf _$model 2>/dev/null || true`" = 1 || test "`getconf $model 2>/dev/null || true`" ; then
+ 			buildmodel=$model
+ 			break
+ 		fi
+ 	done
+ 	if test -z "$buildmodel"; then
+ 		echo "WARNING: No suitable build environment found for large files. Trying to use _FILE_OFFSET_BITS=64"
+ 		sleep 1
+ 		CFLAGS="-D_FILE_OFFSET_BITS=64 $CFLAGS"
+ 	fi
+ fi
+ if test -n "$buildmodel" && test "$buildmodel" != "_default"; then
+ 	echo "Using $buildmodel build environment"
+ 	CFLAGS="`getconf ${buildmodel}_CFLAGS` $CFLAGS"
+ 	LIBS="`getconf ${buildmodel}_LIBS` $LIBS"
+ 	LDFLAGS="`getconf ${buildmodel}_LDFLAGS` $LDFLAGS"
+ fi
+ 
  AM_CONDITIONAL(MAKE_LEAKFINDER, false)
  dnl Enable Leak Finding Functions
  AC_ARG_ENABLE(leakfinder,
***************
*** 1743,1748 ****
--- 1812,1818 ----
  	srand48 \
  	srandom \
  	statfs \
+ 	strtoll \
  	sysconf \
  	syslog \
  	timegm \
Index: squid/configure
diff -c squid/configure:1.248.2.85 squid/configure:1.248.2.87
*** squid/configure:1.248.2.85	Fri Mar 18 18:31:54 2005
--- squid/configure	Sat Mar 26 14:59:01 2005
***************
*** 129,134 ****
--- 129,152 ----
    --enable-linux-netfilter
                            Enable Transparent Proxy support for Linux 2.4."
  ac_help="$ac_help
+   --with-large-files      Enable support for large files (logs etc)."
+ ac_help="$ac_help
+   --enable-large-cache-files
+                           Enable support for large cache files (>2GB).
+                           WARNING: on-disk cache format is changed by this option"
+ ac_help="$ac_help
+   --with-build-environment=model
+                           The build environment to use. Normally one of
+                           POSIX_V6_ILP32_OFF32   32 bits
+                           POSIX_V6_ILP32_OFFBIG  32 bits with large file support
+                           POSIX_V6_LP64_OFF64    64 bits
+                           POSIX_V6_LPBIG_OFFBIG  large pointers and files
+                           XBS5_ILP32_OFF32       32 bits (legacy)
+                           XBS5_ILP32_OFFBIG      32 bits with large file support (legacy)
+                           XBS5_LP64_OFF64        64 bits (legacy)
+                           XBS5_LPBIG_OFFBIG      large pointers and files (legacy)
+                           default                The default for your OS"
+ ac_help="$ac_help
    --enable-leakfinder
                            Enable Leak Finding code.  Enabling this alone
                            does nothing; you also have to modify the source
***************
*** 2585,2590 ****
--- 2603,2674 ----
  fi
  
  
+ buildmodel=""
+ needlargefiles=
+ 
+ # Check whether --with-large-files or --without-large-files was given.
+ if test "${with_large_files+set}" = set; then
+   withval="$with_large_files"
+    if test "$withval" = yes; then
+ 	needlargefiles=1
+   fi
+ 
+ fi
+ 
+ 
+ # Check whether --enable-large-cache-files or --disable-large-cache-files was given.
+ if test "${enable_large_cache_files+set}" = set; then
+   enableval="$enable_large_cache_files"
+    if test "$enableval" = "yes" ; then
+ 	echo "Large cache file support enabled"
+ 	cat >> confdefs.h <<\EOF
+ #define LARGE_CACHE_FILES 1
+ EOF
+ 
+   fi
+ 
+ fi
+ 
+ 
+ # Check whether --with-build-environment or --without-build-environment was given.
+ if test "${with_build_environment+set}" = set; then
+   withval="$with_build_environment"
+    case "$enableval" in
+   yes|no)
+ 	echo "--with-build-environment expects a build environment string as used by getconf"
+ 	exit 1
+ 	;;
+   _*)
+ 	buildmodel="$enableval"
+ 	;;
+   *)
+ 	buildmodel="_$enableval"
+ 	;;
+   esac
+ 
+ fi
+ 
+ 
+ if test $needlargefiles && test -z "$buildmodel"; then
+ 	for model in POSIX_V6_ILP32_OFFBIG XBS5_ILP32_OFFBIG POSIX_V6_LP64_OFF64 XBS5_LP64_OFF64 POSIX_V6_LPBIG_OFFBIG XBS5_LPBIG_OFFBIG; do
+ 		if test "`getconf _$model 2>/dev/null || true`" = 1 || test "`getconf $model 2>/dev/null || true`" ; then
+ 			buildmodel=$model
+ 			break
+ 		fi
+ 	done
+ 	if test -z "$buildmodel"; then
+ 		echo "WARNING: No suitable build environment found for large files. Trying to use _FILE_OFFSET_BITS=64"
+ 		sleep 1
+ 		CFLAGS="-D_FILE_OFFSET_BITS=64 $CFLAGS"
+ 	fi
+ fi
+ if test -n "$buildmodel" && test "$buildmodel" != "_default"; then
+ 	echo "Using $buildmodel build environment"
+ 	CFLAGS="`getconf ${buildmodel}_CFLAGS` $CFLAGS"
+ 	LIBS="`getconf ${buildmodel}_LIBS` $LIBS"
+ 	LDFLAGS="`getconf ${buildmodel}_LDFLAGS` $LDFLAGS"
+ fi
+ 
  
  
  if false; then
***************
*** 7653,7658 ****
--- 7737,7743 ----
  	srand48 \
  	srandom \
  	statfs \
+ 	strtoll \
  	sysconf \
  	syslog \
  	timegm \
Index: squid/include/autoconf.h.in
diff -c squid/include/autoconf.h.in:1.109.2.10 squid/include/autoconf.h.in:1.109.2.11
*** squid/include/autoconf.h.in:1.109.2.10	Mon Aug  9 07:55:49 2004
--- squid/include/autoconf.h.in	Fri Mar 25 20:00:03 2005
***************
*** 575,580 ****
--- 575,583 ----
  /* Define if you have the strerror function.  */
  #undef HAVE_STRERROR
  
+ /* Define if you have the strtoll function.  */
+ #undef HAVE_STRTOLL
+ 
  /* Define if you have the sysconf function.  */
  #undef HAVE_SYSCONF
  
***************
*** 884,889 ****
--- 887,895 ----
  /* Version number of package */
  #undef VERSION
  
+ /* Support large cache files > 2GB */
+ #undef LARGE_CACHE_FILES
+ 
  /* Enable hostname sanity checks */
  #undef CHECK_HOSTNAMES
  
Index: squid/helpers/basic_auth/MSNT/smblib-util.c
diff -c squid/helpers/basic_auth/MSNT/smblib-util.c:1.1.2.3 squid/helpers/basic_auth/MSNT/smblib-util.c:1.1.2.4
*** squid/helpers/basic_auth/MSNT/smblib-util.c:1.1.2.3	Wed Mar  9 07:28:32 2005
--- squid/helpers/basic_auth/MSNT/smblib-util.c	Fri Mar 25 19:50:50 2005
***************
*** 255,261 ****
  	Con_Handle->Encrypt_Key_Len = SVAL(SMB_Hdr(pkt), SMB_negrLM_ekl_offset);
  
  	p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset);
- 	fprintf(stderr, "%d", (int) (SMB_Hdr(pkt) + SMB_negrLM_buf_offset));
  	memcpy(Con_Handle->Encrypt_Key, p, 8);
  
  	p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset + Con_Handle->Encrypt_Key_Len);
--- 255,260 ----
Index: squid/helpers/external_acl/winbind_group/wb_check_group.c
diff -c squid/helpers/external_acl/winbind_group/wb_check_group.c:1.2.2.10 squid/helpers/external_acl/winbind_group/wb_check_group.c:1.2.2.11
*** squid/helpers/external_acl/winbind_group/wb_check_group.c:1.2.2.10	Fri Sep 12 04:11:22 2003
--- squid/helpers/external_acl/winbind_group/wb_check_group.c	Fri Mar 25 19:50:50 2005
***************
*** 364,370 ****
  	if ((p = strchr(buf, '\r')) != NULL)
  	    *p = '\0';		/* strip \r */
  
! 	debug("Got '%s' from Squid (length: %d).\n",buf,strlen(buf));
  	
  	if (buf[0] == '\0') {
  	    warn("Invalid Request\n");
--- 364,370 ----
  	if ((p = strchr(buf, '\r')) != NULL)
  	    *p = '\0';		/* strip \r */
  
! 	debug("Got '%s' from Squid (length: %d).\n",buf,(int)strlen(buf));
  	
  	if (buf[0] == '\0') {
  	    warn("Invalid Request\n");
Index: squid/lib/rfc1035.c
diff -c squid/lib/rfc1035.c:1.22.2.7 squid/lib/rfc1035.c:1.22.2.8
*** squid/lib/rfc1035.c:1.22.2.7	Sun Jan 16 19:46:29 2005
--- squid/lib/rfc1035.c	Fri Mar 25 19:50:50 2005
***************
*** 113,122 ****
   * Packs a rfc1035_header structure into a buffer.
   * Returns number of octets packed (should always be 12)
   */
! static off_t
  rfc1035HeaderPack(char *buf, size_t sz, rfc1035_header * hdr)
  {
!     off_t off = 0;
      unsigned short s;
      unsigned short t;
      assert(sz >= 12);
--- 113,122 ----
   * Packs a rfc1035_header structure into a buffer.
   * Returns number of octets packed (should always be 12)
   */
! static int
  rfc1035HeaderPack(char *buf, size_t sz, rfc1035_header * hdr)
  {
!     int off = 0;
      unsigned short s;
      unsigned short t;
      assert(sz >= 12);
***************
*** 158,167 ****
   * bytes to follow.  Labels must be smaller than 64 octets.
   * Returns number of octets packed.
   */
! static off_t
  rfc1035LabelPack(char *buf, size_t sz, const char *label)
  {
!     off_t off = 0;
      size_t len = label ? strlen(label) : 0;
      if (label)
  	assert(!strchr(label, '.'));
--- 158,167 ----
   * bytes to follow.  Labels must be smaller than 64 octets.
   * Returns number of octets packed.
   */
! static int
  rfc1035LabelPack(char *buf, size_t sz, const char *label)
  {
!     int off = 0;
      size_t len = label ? strlen(label) : 0;
      if (label)
  	assert(!strchr(label, '.'));
***************
*** 183,192 ****
   * Note message compression is not supported here.
   * Returns number of octets packed.
   */
! static off_t
  rfc1035NamePack(char *buf, size_t sz, const char *name)
  {
!     off_t off = 0;
      char *copy = strdup(name);
      char *t;
      /*
--- 183,192 ----
   * Note message compression is not supported here.
   * Returns number of octets packed.
   */
! static int
  rfc1035NamePack(char *buf, size_t sz, const char *name)
  {
!     int off = 0;
      char *copy = strdup(name);
      char *t;
      /*
***************
*** 206,219 ****
   * Packs a QUESTION section of a message.
   * Returns number of octets packed.
   */
! static off_t
  rfc1035QuestionPack(char *buf,
      size_t sz,
      const char *name,
      unsigned short type,
      unsigned short class)
  {
!     off_t off = 0;
      unsigned short s;
      off += rfc1035NamePack(buf + off, sz - off, name);
      s = htons(type);
--- 206,219 ----
   * Packs a QUESTION section of a message.
   * Returns number of octets packed.
   */
! static int
  rfc1035QuestionPack(char *buf,
      size_t sz,
      const char *name,
      unsigned short type,
      unsigned short class)
  {
!     int off = 0;
      unsigned short s;
      off += rfc1035NamePack(buf + off, sz - off, name);
      s = htons(type);
***************
*** 238,244 ****
   * Returns 0 (success) or 1 (error)
   */
  static int
! rfc1035HeaderUnpack(const char *buf, size_t sz, off_t * off, rfc1035_header * h)
  {
      unsigned short s;
      unsigned short t;
--- 238,244 ----
   * Returns 0 (success) or 1 (error)
   */
  static int
! rfc1035HeaderUnpack(const char *buf, size_t sz, int *off, rfc1035_header * h)
  {
      unsigned short s;
      unsigned short t;
***************
*** 299,307 ****
   * Returns 0 (success) or 1 (error)
   */
  static int
! rfc1035NameUnpack(const char *buf, size_t sz, off_t * off, unsigned short *rdlength, char *name, size_t ns, int rdepth)
  {
!     off_t no = 0;
      unsigned char c;
      size_t len;
      assert(ns > 0);
--- 299,307 ----
   * Returns 0 (success) or 1 (error)
   */
  static int
! rfc1035NameUnpack(const char *buf, size_t sz, int *off, unsigned short *rdlength, char *name, size_t ns, int rdepth)
  {
!     int no = 0;
      unsigned char c;
      size_t len;
      assert(ns > 0);
***************
*** 311,318 ****
  	if (c > 191) {
  	    /* blasted compression */
  	    unsigned short s;
! 	    off_t ptr;
! 	    if (rdepth > 64)		/* infinite pointer loop */
  		return 1;
  	    memcpy(&s, buf + (*off), sizeof(s));
  	    s = ntohs(s);
--- 311,318 ----
  	if (c > 191) {
  	    /* blasted compression */
  	    unsigned short s;
! 	    int ptr;
! 	    if (rdepth > 64)	/* infinite pointer loop */
  		return 1;
  	    memcpy(&s, buf + (*off), sizeof(s));
  	    s = ntohs(s);
***************
*** 367,378 ****
   * Returns 0 (success) or 1 (error)
   */
  static int
! rfc1035RRUnpack(const char *buf, size_t sz, off_t * off, rfc1035_rr * RR)
  {
      unsigned short s;
      unsigned int i;
      unsigned short rdlength;
!     off_t rdata_off;
      if (rfc1035NameUnpack(buf, sz, off, NULL, RR->name, RFC1035_MAXHOSTNAMESZ, 0)) {
  	RFC1035_UNPACK_DEBUG;
  	memset(RR, '\0', sizeof(*RR));
--- 367,378 ----
   * Returns 0 (success) or 1 (error)
   */
  static int
! rfc1035RRUnpack(const char *buf, size_t sz, int *off, rfc1035_rr * RR)
  {
      unsigned short s;
      unsigned int i;
      unsigned short rdlength;
!     int rdata_off;
      if (rfc1035NameUnpack(buf, sz, off, NULL, RR->name, RFC1035_MAXHOSTNAMESZ, 0)) {
  	RFC1035_UNPACK_DEBUG;
  	memset(RR, '\0', sizeof(*RR));
***************
*** 413,419 ****
      case RFC1035_TYPE_PTR:
  	RR->rdata = malloc(RFC1035_MAXHOSTNAMESZ);
  	rdata_off = *off;
! 	RR->rdlength = 0; /* Filled in by rfc1035NameUnpack */
  	if (rfc1035NameUnpack(buf, sz, &rdata_off, &RR->rdlength, RR->rdata, RFC1035_MAXHOSTNAMESZ, 0))
  	    return 1;
  	if (rdata_off != ((*off) + rdlength)) {
--- 413,419 ----
      case RFC1035_TYPE_PTR:
  	RR->rdata = malloc(RFC1035_MAXHOSTNAMESZ);
  	rdata_off = *off;
! 	RR->rdlength = 0;	/* Filled in by rfc1035NameUnpack */
  	if (rfc1035NameUnpack(buf, sz, &rdata_off, &RR->rdlength, RR->rdata, RFC1035_MAXHOSTNAMESZ, 0))
  	    return 1;
  	if (rdata_off != ((*off) + rdlength)) {
***************
*** 515,521 ****
      rfc1035_rr ** records,
      unsigned short *id)
  {
!     off_t off = 0;
      int l;
      int i;
      int nr = 0;
--- 515,521 ----
      rfc1035_rr ** records,
      unsigned short *id)
  {
!     int off = 0;
      int l;
      int i;
      int nr = 0;
***************
*** 562,569 ****
      }
      if (hdr.ancount == 0)
  	return 0;
!     recs = calloc((int)hdr.ancount, sizeof(*recs));
!     for (i = 0; i < (int)hdr.ancount; i++) {
  	if (off >= sz) {	/* corrupt packet */
  	    RFC1035_UNPACK_DEBUG;
  	    break;
--- 562,569 ----
      }
      if (hdr.ancount == 0)
  	return 0;
!     recs = calloc((int) hdr.ancount, sizeof(*recs));
!     for (i = 0; i < (int) hdr.ancount; i++) {
  	if (off >= sz) {	/* corrupt packet */
  	    RFC1035_UNPACK_DEBUG;
  	    break;
Index: squid/src/HttpHdrContRange.c
diff -c squid/src/HttpHdrContRange.c:1.14 squid/src/HttpHdrContRange.c:1.14.2.1
*** squid/src/HttpHdrContRange.c:1.14	Wed Oct 24 02:19:07 2001
--- squid/src/HttpHdrContRange.c	Fri Mar 25 19:50:50 2005
***************
*** 81,87 ****
      p++;
      /* do we have last-pos ? */
      if (p - field < flen) {
! 	ssize_t last_pos;
  	if (!httpHeaderParseSize(p, &last_pos))
  	    return 0;
  	spec->length = size_diff(last_pos + 1, spec->offset);
--- 81,87 ----
      p++;
      /* do we have last-pos ? */
      if (p - field < flen) {
! 	squid_off_t last_pos;
  	if (!httpHeaderParseSize(p, &last_pos))
  	    return 0;
  	spec->length = size_diff(last_pos + 1, spec->offset);
***************
*** 101,108 ****
      if (!known_spec(spec->offset) || !known_spec(spec->length))
  	packerPrintf(p, "*");
      else
! 	packerPrintf(p, "bytes %ld-%ld",
! 	    (long int) spec->offset, (long int) spec->offset + spec->length - 1);
  }
  
  /*
--- 101,108 ----
      if (!known_spec(spec->offset) || !known_spec(spec->length))
  	packerPrintf(p, "*");
      else
! 	packerPrintf(p, "bytes %" PRINTF_OFF_T "-%" PRINTF_OFF_T "",
! 	    spec->offset, spec->offset + spec->length - 1);
  }
  
  /*
***************
*** 152,160 ****
  	range->elength = range_spec_unknown;
      else if (!httpHeaderParseSize(p, &range->elength))
  	return 0;
!     debug(68, 8) ("parsed content-range field: %ld-%ld / %ld\n",
! 	(long int) range->spec.offset, (long int) range->spec.offset + range->spec.length - 1,
! 	(long int) range->elength);
      return 1;
  }
  
--- 152,160 ----
  	range->elength = range_spec_unknown;
      else if (!httpHeaderParseSize(p, &range->elength))
  	return 0;
!     debug(68, 8) ("parsed content-range field: %" PRINTF_OFF_T "-%" PRINTF_OFF_T " / %" PRINTF_OFF_T "\n",
! 	range->spec.offset, range->spec.offset + range->spec.length - 1,
! 	range->elength);
      return 1;
  }
  
***************
*** 187,193 ****
  }
  
  void
! httpHdrContRangeSet(HttpHdrContRange * cr, HttpHdrRangeSpec spec, ssize_t ent_len)
  {
      assert(cr && ent_len >= 0);
      cr->spec = spec;
--- 187,193 ----
  }
  
  void
! httpHdrContRangeSet(HttpHdrContRange * cr, HttpHdrRangeSpec spec, squid_off_t ent_len)
  {
      assert(cr && ent_len >= 0);
      cr->spec = spec;
Index: squid/src/HttpHdrRange.c
diff -c squid/src/HttpHdrRange.c:1.26 squid/src/HttpHdrRange.c:1.26.2.1
*** squid/src/HttpHdrRange.c:1.26	Wed Oct 24 02:19:07 2001
--- squid/src/HttpHdrRange.c	Fri Mar 25 19:50:50 2005
***************
*** 55,61 ****
  
  
  /* local constants */
! #define range_spec_unknown ((ssize_t)-1)
  
  /* local routines */
  #define known_spec(s) ((s) != range_spec_unknown)
--- 55,61 ----
  
  
  /* local constants */
! #define range_spec_unknown ((squid_off_t)-1)
  
  /* local routines */
  #define known_spec(s) ((s) != range_spec_unknown)
***************
*** 102,108 ****
  	p++;
  	/* do we have last-pos ? */
  	if (p - field < flen) {
! 	    ssize_t last_pos;
  	    if (!httpHeaderParseSize(p, &last_pos))
  		return NULL;
  	    spec.length = size_diff(last_pos + 1, spec.offset);
--- 102,108 ----
  	p++;
  	/* do we have last-pos ? */
  	if (p - field < flen) {
! 	    squid_off_t last_pos;
  	    if (!httpHeaderParseSize(p, &last_pos))
  		return NULL;
  	    spec.length = size_diff(last_pos + 1, spec.offset);
***************
*** 136,147 ****
  httpHdrRangeSpecPackInto(const HttpHdrRangeSpec * spec, Packer * p)
  {
      if (!known_spec(spec->offset))	/* suffix */
! 	packerPrintf(p, "-%ld", (long int) spec->length);
      else if (!known_spec(spec->length))		/* trailer */
! 	packerPrintf(p, "%ld-", (long int) spec->offset);
      else			/* range */
! 	packerPrintf(p, "%ld-%ld",
! 	    (long int) spec->offset, (long int) spec->offset + spec->length - 1);
  }
  
  /* fills "absent" positions in range specification based on response body size 
--- 136,147 ----
  httpHdrRangeSpecPackInto(const HttpHdrRangeSpec * spec, Packer * p)
  {
      if (!known_spec(spec->offset))	/* suffix */
! 	packerPrintf(p, "-%" PRINTF_OFF_T, spec->length);
      else if (!known_spec(spec->length))		/* trailer */
! 	packerPrintf(p, "%" PRINTF_OFF_T "-", spec->offset);
      else			/* range */
! 	packerPrintf(p, "%" PRINTF_OFF_T "-%" PRINTF_OFF_T,
! 	    spec->offset, spec->offset + spec->length - 1);
  }
  
  /* fills "absent" positions in range specification based on response body size 
***************
*** 151,158 ****
  static int
  httpHdrRangeSpecCanonize(HttpHdrRangeSpec * spec, size_t clen)
  {
!     debug(64, 5) ("httpHdrRangeSpecCanonize: have: [%ld, %ld) len: %ld\n",
! 	(long int) spec->offset, (long int) spec->offset + spec->length, (long int) spec->length);
      if (!known_spec(spec->offset))	/* suffix */
  	spec->offset = size_diff(clen, spec->length);
      else if (!known_spec(spec->length))		/* trailer */
--- 151,158 ----
  static int
  httpHdrRangeSpecCanonize(HttpHdrRangeSpec * spec, size_t clen)
  {
!     debug(64, 5) ("httpHdrRangeSpecCanonize: have: [%" PRINTF_OFF_T ", %" PRINTF_OFF_T ") len: %" PRINTF_OFF_T "\n",
! 	spec->offset, spec->offset + spec->length, spec->length);
      if (!known_spec(spec->offset))	/* suffix */
  	spec->offset = size_diff(clen, spec->length);
      else if (!known_spec(spec->length))		/* trailer */
***************
*** 162,169 ****
      assert(known_spec(spec->offset));
      spec->length = size_min(size_diff(clen, spec->offset), spec->length);
      /* check range validity */
!     debug(64, 5) ("httpHdrRangeSpecCanonize: done: [%ld, %ld) len: %ld\n",
! 	(long int) spec->offset, (long int) spec->offset + (long int) spec->length, (long int) spec->length);
      return spec->length > 0;
  }
  
--- 162,169 ----
      assert(known_spec(spec->offset));
      spec->length = size_min(size_diff(clen, spec->offset), spec->length);
      /* check range validity */
!     debug(64, 5) ("httpHdrRangeSpecCanonize: done: [%" PRINTF_OFF_T ", %" PRINTF_OFF_T ") len: %" PRINTF_OFF_T "\n",
! 	spec->offset, spec->offset + spec->length, spec->length);
      return spec->length > 0;
  }
  
***************
*** 303,309 ****
   *   - there is at least one range spec
   */
  int
! httpHdrRangeCanonize(HttpHdrRange * range, ssize_t clen)
  {
      int i;
      HttpHdrRangeSpec *spec;
--- 303,309 ----
   *   - there is at least one range spec
   */
  int
! httpHdrRangeCanonize(HttpHdrRange * range, squid_off_t clen)
  {
      int i;
      HttpHdrRangeSpec *spec;
***************
*** 415,424 ****
   * Returns lowest known offset in range spec(s), or range_spec_unknown
   * this is used for size limiting
   */
! ssize_t
  httpHdrRangeFirstOffset(const HttpHdrRange * range)
  {
!     ssize_t offset = range_spec_unknown;
      HttpHdrRangePos pos = HttpHdrRangeInitPos;
      const HttpHdrRangeSpec *spec;
      assert(range);
--- 415,424 ----
   * Returns lowest known offset in range spec(s), or range_spec_unknown
   * this is used for size limiting
   */
! squid_off_t
  httpHdrRangeFirstOffset(const HttpHdrRange * range)
  {
!     squid_off_t offset = range_spec_unknown;
      HttpHdrRangePos pos = HttpHdrRangeInitPos;
      const HttpHdrRangeSpec *spec;
      assert(range);
***************
*** 435,445 ****
   * ranges are combined into one, for example FTP REST.
   * Use 0 for size if unknown
   */
! ssize_t
! httpHdrRangeLowestOffset(const HttpHdrRange * range, ssize_t size)
  {
!     ssize_t offset = range_spec_unknown;
!     ssize_t current;
      HttpHdrRangePos pos = HttpHdrRangeInitPos;
      const HttpHdrRangeSpec *spec;
      assert(range);
--- 435,445 ----
   * ranges are combined into one, for example FTP REST.
   * Use 0 for size if unknown
   */
! squid_off_t
! httpHdrRangeLowestOffset(const HttpHdrRange * range, squid_off_t size)
  {
!     squid_off_t offset = range_spec_unknown;
!     squid_off_t current;
      HttpHdrRangePos pos = HttpHdrRangeInitPos;
      const HttpHdrRangeSpec *spec;
      assert(range);
Index: squid/src/HttpHeader.c
diff -c squid/src/HttpHeader.c:1.74.2.26 squid/src/HttpHeader.c:1.74.2.27
*** squid/src/HttpHeader.c:1.74.2.26	Wed Mar  9 07:37:50 2005
--- squid/src/HttpHeader.c	Fri Mar 25 19:50:50 2005
***************
*** 80,86 ****
      {"Content-Disposition", HDR_CONTENT_DISPOSITION, ftStr},
      {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
      {"Content-Language", HDR_CONTENT_LANGUAGE, ftStr},
!     {"Content-Length", HDR_CONTENT_LENGTH, ftInt},
      {"Content-Location", HDR_CONTENT_LOCATION, ftStr},
      {"Content-MD5", HDR_CONTENT_MD5, ftStr},	/* for now */
      {"Content-Range", HDR_CONTENT_RANGE, ftPContRange},
--- 80,86 ----
      {"Content-Disposition", HDR_CONTENT_DISPOSITION, ftStr},
      {"Content-Encoding", HDR_CONTENT_ENCODING, ftStr},
      {"Content-Language", HDR_CONTENT_LANGUAGE, ftStr},
!     {"Content-Length", HDR_CONTENT_LENGTH, ftSize},
      {"Content-Location", HDR_CONTENT_LOCATION, ftStr},
      {"Content-MD5", HDR_CONTENT_MD5, ftStr},	/* for now */
      {"Content-Range", HDR_CONTENT_RANGE, ftPContRange},
***************
*** 814,819 ****
--- 814,830 ----
  }
  
  void
+ httpHeaderPutSize(HttpHeader * hdr, http_hdr_type id, squid_off_t number)
+ {
+     char size[64];
+     assert_eid(id);
+     assert(Headers[id].type == ftSize);		/* must be of an appropriate type */
+     assert(number >= 0);
+     snprintf(size, sizeof(size), "%" PRINTF_OFF_T, number);
+     httpHeaderAddEntry(hdr, httpHeaderEntryCreate(id, NULL, size));
+ }
+ 
+ void
  httpHeaderPutTime(HttpHeader * hdr, http_hdr_type id, time_t htime)
  {
      assert_eid(id);
***************
*** 919,924 ****
--- 930,950 ----
      return value;
  }
  
+ squid_off_t
+ httpHeaderGetSize(const HttpHeader * hdr, http_hdr_type id)
+ {
+     HttpHeaderEntry *e;
+     squid_off_t value = -1;
+     int ok;
+     assert_eid(id);
+     assert(Headers[id].type == ftSize);		/* must be of an appropriate type */
+     if ((e = httpHeaderFindEntry(hdr, id))) {
+ 	ok = httpHeaderParseSize(strBuf(e->value), &value);
+ 	httpHeaderNoteParsedEntry(e->id, e->value, !ok);
+     }
+     return value;
+ }
+ 
  time_t
  httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id)
  {
Index: squid/src/HttpHeaderTools.c
diff -c squid/src/HttpHeaderTools.c:1.32.2.3 squid/src/HttpHeaderTools.c:1.32.2.4
*** squid/src/HttpHeaderTools.c:1.32.2.3	Sat Sep 25 05:56:16 2004
--- squid/src/HttpHeaderTools.c	Fri Mar 25 19:50:51 2005
***************
*** 138,144 ****
  
  /* wrapper arrounf PutContRange */
  void
! httpHeaderAddContRange(HttpHeader * hdr, HttpHdrRangeSpec spec, ssize_t ent_len)
  {
      HttpHdrContRange *cr = httpHdrContRangeCreate();
      assert(hdr && ent_len >= 0);
--- 138,144 ----
  
  /* wrapper arrounf PutContRange */
  void
! httpHeaderAddContRange(HttpHeader * hdr, HttpHdrRangeSpec spec, squid_off_t ent_len)
  {
      HttpHdrContRange *cr = httpHdrContRangeCreate();
      assert(hdr && ent_len >= 0);
***************
*** 316,326 ****
      return 1;
  }
  
! int
! httpHeaderParseSize(const char *start, ssize_t * value)
  {
!     int v;
!     const int res = httpHeaderParseInt(start, &v);
      assert(value);
      *value = res ? v : 0;
      return res;
--- 316,329 ----
      return 1;
  }
  
! squid_off_t
! httpHeaderParseSize(const char *start, squid_off_t * value)
  {
!     squid_off_t v;
!     char *end;
!     int res;
!     v = strto_off_t(start, &end, 10);
!     res = start != end;
      assert(value);
      *value = res ? v : 0;
      return res;
Index: squid/src/HttpReply.c
diff -c squid/src/HttpReply.c:1.49.2.4 squid/src/HttpReply.c:1.49.2.5
*** squid/src/HttpReply.c:1.49.2.4	Fri Jan 21 05:22:59 2005
--- squid/src/HttpReply.c	Fri Mar 25 19:50:51 2005
***************
*** 135,141 ****
   * returns true on success.
   */
  int
! httpReplyParse(HttpReply * rep, const char *buf, ssize_t end)
  {
      /*
       * this extra buffer/copy will be eliminated when headers become
--- 135,141 ----
   * returns true on success.
   */
  int
! httpReplyParse(HttpReply * rep, const char *buf, size_t end)
  {
      /*
       * this extra buffer/copy will be eliminated when headers become
***************
*** 194,202 ****
      packerClean(&p);
  }
  
  MemBuf
  httpPackedReply(http_version_t ver, http_status status, const char *ctype,
!     int clen, time_t lmt, time_t expires)
  {
      HttpReply *rep = httpReplyCreate();
      MemBuf mb;
--- 194,203 ----
      packerClean(&p);
  }
  
+ #if UNUSED_CODE
  MemBuf
  httpPackedReply(http_version_t ver, http_status status, const char *ctype,
!     squid_off_t clen, time_t lmt, time_t expires)
  {
      HttpReply *rep = httpReplyCreate();
      MemBuf mb;
***************
*** 205,210 ****
--- 206,212 ----
      httpReplyDestroy(rep);
      return mb;
  }
+ #endif
  
  MemBuf
  httpPacked304Reply(const HttpReply * rep)
***************
*** 230,236 ****
  
  void
  httpReplySetHeaders(HttpReply * reply, http_version_t ver, http_status status, const char *reason,
!     const char *ctype, int clen, time_t lmt, time_t expires)
  {
      HttpHeader *hdr;
      assert(reply);
--- 232,238 ----
  
  void
  httpReplySetHeaders(HttpReply * reply, http_version_t ver, http_status status, const char *reason,
!     const char *ctype, squid_off_t clen, time_t lmt, time_t expires)
  {
      HttpHeader *hdr;
      assert(reply);
***************
*** 245,251 ****
      } else
  	reply->content_type = StringNull;
      if (clen >= 0)
! 	httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, clen);
      if (expires >= 0)
  	httpHeaderPutTime(hdr, HDR_EXPIRES, expires);
      if (lmt > 0)		/* this used to be lmt != 0 @?@ */
--- 247,253 ----
      } else
  	reply->content_type = StringNull;
      if (clen >= 0)
! 	httpHeaderPutSize(hdr, HDR_CONTENT_LENGTH, clen);
      if (expires >= 0)
  	httpHeaderPutTime(hdr, HDR_EXPIRES, expires);
      if (lmt > 0)		/* this used to be lmt != 0 @?@ */
***************
*** 267,273 ****
      hdr = &reply->header;
      httpHeaderPutStr(hdr, HDR_SERVER, full_appname_string);
      httpHeaderPutTime(hdr, HDR_DATE, squid_curtime);
!     httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, 0);
      httpHeaderPutStr(hdr, HDR_LOCATION, loc);
      reply->date = squid_curtime;
      reply->content_length = 0;
--- 269,275 ----
      hdr = &reply->header;
      httpHeaderPutStr(hdr, HDR_SERVER, full_appname_string);
      httpHeaderPutTime(hdr, HDR_DATE, squid_curtime);
!     httpHeaderPutSize(hdr, HDR_CONTENT_LENGTH, 0);
      httpHeaderPutStr(hdr, HDR_LOCATION, loc);
      reply->date = squid_curtime;
      reply->content_length = 0;
***************
*** 342,348 ****
  {
      const HttpHeader *hdr = &rep->header;
      const char *str;
!     rep->content_length = httpHeaderGetInt(hdr, HDR_CONTENT_LENGTH);
      rep->date = httpHeaderGetTime(hdr, HDR_DATE);
      rep->last_modified = httpHeaderGetTime(hdr, HDR_LAST_MODIFIED);
      str = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE);
--- 344,350 ----
  {
      const HttpHeader *hdr = &rep->header;
      const char *str;
!     rep->content_length = httpHeaderGetSize(hdr, HDR_CONTENT_LENGTH);
      rep->date = httpHeaderGetTime(hdr, HDR_DATE);
      rep->last_modified = httpHeaderGetTime(hdr, HDR_LAST_MODIFIED);
      str = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE);
***************
*** 449,455 ****
  /*
   * Returns the body size of a HTTP response
   */
! int
  httpReplyBodySize(method_t method, const HttpReply * reply)
  {
      if (reply->sline.version.major < 1)
--- 451,457 ----
  /*
   * Returns the body size of a HTTP response
   */
! squid_off_t
  httpReplyBodySize(method_t method, const HttpReply * reply)
  {
      if (reply->sline.version.major < 1)
Index: squid/src/MemBuf.c
diff -c squid/src/MemBuf.c:1.28.2.3 squid/src/MemBuf.c:1.28.2.4
*** squid/src/MemBuf.c:1.28.2.3	Tue Oct  5 15:31:25 2004
--- squid/src/MemBuf.c	Fri Mar 25 19:50:51 2005
***************
*** 192,198 ****
  
  /* calls memcpy, appends exactly size bytes, extends buffer if needed */
  void
! memBufAppend(MemBuf * mb, const char *buf, mb_size_t sz)
  {
      assert(mb && buf && sz >= 0);
      assert(mb->buf);
--- 192,198 ----
  
  /* calls memcpy, appends exactly size bytes, extends buffer if needed */
  void
! memBufAppend(MemBuf * mb, const char *buf, int sz)
  {
      assert(mb && buf && sz >= 0);
      assert(mb->buf);
Index: squid/src/MemPool.c
diff -c squid/src/MemPool.c:1.28.2.1 squid/src/MemPool.c:1.28.2.2
*** squid/src/MemPool.c:1.28.2.1	Sun Mar 10 08:18:04 2002
--- squid/src/MemPool.c	Fri Mar 25 19:50:51 2005
***************
*** 46,52 ****
  /* module globals */
  
  /* huge constant to set mem_idle_limit to "unlimited" */
! static const size_t mem_unlimited_size = 2 * 1024 * MB;
  
  /* we cannot keep idle more than this limit */
  static size_t mem_idle_limit = 0;
--- 46,52 ----
  /* module globals */
  
  /* huge constant to set mem_idle_limit to "unlimited" */
! static const size_t mem_unlimited_size = 2 * 1024 * MB - 1;
  
  /* we cannot keep idle more than this limit */
  static size_t mem_idle_limit = 0;
***************
*** 58,66 ****
  static Stack Pools;
  
  /* local prototypes */
! static void memShrink(ssize_t new_limit);
  static void memPoolDescribe(const MemPool * pool);
! static void memPoolShrink(MemPool * pool, ssize_t new_limit);
  
  
  static double
--- 58,66 ----
  static Stack Pools;
  
  /* local prototypes */
! static void memShrink(size_t new_limit);
  static void memPoolDescribe(const MemPool * pool);
! static void memPoolShrink(MemPool * pool, size_t new_limit);
  
  
  static double
***************
*** 135,143 ****
  
  
  static void
! memShrink(ssize_t new_limit)
  {
!     ssize_t start_limit = TheMeter.idle.level;
      int i;
      assert(start_limit >= 0 && new_limit >= 0);
      debug(63, 1) ("memShrink: started with %ld KB goal: %ld KB\n",
--- 135,143 ----
  
  
  static void
! memShrink(size_t new_limit)
  {
!     size_t start_limit = TheMeter.idle.level;
      int i;
      assert(start_limit >= 0 && new_limit >= 0);
      debug(63, 1) ("memShrink: started with %ld KB goal: %ld KB\n",
***************
*** 145,151 ****
      /* first phase: cut proportionally to the pool idle size */
      for (i = 0; i < Pools.count && TheMeter.idle.level > new_limit; ++i) {
  	MemPool *pool = Pools.items[i];
! 	const ssize_t target_pool_size = (size_t) ((double) pool->meter.idle.level * new_limit) / start_limit;
  	memPoolShrink(pool, target_pool_size);
      }
      debug(63, 1) ("memShrink: 1st phase done with %ld KB left\n", (long int) toKB(TheMeter.idle.level));
--- 145,151 ----
      /* first phase: cut proportionally to the pool idle size */
      for (i = 0; i < Pools.count && TheMeter.idle.level > new_limit; ++i) {
  	MemPool *pool = Pools.items[i];
! 	const size_t target_pool_size = (size_t) ((double) pool->meter.idle.level * new_limit) / start_limit;
  	memPoolShrink(pool, target_pool_size);
      }
      debug(63, 1) ("memShrink: 1st phase done with %ld KB left\n", (long int) toKB(TheMeter.idle.level));
***************
*** 276,282 ****
  }
  
  static void
! memPoolShrink(MemPool * pool, ssize_t new_limit)
  {
      assert(pool);
      assert(new_limit >= 0);
--- 276,282 ----
  }
  
  static void
! memPoolShrink(MemPool * pool, size_t new_limit)
  {
      assert(pool);
      assert(new_limit >= 0);
***************
*** 308,314 ****
  memPoolInUseSize(const MemPool * pool)
  {
      assert(pool);
!     return pool->obj_size * pool->meter.inuse.level;
  }
  
  /* to-do: make debug level a parameter? */
--- 308,314 ----
  memPoolInUseSize(const MemPool * pool)
  {
      assert(pool);
!     return (pool->obj_size * pool->meter.inuse.level);
  }
  
  /* to-do: make debug level a parameter? */
***************
*** 321,327 ****
  	(long int) toKB(memPoolInUseSize(pool)));
  }
  
! size_t
  memTotalAllocated(void)
  {
      return TheMeter.alloc.level;
--- 321,327 ----
  	(long int) toKB(memPoolInUseSize(pool)));
  }
  
! int
  memTotalAllocated(void)
  {
      return TheMeter.alloc.level;
Index: squid/src/Packer.c
diff -c squid/src/Packer.c:1.13 squid/src/Packer.c:1.13.2.1
*** squid/src/Packer.c:1.13	Thu Jan 11 17:37:14 2001
--- squid/src/Packer.c	Fri Mar 25 19:50:51 2005
***************
*** 93,99 ****
  
  /* append()'s */
  static void (*const store_append) (StoreEntry *, const char *, int) = &storeAppend;
! static void (*const memBuf_append) (MemBuf *, const char *, mb_size_t) = &memBufAppend;
  
  /* vprintf()'s */
  static void (*const store_vprintf) (StoreEntry *, const char *, va_list ap) = &storeAppendVPrintf;
--- 93,99 ----
  
  /* append()'s */
  static void (*const store_append) (StoreEntry *, const char *, int) = &storeAppend;
! static void (*const memBuf_append) (MemBuf *, const char *, int) = &memBufAppend;
  
  /* vprintf()'s */
  static void (*const store_vprintf) (StoreEntry *, const char *, va_list ap) = &storeAppendVPrintf;
***************
*** 109,115 ****
      assert(p && e);
      p->append = (append_f) store_append;
      p->vprintf = (vprintf_f) store_vprintf;
!     p->real_handler = e;
  }
  
  /* init with this to accumulate data in MemBuf */
--- 109,115 ----
      assert(p && e);
      p->append = (append_f) store_append;
      p->vprintf = (vprintf_f) store_vprintf;
!     p->real_handle = e;
  }
  
  /* init with this to accumulate data in MemBuf */
***************
*** 119,125 ****
      assert(p && mb);
      p->append = (append_f) memBuf_append;
      p->vprintf = (vprintf_f) memBuf_vprintf;
!     p->real_handler = mb;
  }
  
  /* call this when you are done */
--- 119,125 ----
      assert(p && mb);
      p->append = (append_f) memBuf_append;
      p->vprintf = (vprintf_f) memBuf_vprintf;
!     p->real_handle = mb;
  }
  
  /* call this when you are done */
***************
*** 130,144 ****
      /* it is not really necessary to do this, but, just in case... */
      p->append = NULL;
      p->vprintf = NULL;
!     p->real_handler = NULL;
  }
  
  void
  packerAppend(Packer * p, const char *buf, int sz)
  {
      assert(p);
!     assert(p->real_handler && p->append);
!     p->append(p->real_handler, buf, sz);
  }
  
  #if STDC_HEADERS
--- 130,144 ----
      /* it is not really necessary to do this, but, just in case... */
      p->append = NULL;
      p->vprintf = NULL;
!     p->real_handle = NULL;
  }
  
  void
  packerAppend(Packer * p, const char *buf, int sz)
  {
      assert(p);
!     assert(p->real_handle && p->append);
!     p->append(p->real_handle, buf, sz);
  }
  
  #if STDC_HEADERS
***************
*** 161,167 ****
      fmt = va_arg(args, char *);
  #endif
      assert(p);
!     assert(p->real_handler && p->vprintf);
!     p->vprintf(p->real_handler, fmt, args);
      va_end(args);
  }
--- 161,167 ----
      fmt = va_arg(args, char *);
  #endif
      assert(p);
!     assert(p->real_handle && p->vprintf);
!     p->vprintf(p->real_handle, fmt, args);
      va_end(args);
  }
Index: squid/src/access_log.c
diff -c squid/src/access_log.c:1.72.2.6 squid/src/access_log.c:1.72.2.8
*** squid/src/access_log.c:1.72.2.6	Mon Sep 27 16:34:19 2004
--- squid/src/access_log.c	Tue Mar 29 16:13:11 2005
***************
*** 245,258 ****
  	client = inet_ntoa(al->cache.caddr);
      user = accessLogFormatName(al->cache.authuser ?
  	al->cache.authuser : al->cache.rfc931);
!     logfilePrintf(logfile, "%9d.%03d %6d %s %s/%03d %lu %s %s %s %s%s/%s %s",
! 	(int) current_time.tv_sec,
  	(int) current_time.tv_usec / 1000,
  	al->cache.msec,
  	client,
  	log_tags[al->cache.code],
  	al->http.code,
! 	(unsigned long) al->cache.size,
  	al->private.method_str,
  	al->url,
  	user && *user ? user : dash_str,
--- 245,258 ----
  	client = inet_ntoa(al->cache.caddr);
      user = accessLogFormatName(al->cache.authuser ?
  	al->cache.authuser : al->cache.rfc931);
!     logfilePrintf(logfile, "%9ld.%03d %6d %s %s/%03d %" PRINTF_OFF_T " %s %s %s %s%s/%s %s",
! 	(long int) current_time.tv_sec,
  	(int) current_time.tv_usec / 1000,
  	al->cache.msec,
  	client,
  	log_tags[al->cache.code],
  	al->http.code,
! 	al->cache.size,
  	al->private.method_str,
  	al->url,
  	user && *user ? user : dash_str,
***************
*** 274,280 ****
  	client = inet_ntoa(al->cache.caddr);
      user1 = accessLogFormatName(al->cache.authuser);
      user2 = accessLogFormatName(al->cache.rfc931);
!     logfilePrintf(logfile, "%s %s %s [%s] \"%s %s HTTP/%d.%d\" %d %ld %s:%s",
  	client,
  	user2 ? user2 : dash_str,
  	user1 ? user1 : dash_str,
--- 274,280 ----
  	client = inet_ntoa(al->cache.caddr);
      user1 = accessLogFormatName(al->cache.authuser);
      user2 = accessLogFormatName(al->cache.rfc931);
!     logfilePrintf(logfile, "%s %s %s [%s] \"%s %s HTTP/%d.%d\" %d %" PRINTF_OFF_T " %s:%s",
  	client,
  	user2 ? user2 : dash_str,
  	user1 ? user1 : dash_str,
***************
*** 283,289 ****
  	al->url,
  	al->http.version.major, al->http.version.minor,
  	al->http.code,
! 	(long int) al->cache.size,
  	log_tags[al->cache.code],
  	hier_strings[al->hier.code]);
      safe_free(user1);
--- 283,289 ----
  	al->url,
  	al->http.version.major, al->http.version.minor,
  	al->http.code,
! 	al->cache.size,
  	log_tags[al->cache.code],
  	hier_strings[al->hier.code]);
      safe_free(user1);
Index: squid/src/asn.c
diff -c squid/src/asn.c:1.78.2.1 squid/src/asn.c:1.78.2.2
*** squid/src/asn.c:1.78.2.1	Wed Jun 18 17:53:34 2003
--- squid/src/asn.c	Fri Mar 25 19:50:51 2005
***************
*** 73,80 ****
      store_client *sc;
      request_t *request;
      int as_number;
!     off_t seen;
!     off_t offset;
  };
  
  typedef struct _ASState ASState;
--- 73,80 ----
      store_client *sc;
      request_t *request;
      int as_number;
!     squid_off_t seen;
!     squid_off_t offset;
  };
  
  typedef struct _ASState ASState;
Index: squid/src/authenticate.c
diff -c squid/src/authenticate.c:1.36.2.16 squid/src/authenticate.c:1.36.2.17
*** squid/src/authenticate.c:1.36.2.16	Mon Jan 10 08:35:38 2005
--- squid/src/authenticate.c	Fri Mar 25 19:50:51 2005
***************
*** 352,358 ****
  	authenticateAuthUserClearIp(auth_user_request->auth_user);
  }
  
! size_t
  authenticateAuthUserRequestIPCount(auth_user_request_t * auth_user_request)
  {
      assert(auth_user_request);
--- 352,358 ----
  	authenticateAuthUserClearIp(auth_user_request->auth_user);
  }
  
! int
  authenticateAuthUserRequestIPCount(auth_user_request_t * auth_user_request)
  {
      assert(auth_user_request);
Index: squid/src/cache_cf.c
diff -c squid/src/cache_cf.c:1.396.2.22 squid/src/cache_cf.c:1.396.2.23
*** squid/src/cache_cf.c:1.396.2.22	Wed Mar  9 07:25:49 2005
--- squid/src/cache_cf.c	Fri Mar 25 19:50:51 2005
***************
*** 78,84 ****
  static void default_all(void);
  static void defaults_if_none(void);
  static int parse_line(char *);
! static void parseBytesLine(size_t * bptr, const char *units);
  static size_t parseBytesUnits(const char *unit);
  static void free_all(void);
  void requirePathnameExists(const char *name, const char *path);
--- 78,84 ----
  static void default_all(void);
  static void defaults_if_none(void);
  static int parse_line(char *);
! static void parseBytesLine(squid_off_t * bptr, const char *units);
  static size_t parseBytesUnits(const char *unit);
  static void free_all(void);
  void requirePathnameExists(const char *name, const char *path);
***************
*** 211,220 ****
  GetInteger(void)
  {
      char *token = strtok(NULL, w_space);
      int i;
      if (token == NULL)
  	self_destruct();
!     if (sscanf(token, "%d", &i) != 1)
  	self_destruct();
      return i;
  }
--- 211,245 ----
  GetInteger(void)
  {
      char *token = strtok(NULL, w_space);
+     char *end;
      int i;
+     double d;
      if (token == NULL)
  	self_destruct();
!     i = strtol(token, &end, 0);
!     d = strtod(token, NULL);
!     if (d > INT_MAX || end == token)
! 	self_destruct();
!     return i;
! }
! 
! static squid_off_t
! GetOffT(void)
! {
!     char *token = strtok(NULL, w_space);
!     char *end;
!     squid_off_t i;
!     if (token == NULL)
! 	self_destruct();
!     i = strto_off_t(token, &end, 0);
! #if SIZEOF_SQUID_OFF_T <= 4
!     {
! 	double d = strtod(token, NULL);
! 	if (d > INT_MAX)
! 	    end = token;
!     }
! #endif
!     if (end == token)
  	self_destruct();
      return i;
  }
***************
*** 223,229 ****
  update_maxobjsize(void)
  {
      int i;
!     ssize_t ms = -1;
  
      for (i = 0; i < Config.cacheSwap.n_configured; i++) {
  	if (Config.cacheSwap.swapDirs[i].max_objsize > ms)
--- 248,254 ----
  update_maxobjsize(void)
  {
      int i;
!     squid_off_t ms = -1;
  
      for (i = 0; i < Config.cacheSwap.n_configured; i++) {
  	if (Config.cacheSwap.swapDirs[i].max_objsize > ms)
***************
*** 440,445 ****
--- 465,490 ----
  	debug(22, 0) ("NOTICE: positive_dns_ttl must be larger than negative_dns_ttl. Resetting negative_dns_ttl to match\n");
  	Config.positiveDnsTtl = Config.negativeDnsTtl;
      }
+ #if SIZEOF_SQUID_FILE_SZ <= 4
+ #if SIZEOF_SQUID_OFF_T <= 4
+     if (Config.Store.maxObjectSize > 0x7FFF0000) {
+ 	debug(22, 0) ("NOTICE: maximum_object_size limited to %d KB due to hardware limitations\n", 0x7FFF0000 / 1024);
+ 	Config.Store.maxObjectSize = 0x7FFF0000;
+     }
+ #elif SIZEOF_OFF_T <= 4
+     if (Config.Store.maxObjectSize > 0xFFFF0000) {
+ 	debug(22, 0) ("NOTICE: maximum_object_size limited to %d KB due to OS limitations\n", 0xFFFF0000 / 1024);
+ 	Config.Store.maxObjectSize = 0xFFFF0000;
+     }
+ #else
+     if (Config.Store.maxObjectSize > 0xFFFF0000) {
+ 	debug(22, 0) ("NOTICE: maximum_object_size limited to %d KB to keep compatibility with existing cache\n", 0xFFFF0000 / 1024);
+ 	Config.Store.maxObjectSize = 0xFFFF0000;
+     }
+ #endif
+ #endif
+     if (Config.Store.maxInMemObjSize > 8 * 1024 * 1024)
+ 	debug(22, 0) ("WARNING: Very large maximum_object_size_in_memory settings can have negative impact on performance\n");
  }
  
  /* Parse a time specification from the config file.  Store the
***************
*** 493,510 ****
  }
  
  static void
! parseBytesLine(size_t * bptr, const char *units)
  {
      char *token;
      double d;
!     size_t m;
!     size_t u;
      if ((u = parseBytesUnits(units)) == 0)
  	self_destruct();
      if ((token = strtok(NULL, w_space)) == NULL)
  	self_destruct();
      if (strcmp(token, "none") == 0 || strcmp(token, "-1") == 0) {
! 	*bptr = (size_t) - 1;
  	return;
      }
      d = atof(token);
--- 538,555 ----
  }
  
  static void
! parseBytesLine(squid_off_t * bptr, const char *units)
  {
      char *token;
      double d;
!     squid_off_t m;
!     squid_off_t u;
      if ((u = parseBytesUnits(units)) == 0)
  	self_destruct();
      if ((token = strtok(NULL, w_space)) == NULL)
  	self_destruct();
      if (strcmp(token, "none") == 0 || strcmp(token, "-1") == 0) {
! 	*bptr = (squid_off_t) - 1;
  	return;
      }
      d = atof(token);
***************
*** 1324,1335 ****
  static void
  parse_cachedir_option_maxsize(SwapDir * sd, const char *option, const char *value, int reconfiguring)
  {
!     ssize_t size;
  
      if (!value)
  	self_destruct();
  
!     size = atoi(value);
  
      if (reconfiguring && sd->max_objsize != size)
  	debug(3, 1) ("Cache dir '%s' max object size now %ld\n", sd->path, (long int) size);
--- 1369,1380 ----
  static void
  parse_cachedir_option_maxsize(SwapDir * sd, const char *option, const char *value, int reconfiguring)
  {
!     squid_off_t size;
  
      if (!value)
  	self_destruct();
  
!     size = strto_off_t(value, NULL, 10);
  
      if (reconfiguring && sd->max_objsize != size)
  	debug(3, 1) ("Cache dir '%s' max object size now %ld\n", sd->path, (long int) size);
***************
*** 2074,2107 ****
      *var = 0;
  }
  
  static void
! dump_size_t(StoreEntry * entry, const char *name, size_t var)
  {
!     storeAppendPrintf(entry, "%s %d\n", name, (int) var);
  }
  
! static void
! dump_b_size_t(StoreEntry * entry, const char *name, size_t var)
! {
!     storeAppendPrintf(entry, "%s %d %s\n", name, (int) var, B_BYTES_STR);
! }
  
  static void
! dump_kb_size_t(StoreEntry * entry, const char *name, size_t var)
  {
!     storeAppendPrintf(entry, "%s %d %s\n", name, (int) var, B_KBYTES_STR);
  }
  
  static void
! parse_size_t(size_t * var)
  {
!     int i;
!     i = GetInteger();
!     *var = (size_t) i;
  }
  
  static void
! parse_b_size_t(size_t * var)
  {
      parseBytesLine(var, B_BYTES_STR);
  }
--- 2119,2147 ----
      *var = 0;
  }
  
+ #if UNUSED_CODE
  static void
! dump_size_t(StoreEntry * entry, const char *name, squid_off_t var)
  {
!     storeAppendPrintf(entry, "%s %" PRINTF_OFF_T "\n", name, var);
  }
  
! #endif
  
  static void
! dump_b_size_t(StoreEntry * entry, const char *name, squid_off_t var)
  {
!     storeAppendPrintf(entry, "%s %" PRINTF_OFF_T " %s\n", name, var, B_BYTES_STR);
  }
  
  static void
! dump_kb_size_t(StoreEntry * entry, const char *name, squid_off_t var)
  {
!     storeAppendPrintf(entry, "%s %" PRINTF_OFF_T " %s\n", name, var, B_KBYTES_STR);
  }
  
  static void
! parse_b_size_t(squid_off_t * var)
  {
      parseBytesLine(var, B_BYTES_STR);
  }
***************
*** 2114,2120 ****
      body_size *bs;
      CBDATA_INIT_TYPE(body_size);
      bs = cbdataAlloc(body_size);
!     parse_size_t(&bs->maxsize);
      aclParseAccessLine(&bs->access_list);
  
      dlinkAddTail(bs, &bs->node, bodylist);
--- 2154,2160 ----
      body_size *bs;
      CBDATA_INIT_TYPE(body_size);
      bs = cbdataAlloc(body_size);
!     bs->maxsize = GetOffT();
      aclParseAccessLine(&bs->access_list);
  
      dlinkAddTail(bs, &bs->node, bodylist);
***************
*** 2129,2135 ****
  	acl_list *l;
  	acl_access *head = bs->access_list;
  	while (head != NULL) {
! 	    storeAppendPrintf(entry, "%s %ld %s", name, (long int) bs->maxsize,
  		head->allow ? "Allow" : "Deny");
  	    for (l = head->acl_list; l != NULL; l = l->next) {
  		storeAppendPrintf(entry, " %s%s",
--- 2169,2175 ----
  	acl_list *l;
  	acl_access *head = bs->access_list;
  	while (head != NULL) {
! 	    storeAppendPrintf(entry, "%s %" PRINTF_OFF_T " %s", name, bs->maxsize,
  		head->allow ? "Allow" : "Deny");
  	    for (l = head->acl_list; l != NULL; l = l->next) {
  		storeAppendPrintf(entry, " %s%s",
***************
*** 2166,2178 ****
  
  
  static void
! parse_kb_size_t(size_t * var)
  {
      parseBytesLine(var, B_KBYTES_STR);
  }
  
  static void
! free_size_t(size_t * var)
  {
      *var = 0;
  }
--- 2206,2218 ----
  
  
  static void
! parse_kb_size_t(squid_off_t * var)
  {
      parseBytesLine(var, B_KBYTES_STR);
  }
  
  static void
! free_size_t(squid_off_t * var)
  {
      *var = 0;
  }
Index: squid/src/cachemgr.c
diff -c squid/src/cachemgr.c:1.90.2.6 squid/src/cachemgr.c:1.90.2.7
*** squid/src/cachemgr.c:1.90.2.6	Sun Nov 10 10:07:44 2002
--- squid/src/cachemgr.c	Fri Mar 25 19:50:51 2005
***************
*** 735,741 ****
  make_auth_header(const cachemgr_request * req)
  {
      static char buf[1024];
!     off_t l = 0;
      const char *str64;
      if (!req->passwd)
  	return "";
--- 735,741 ----
  make_auth_header(const cachemgr_request * req)
  {
      static char buf[1024];
!     int l = 0;
      const char *str64;
      if (!req->passwd)
  	return "";
Index: squid/src/cf.data.pre
diff -c squid/src/cf.data.pre:1.245.2.87 squid/src/cf.data.pre:1.245.2.88
*** squid/src/cf.data.pre:1.245.2.87	Wed Mar  9 07:22:33 2005
--- squid/src/cf.data.pre	Fri Mar 25 19:50:51 2005
***************
*** 1046,1052 ****
  DOC_END
  
  NAME: ftp_list_width
! TYPE: size_t
  DEFAULT: 32
  LOC: Config.Ftp.list_width
  DOC_START
--- 1046,1052 ----
  DOC_END
  
  NAME: ftp_list_width
! TYPE: int
  DEFAULT: 32
  LOC: Config.Ftp.list_width
  DOC_START
Index: squid/src/client.c
diff -c squid/src/client.c:1.94.2.6 squid/src/client.c:1.94.2.8
*** squid/src/client.c:1.94.2.6	Tue Feb 17 20:45:30 2004
--- squid/src/client.c	Wed Mar 30 14:13:55 2005
***************
*** 311,317 ****
      }
      loops = ping ? pcount : 1;
      for (i = 0; loops == 0 || i < loops; i++) {
! 	int fsize = 0;
  	/* Connect to the server */
  	if ((conn = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
  	    perror("client: socket");
--- 311,317 ----
      }
      loops = ping ? pcount : 1;
      for (i = 0; loops == 0 || i < loops; i++) {
! 	squid_off_t fsize = 0;
  	/* Connect to the server */
  	if ((conn = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
  	    perror("client: socket");
***************
*** 321,327 ****
  	    perror("client: bind");
  	    exit(1);
  	}
! 	if (client_comm_connect(conn, hostname, port, ping ? &tv1 : NULL) < 0) {
  	    if (errno == 0) {
  		fprintf(stderr, "client: ERROR: Cannot connect to %s:%d: Host unknown.\n", hostname, port);
  	    } else {
--- 321,327 ----
  	    perror("client: bind");
  	    exit(1);
  	}
! 	if (client_comm_connect(conn, hostname, port, (ping || opt_verbose) ? &tv1 : NULL) < 0) {
  	    if (errno == 0) {
  		fprintf(stderr, "client: ERROR: Cannot connect to %s:%d: Host unknown.\n", hostname, port);
  	    } else {
***************
*** 365,371 ****
  	if (interrupted)
  	    break;
  
! 	if (ping) {
  	    struct tm *tmp;
  	    time_t t2s;
  	    long elapsed_msec;
--- 365,371 ----
  	if (interrupted)
  	    break;
  
! 	if (ping || opt_verbose) {
  	    struct tm *tmp;
  	    time_t t2s;
  	    long elapsed_msec;
***************
*** 374,391 ****
  	    elapsed_msec = tvSubMsec(tv1, tv2);
  	    t2s = tv2.tv_sec;
  	    tmp = localtime(&t2s);
! 	    fprintf(stderr, "%d-%02d-%02d %02d:%02d:%02d [%d]: %ld.%03ld secs, %f KB/s\n",
  		tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
  		tmp->tm_hour, tmp->tm_min, tmp->tm_sec, i + 1,
  		elapsed_msec / 1000, elapsed_msec % 1000,
! 		elapsed_msec ? (double) fsize / elapsed_msec : -1.0);
  	    if (i == 0 || elapsed_msec < ping_min)
  		ping_min = elapsed_msec;
  	    if (i == 0 || elapsed_msec > ping_max)
  		ping_max = elapsed_msec;
  	    ping_sum += elapsed_msec;
  	    /* Delay until next "ping_int" boundary */
! 	    if ((loops == 0 || i + 1 < loops) && elapsed_msec < ping_int) {
  		struct timeval tvs;
  		long msec_left = ping_int - elapsed_msec;
  
--- 374,392 ----
  	    elapsed_msec = tvSubMsec(tv1, tv2);
  	    t2s = tv2.tv_sec;
  	    tmp = localtime(&t2s);
! 	    fprintf(stderr, "%d-%02d-%02d %02d:%02d:%02d [%d]: %ld.%03ld secs, %f KB/s (%" PRINTF_OFF_T "KB)\n",
  		tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
  		tmp->tm_hour, tmp->tm_min, tmp->tm_sec, i + 1,
  		elapsed_msec / 1000, elapsed_msec % 1000,
! 		elapsed_msec ? (double) fsize / elapsed_msec * 1000 / 1024 : -1.0,
! 		(fsize + 1023) / 1024);
  	    if (i == 0 || elapsed_msec < ping_min)
  		ping_min = elapsed_msec;
  	    if (i == 0 || elapsed_msec > ping_max)
  		ping_max = elapsed_msec;
  	    ping_sum += elapsed_msec;
  	    /* Delay until next "ping_int" boundary */
! 	    if (ping && (loops == 0 || i + 1 < loops) && elapsed_msec < ping_int) {
  		struct timeval tvs;
  		long msec_left = ping_int - elapsed_msec;
  
Index: squid/src/client_db.c
diff -c squid/src/client_db.c:1.53.2.4 squid/src/client_db.c:1.53.2.5
*** squid/src/client_db.c:1.53.2.4	Mon Oct 11 14:25:52 2004
--- squid/src/client_db.c	Fri Mar 25 19:50:52 2005
***************
*** 77,83 ****
  }
  
  void
! clientdbUpdate(struct in_addr addr, log_type ltype, protocol_t p, size_t size)
  {
      char *key;
      ClientInfo *c;
--- 77,83 ----
  }
  
  void
! clientdbUpdate(struct in_addr addr, log_type ltype, protocol_t p, squid_off_t size)
  {
      char *key;
      ClientInfo *c;
Index: squid/src/client_side.c
diff -c squid/src/client_side.c:1.561.2.74 squid/src/client_side.c:1.561.2.75
*** squid/src/client_side.c:1.561.2.74	Wed Mar  9 07:09:03 2005
--- squid/src/client_side.c	Fri Mar 25 19:50:52 2005
***************
*** 125,132 ****
  static int clientCheckContentLength(request_t * r);
  static DEFER httpAcceptDefer;
  static log_type clientProcessRequest2(clientHttpRequest * http);
! static int clientReplyBodyTooLarge(clientHttpRequest *, ssize_t clen);
! static int clientRequestBodyTooLarge(int clen);
  static void clientProcessBody(ConnStateData * conn);
  static void clientEatRequestBody(clientHttpRequest *);
  static BODY_HANDLER clientReadBody;
--- 125,132 ----
  static int clientCheckContentLength(request_t * r);
  static DEFER httpAcceptDefer;
  static log_type clientProcessRequest2(clientHttpRequest * http);
! static int clientReplyBodyTooLarge(clientHttpRequest *, squid_off_t clen);
! static int clientRequestBodyTooLarge(squid_off_t clen);
  static void clientProcessBody(ConnStateData * conn);
  static void clientEatRequestBody(clientHttpRequest *);
  static BODY_HANDLER clientReadBody;
***************
*** 603,609 ****
  int
  modifiedSince(StoreEntry * entry, request_t * request)
  {
!     int object_length;
      MemObject *mem = entry->mem_obj;
      time_t mod_time = entry->lastmod;
      debug(33, 3) ("modifiedSince: '%s'\n", storeUrl(entry));
--- 603,609 ----
  int
  modifiedSince(StoreEntry * entry, request_t * request)
  {
!     squid_off_t object_length;
      MemObject *mem = entry->mem_obj;
      time_t mod_time = entry->lastmod;
      debug(33, 3) ("modifiedSince: '%s'\n", storeUrl(entry));
***************
*** 1225,1234 ****
   * warning: assumes that HTTP headers for individual ranges at the
   *          time of the actuall assembly will be exactly the same as
   *          the headers when clientMRangeCLen() is called */
! static int
  clientMRangeCLen(clientHttpRequest * http)
  {
!     int clen = 0;
      HttpHdrRangePos pos = HttpHdrRangeInitPos;
      const HttpHdrRangeSpec *spec;
      MemBuf mb;
--- 1225,1234 ----
   * warning: assumes that HTTP headers for individual ranges at the
   *          time of the actuall assembly will be exactly the same as
   *          the headers when clientMRangeCLen() is called */
! static squid_off_t
  clientMRangeCLen(clientHttpRequest * http)
  {
!     squid_off_t clen = 0;
      HttpHdrRangePos pos = HttpHdrRangeInitPos;
      const HttpHdrRangeSpec *spec;
      MemBuf mb;
***************
*** 1247,1254 ****
  	/* account for range content */
  	clen += spec->length;
  
! 	debug(33, 6) ("clientMRangeCLen: (clen += %ld + %ld) == %d\n",
! 	    (long int) mb.size, (long int) spec->length, clen);
      }
      /* account for the terminating boundary */
      memBufReset(&mb);
--- 1247,1254 ----
  	/* account for range content */
  	clen += spec->length;
  
! 	debug(33, 6) ("clientMRangeCLen: (clen += %ld + %" PRINTF_OFF_T ") == %" PRINTF_OFF_T "\n",
! 	    (long int) mb.size, spec->length, clen);
      }
      /* account for the terminating boundary */
      memBufReset(&mb);
***************
*** 1295,1303 ****
  	http->request->range = NULL;
      } else {
  	const int spec_count = http->request->range->specs.count;
! 	int actual_clen = -1;
  
! 	debug(33, 3) ("clientBuildRangeHeader: range spec count: %d virgin clen: %d\n",
  	    spec_count, rep->content_length);
  	assert(spec_count > 0);
  	/* ETags should not be returned with Partial Content replies? */
--- 1295,1303 ----
  	http->request->range = NULL;
      } else {
  	const int spec_count = http->request->range->specs.count;
! 	squid_off_t actual_clen = -1;
  
! 	debug(33, 3) ("clientBuildRangeHeader: range spec count: %d virgin clen: %" PRINTF_OFF_T "\n",
  	    spec_count, rep->content_length);
  	assert(spec_count > 0);
  	/* ETags should not be returned with Partial Content replies? */
***************
*** 1329,1336 ****
  	/* replace Content-Length header */
  	assert(actual_clen >= 0);
  	httpHeaderDelById(hdr, HDR_CONTENT_LENGTH);
! 	httpHeaderPutInt(hdr, HDR_CONTENT_LENGTH, actual_clen);
! 	debug(33, 3) ("clientBuildRangeHeader: actual content length: %d\n", actual_clen);
      }
  }
  
--- 1329,1336 ----
  	/* replace Content-Length header */
  	assert(actual_clen >= 0);
  	httpHeaderDelById(hdr, HDR_CONTENT_LENGTH);
! 	httpHeaderPutSize(hdr, HDR_CONTENT_LENGTH, actual_clen);
! 	debug(33, 3) ("clientBuildRangeHeader: actual content length: %" PRINTF_OFF_T "\n", actual_clen);
      }
  }
  
***************
*** 1734,1744 ****
  clientPackRange(clientHttpRequest * http,
      HttpHdrRangeIter * i,
      const char **buf,
!     ssize_t * size,
      MemBuf * mb)
  {
!     const ssize_t copy_sz = i->debt_size <= *size ? i->debt_size : *size;
!     off_t body_off = http->out.offset - i->prefix_size;
      assert(*size > 0);
      assert(i->spec);
      /*
--- 1734,1744 ----
  clientPackRange(clientHttpRequest * http,
      HttpHdrRangeIter * i,
      const char **buf,
!     size_t * size,
      MemBuf * mb)
  {
!     const size_t copy_sz = i->debt_size <= *size ? i->debt_size : *size;
!     squid_off_t body_off = http->out.offset - i->prefix_size;
      assert(*size > 0);
      assert(i->spec);
      /*
***************
*** 1782,1788 ****
   * increments iterator "i"
   * used by clientPackMoreRanges */
  static int
! clientCanPackMoreRanges(const clientHttpRequest * http, HttpHdrRangeIter * i, ssize_t size)
  {
      /* first update "i" if needed */
      if (!i->debt_size) {
--- 1782,1788 ----
   * increments iterator "i"
   * used by clientPackMoreRanges */
  static int
! clientCanPackMoreRanges(const clientHttpRequest * http, HttpHdrRangeIter * i, size_t size)
  {
      /* first update "i" if needed */
      if (!i->debt_size) {
***************
*** 1797,1813 ****
  /* extracts "ranges" from buf and appends them to mb, updating all offsets and such */
  /* returns true if we need more data */
  static int
! clientPackMoreRanges(clientHttpRequest * http, const char *buf, ssize_t size, MemBuf * mb)
  {
      HttpHdrRangeIter *i = &http->range_iter;
      /* offset in range specs does not count the prefix of an http msg */
!     off_t body_off = http->out.offset - i->prefix_size;
      assert(size >= 0);
      /* check: reply was parsed and range iterator was initialized */
      assert(i->prefix_size > 0);
      /* filter out data according to range specs */
      while (clientCanPackMoreRanges(http, i, size)) {
! 	off_t start;		/* offset of still missing data */
  	assert(i->spec);
  	start = i->spec->offset + i->spec->length - i->debt_size;
  	debug(33, 3) ("clientPackMoreRanges: in:  offset: %ld size: %ld\n",
--- 1797,1813 ----
  /* extracts "ranges" from buf and appends them to mb, updating all offsets and such */
  /* returns true if we need more data */
  static int
! clientPackMoreRanges(clientHttpRequest * http, const char *buf, size_t size, MemBuf * mb)
  {
      HttpHdrRangeIter *i = &http->range_iter;
      /* offset in range specs does not count the prefix of an http msg */
!     squid_off_t body_off = http->out.offset - i->prefix_size;
      assert(size >= 0);
      /* check: reply was parsed and range iterator was initialized */
      assert(i->prefix_size > 0);
      /* filter out data according to range specs */
      while (clientCanPackMoreRanges(http, i, size)) {
! 	squid_off_t start;	/* offset of still missing data */
  	assert(i->spec);
  	start = i->spec->offset + i->spec->length - i->debt_size;
  	debug(33, 3) ("clientPackMoreRanges: in:  offset: %ld size: %ld\n",
***************
*** 1881,1887 ****
  }
  
  static int
! clientReplyBodyTooLarge(clientHttpRequest * http, ssize_t clen)
  {
      if (0 == http->maxBodySize)
  	return 0;		/* disabled */
--- 1881,1887 ----
  }
  
  static int
! clientReplyBodyTooLarge(clientHttpRequest * http, squid_off_t clen)
  {
      if (0 == http->maxBodySize)
  	return 0;		/* disabled */
***************
*** 1893,1899 ****
  }
  
  static int
! clientRequestBodyTooLarge(int clen)
  {
      if (0 == Config.maxRequestBodySize)
  	return 0;		/* disabled */
--- 1893,1899 ----
  }
  
  static int
! clientRequestBodyTooLarge(squid_off_t clen)
  {
      if (0 == Config.maxRequestBodySize)
  	return 0;		/* disabled */
***************
*** 1944,1952 ****
      int fd = conn->fd;
      HttpReply *rep = NULL;
      const char *body_buf = buf;
!     ssize_t body_size = size;
      MemBuf mb;
!     ssize_t check_size = 0;
      debug(33, 5) ("clientSendMoreData: %s, %d bytes\n", http->uri, (int) size);
      assert(size <= CLIENT_SOCK_SZ);
      assert(http->request != NULL);
--- 1944,1952 ----
      int fd = conn->fd;
      HttpReply *rep = NULL;
      const char *body_buf = buf;
!     squid_off_t body_size = size;
      MemBuf mb;
!     squid_off_t check_size = 0;
      debug(33, 5) ("clientSendMoreData: %s, %d bytes\n", http->uri, (int) size);
      assert(size <= CLIENT_SOCK_SZ);
      assert(http->request != NULL);
***************
*** 2189,2202 ****
      StoreEntry *entry = http->entry;
      int done;
      http->out.size += size;
!     debug(33, 5) ("clientWriteComplete: FD %d, sz %ld, err %d, off %ld, len %d\n",
! 	fd, (long int) size, errflag, (long int) http->out.offset, entry ? objectLen(entry) : 0);
      if (size > 0) {
  	kb_incr(&statCounter.client_http.kbytes_out, size);
  	if (isTcpHit(http->log_type))
  	    kb_incr(&statCounter.client_http.hit_kbytes_out, size);
      }
! #if SIZEOF_SIZE_T == 4
      if (http->out.size > 0x7FFF0000) {
  	debug(33, 1) ("WARNING: closing FD %d to prevent counter overflow\n", fd);
  	debug(33, 1) ("\tclient %s\n", inet_ntoa(http->conn->peer.sin_addr));
--- 2189,2202 ----
      StoreEntry *entry = http->entry;
      int done;
      http->out.size += size;
!     debug(33, 5) ("clientWriteComplete: FD %d, sz %d, err %d, off %" PRINTF_OFF_T ", len %" PRINTF_OFF_T "\n",
! 	fd, (int) size, errflag, http->out.offset, entry ? objectLen(entry) : (squid_off_t) 0);
      if (size > 0) {
  	kb_incr(&statCounter.client_http.kbytes_out, size);
  	if (isTcpHit(http->log_type))
  	    kb_incr(&statCounter.client_http.hit_kbytes_out, size);
      }
! #if SIZEOF_SQUID_OFF_T <= 4
      if (http->out.size > 0x7FFF0000) {
  	debug(33, 1) ("WARNING: closing FD %d to prevent counter overflow\n", fd);
  	debug(33, 1) ("\tclient %s\n", inet_ntoa(http->conn->peer.sin_addr));
***************
*** 2205,2211 ****
  	comm_close(fd);
      } else
  #endif
! #if SIZEOF_OFF_T == 4
      if (http->out.offset > 0x7FFF0000) {
  	debug(33, 1) ("WARNING: closing FD %d to prevent counter overflow\n", fd);
  	debug(33, 1) ("\tclient %s\n", inet_ntoa(http->conn->peer.sin_addr));
--- 2205,2211 ----
  	comm_close(fd);
      } else
  #endif
! #if SIZEOF_SQUID_OFF_T <= 4
      if (http->out.offset > 0x7FFF0000) {
  	debug(33, 1) ("WARNING: closing FD %d to prevent counter overflow\n", fd);
  	debug(33, 1) ("\tclient %s\n", inet_ntoa(http->conn->peer.sin_addr));
***************
*** 2595,2601 ****
      static int pffd = -1;
  #endif
  #if LINUX_NETFILTER
!     size_t sock_sz = sizeof(conn->me);
  #endif
  
      /* pre-set these values to make aborting simpler */
--- 2595,2601 ----
      static int pffd = -1;
  #endif
  #if LINUX_NETFILTER
!     socklen_t sock_sz = sizeof(conn->me);
  #endif
  
      /* pre-set these values to make aborting simpler */
***************
*** 3130,3136 ****
  	    /*
  	     * cache the Content-length value in request_t.
  	     */
! 	    request->content_length = httpHeaderGetInt(&request->header,
  		HDR_CONTENT_LENGTH);
  	    request->flags.internal = http->flags.internal;
  	    safe_free(prefix);
--- 3130,3136 ----
  	    /*
  	     * cache the Content-length value in request_t.
  	     */
! 	    request->content_length = httpHeaderGetSize(&request->header,
  		HDR_CONTENT_LENGTH);
  	    request->flags.internal = http->flags.internal;
  	    safe_free(prefix);
***************
*** 3642,3648 ****
      StoreEntry *entry = http->entry;
      MemObject *mem;
      http_reply *reply;
!     int sendlen;
      if (entry == NULL)
  	return 0;
      /*
--- 3642,3648 ----
      StoreEntry *entry = http->entry;
      MemObject *mem;
      http_reply *reply;
!     squid_off_t sendlen;
      if (entry == NULL)
  	return 0;
      /*
***************
*** 3705,3711 ****
  static int
  clientGotNotEnough(clientHttpRequest * http)
  {
!     int cl = httpReplyBodySize(http->request->method, http->entry->mem_obj->reply);
      int hs = http->entry->mem_obj->reply->hdr_sz;
      assert(cl >= 0);
      if (http->out.offset < cl + hs)
--- 3705,3711 ----
  static int
  clientGotNotEnough(clientHttpRequest * http)
  {
!     squid_off_t cl = httpReplyBodySize(http->request->method, http->entry->mem_obj->reply);
      int hs = http->entry->mem_obj->reply->hdr_sz;
      assert(cl >= 0);
      if (http->out.offset < cl + hs)
Index: squid/src/defines.h
diff -c squid/src/defines.h:1.97.2.3 squid/src/defines.h:1.97.2.4
*** squid/src/defines.h:1.97.2.3	Thu Aug  8 14:17:39 2002
--- squid/src/defines.h	Fri Mar 25 19:50:52 2005
***************
*** 200,206 ****
  #define SwapMetaType(x) (char)x[0]
  #define SwapMetaSize(x) &x[sizeof(char)]
  #define SwapMetaData(x) &x[STORE_META_TLD_START]
! #define STORE_HDR_METASIZE (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(size_t))
  
  #define STORE_ENTRY_WITH_MEMOBJ		1
  #define STORE_ENTRY_WITHOUT_MEMOBJ	0
--- 200,207 ----
  #define SwapMetaType(x) (char)x[0]
  #define SwapMetaSize(x) &x[sizeof(char)]
  #define SwapMetaData(x) &x[STORE_META_TLD_START]
! #define STORE_HDR_METASIZE (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(squid_file_sz))
! #define STORE_HDR_METASIZE_OLD (4*sizeof(time_t)+2*sizeof(u_short)+sizeof(size_t))
  
  #define STORE_ENTRY_WITH_MEMOBJ		1
  #define STORE_ENTRY_WITHOUT_MEMOBJ	0
Index: squid/src/disk.c
diff -c squid/src/disk.c:1.157.2.2 squid/src/disk.c:1.157.2.5
*** squid/src/disk.c:1.157.2.2	Sat Nov  6 14:37:12 2004
--- squid/src/disk.c	Sat Mar 26 10:36:01 2005
***************
*** 239,245 ****
  	q->buf_offset += len;
  	if (q->buf_offset > q->len)
  	    debug(50, 1) ("diskHandleWriteComplete: q->buf_offset > q->len (%p,%d, %d, %d FD %d)\n",
! 		q, (int) q->buf_offset, q->len, len, fd);
  	assert(q->buf_offset <= q->len);
  	if (q->buf_offset == q->len) {
  	    /* complete write */
--- 239,245 ----
  	q->buf_offset += len;
  	if (q->buf_offset > q->len)
  	    debug(50, 1) ("diskHandleWriteComplete: q->buf_offset > q->len (%p,%d, %d, %d FD %d)\n",
! 		q, (int) q->buf_offset, (int) q->len, len, fd);
  	assert(q->buf_offset <= q->len);
  	if (q->buf_offset == q->len) {
  	    /* complete write */
***************
*** 293,299 ****
  file_write(int fd,
      off_t file_offset,
      void *ptr_to_buf,
!     int len,
      DWCB * handle,
      void *handle_data,
      FREE * free_func)
--- 293,299 ----
  file_write(int fd,
      off_t file_offset,
      void *ptr_to_buf,
!     size_t len,
      DWCB * handle,
      void *handle_data,
      FREE * free_func)
***************
*** 331,339 ****
   * in a snap
   */
  void
! file_write_mbuf(int fd, off_t off, MemBuf mb, DWCB * handler, void *handler_data)
  {
!     file_write(fd, off, mb.buf, mb.size, handler, handler_data, memBufFreeFunc(&mb));
  }
  
  /* Read from FD */
--- 331,339 ----
   * in a snap
   */
  void
! file_write_mbuf(int fd, off_t file_offset, MemBuf mb, DWCB * handler, void *handler_data)
  {
!     file_write(fd, file_offset, mb.buf, mb.size, handler, handler_data, memBufFreeFunc(&mb));
  }
  
  /* Read from FD */
***************
*** 352,363 ****
  	memFree(ctrl_dat, MEM_DREAD_CTRL);
  	return;
      }
!     if (F->disk.offset != ctrl_dat->offset) {
  	debug(6, 3) ("diskHandleRead: FD %d seeking to offset %d\n",
! 	    fd, (int) ctrl_dat->offset);
! 	lseek(fd, ctrl_dat->offset, SEEK_SET);	/* XXX ignore return? */
  	statCounter.syscalls.disk.seeks++;
! 	F->disk.offset = ctrl_dat->offset;
      }
      errno = 0;
      len = FD_READ_METHOD(fd, ctrl_dat->buf, ctrl_dat->req_len);
--- 352,363 ----
  	memFree(ctrl_dat, MEM_DREAD_CTRL);
  	return;
      }
!     if (F->disk.offset != ctrl_dat->file_offset) {
  	debug(6, 3) ("diskHandleRead: FD %d seeking to offset %d\n",
! 	    fd, (int) ctrl_dat->file_offset);
! 	lseek(fd, ctrl_dat->file_offset, SEEK_SET);	/* XXX ignore return? */
  	statCounter.syscalls.disk.seeks++;
! 	F->disk.offset = ctrl_dat->file_offset;
      }
      errno = 0;
      len = FD_READ_METHOD(fd, ctrl_dat->buf, ctrl_dat->req_len);
***************
*** 388,400 ****
   * It must have at least req_len space in there. 
   * call handler when a reading is complete. */
  void
! file_read(int fd, char *buf, int req_len, off_t offset, DRCB * handler, void *client_data)
  {
      dread_ctrl *ctrl_dat;
      assert(fd >= 0);
      ctrl_dat = memAllocate(MEM_DREAD_CTRL);
      ctrl_dat->fd = fd;
!     ctrl_dat->offset = offset;
      ctrl_dat->req_len = req_len;
      ctrl_dat->buf = buf;
      ctrl_dat->end_of_file = 0;
--- 388,400 ----
   * It must have at least req_len space in there. 
   * call handler when a reading is complete. */
  void
! file_read(int fd, char *buf, size_t req_len, off_t file_offset, DRCB * handler, void *client_data)
  {
      dread_ctrl *ctrl_dat;
      assert(fd >= 0);
      ctrl_dat = memAllocate(MEM_DREAD_CTRL);
      ctrl_dat->fd = fd;
!     ctrl_dat->file_offset = file_offset;
      ctrl_dat->req_len = req_len;
      ctrl_dat->buf = buf;
      ctrl_dat->end_of_file = 0;
Index: squid/src/enums.h
diff -c squid/src/enums.h:1.203.2.14 squid/src/enums.h:1.203.2.15
*** squid/src/enums.h:1.203.2.14	Mon Jan 17 15:13:04 2005
--- squid/src/enums.h	Fri Mar 25 19:50:52 2005
***************
*** 274,280 ****
      ftPCc,
      ftPContRange,
      ftPRange,
!     ftDate_1123_or_ETag
  } field_type;
  
  /* possible owners of http header */
--- 274,281 ----
      ftPCc,
      ftPContRange,
      ftPRange,
!     ftDate_1123_or_ETag,
!     ftSize
  } field_type;
  
  /* possible owners of http header */
***************
*** 623,628 ****
--- 624,630 ----
      STORE_META_HITMETERING,	/* reserved for hit metering */
      STORE_META_VALID,
      STORE_META_VARY_HEADERS,	/* Stores Vary request headers */
+     STORE_META_STD_LFS,		/* standard metadata in lfs format */
      STORE_META_END
  };
  
***************
*** 638,643 ****
--- 640,646 ----
      SWAP_LOG_NOP,
      SWAP_LOG_ADD,
      SWAP_LOG_DEL,
+     SWAP_LOG_VERSION,
      SWAP_LOG_MAX
  } swap_log_op;
  
Index: squid/src/forward.c
diff -c squid/src/forward.c:1.82.2.14 squid/src/forward.c:1.82.2.15
*** squid/src/forward.c:1.82.2.14	Tue Feb 22 17:06:35 2005
--- squid/src/forward.c	Fri Mar 25 19:50:53 2005
***************
*** 693,701 ****
  #endif
      if (EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT))
  	return rc;
!     if (mem->inmem_hi - storeLowestMemReaderOffset(e) < READ_AHEAD_GAP)
! 	return rc;
!     return 1;
  }
  
  void
--- 693,710 ----
  #endif
      if (EBIT_TEST(e->flags, ENTRY_FWD_HDR_WAIT))
  	return rc;
!     if (EBIT_TEST(e->flags, RELEASE_REQUEST)) {
! 	/* Just a small safety cap to defer storing more data into the object
! 	 * if there already is way too much. This handles the case when there
! 	 * is disk clients pending on a too large object being fetched and a
! 	 * few other corner cases.
! 	 */
! 	if (mem->inmem_hi - mem->inmem_lo > SM_PAGE_SIZE + Config.Store.maxInMemObjSize + READ_AHEAD_GAP)
! 	    return 1;
!     }
!     if (mem->inmem_hi - storeLowestMemReaderOffset(e) > READ_AHEAD_GAP)
! 	return 1;
!     return rc;
  }
  
  void
Index: squid/src/ftp.c
diff -c squid/src/ftp.c:1.316.2.24 squid/src/ftp.c:1.316.2.25
*** squid/src/ftp.c:1.316.2.24	Mon Mar  7 06:31:35 2005
--- squid/src/ftp.c	Fri Mar 25 19:50:53 2005
***************
*** 93,106 ****
      int login_att;
      ftp_state_t state;
      time_t mdtm;
!     int size;
      wordlist *pathcomps;
      char *filepath;
!     int restart_offset;
!     int restarted_offset;
      int rest_att;
      char *proxy_host;
!     size_t list_width;
      wordlist *cwd_message;
      char *old_request;
      char *old_reply;
--- 93,106 ----
      int login_att;
      ftp_state_t state;
      time_t mdtm;
!     squid_off_t size;
      wordlist *pathcomps;
      char *filepath;
!     squid_off_t restart_offset;
!     squid_off_t restarted_offset;
      int rest_att;
      char *proxy_host;
!     int list_width;
      wordlist *cwd_message;
      char *old_request;
      char *old_reply;
***************
*** 110,116 ****
  	int fd;
  	char *buf;
  	size_t size;
! 	off_t offset;
  	FREE *freefunc;
  	wordlist *message;
  	char *last_command;
--- 110,116 ----
  	int fd;
  	char *buf;
  	size_t size;
! 	size_t offset;
  	FREE *freefunc;
  	wordlist *message;
  	char *last_command;
***************
*** 121,127 ****
  	int fd;
  	char *buf;
  	size_t size;
! 	off_t offset;
  	FREE *freefunc;
  	char *host;
  	u_short port;
--- 121,127 ----
  	int fd;
  	char *buf;
  	size_t size;
! 	size_t offset;
  	FREE *freefunc;
  	char *host;
  	u_short port;
***************
*** 132,138 ****
  
  typedef struct {
      char type;
!     int size;
      char *date;
      char *name;
      char *showname;
--- 132,138 ----
  
  typedef struct {
      char type;
!     squid_off_t size;
      char *date;
      char *name;
      char *showname;
***************
*** 537,543 ****
  		month, day, year);
  	if ((t = strstr(buf, tbuf))) {
  	    p->type = *tokens[0];
! 	    p->size = atoi(size);
  	    p->date = xstrdup(tbuf);
  	    if (flags.skip_whitespace) {
  		t += strlen(tbuf);
--- 537,543 ----
  		month, day, year);
  	if ((t = strstr(buf, tbuf))) {
  	    p->type = *tokens[0];
! 	    p->size = strto_off_t(size, NULL, 10);
  	    p->date = xstrdup(tbuf);
  	    if (flags.skip_whitespace) {
  		t += strlen(tbuf);
***************
*** 566,572 ****
  	    p->type = 'd';
  	} else {
  	    p->type = '-';
! 	    p->size = atoi(tokens[2]);
  	}
  	snprintf(tbuf, 128, "%s %s", tokens[0], tokens[1]);
  	p->date = xstrdup(tbuf);
--- 566,572 ----
  	    p->type = 'd';
  	} else {
  	    p->type = '-';
! 	    p->size = strto_off_t(tokens[2], NULL, 10);
  	}
  	snprintf(tbuf, 128, "%s %s", tokens[0], tokens[1]);
  	p->date = xstrdup(tbuf);
***************
*** 604,613 ****
  		p->name = xstrndup(ct + 1, l + 1);
  		break;
  	    case 's':
! 		p->size = atoi(ct + 1);
  		break;
  	    case 'm':
! 		t = (time_t) strtol(ct + 1, &tmp, 0);
  		if (tmp != ct + l)
  		    break;	/* not a valid integer */
  		p->date = xstrdup(ctime(&t));
--- 604,613 ----
  		p->name = xstrndup(ct + 1, l + 1);
  		break;
  	    case 's':
! 		p->size = strto_off_t(ct + 1, NULL, 10);
  		break;
  	    case 'm':
! 		t = (time_t) strto_off_t(ct + 1, &tmp, 0);
  		if (tmp != ct + l)
  		    break;	/* not a valid integer */
  		p->date = xstrdup(ctime(&t));
***************
*** 728,735 ****
  	ftpListPartsFree(&parts);
  	return html;
      }
-     parts->size += 1023;
-     parts->size >>= 10;
      parts->showname = xstrdup(parts->name);
      if (!Config.Ftp.list_wrap) {
  	if (strlen(parts->showname) > width - 1) {
--- 728,733 ----
***************
*** 771,780 ****
  	break;
      case '-':
      default:
! 	snprintf(icon, 2048, "<IMG border=\"0\" SRC=\"%s\" ALT=\"%-6s\">",
! 	    mimeGetIconURL(parts->name),
! 	    "[FILE]");
! 	snprintf(size, 2048, " %6dk", parts->size);
  	break;
      }
      if (parts->type != 'd') {
--- 769,794 ----
  	break;
      case '-':
      default:
! 	{
! 	    squid_off_t sz = parts->size;
! 	    char units = ' ';
! 	    snprintf(icon, 2048, "<IMG border=\"0\" SRC=\"%s\" ALT=\"%-6s\">",
! 		mimeGetIconURL(parts->name),
! 		"[FILE]");
! 	    if (sz > 10 * 1024) {
! 		sz = (sz + 1023) >> 10;
! 		units = 'K';
! 	    }
! 	    if (sz > 10 * 1024) {
! 		sz = (sz + 1023) >> 10;
! 		units = 'M';
! 	    }
! 	    if (sz > 10 * 1024) {
! 		sz = (sz + 1023) >> 10;
! 		units = 'G';
! 	    }
! 	    snprintf(size, 2048, " %6" PRINTF_OFF_T "%c", sz, units);
! 	}
  	break;
      }
      if (parts->type != 'd') {
***************
*** 818,824 ****
      size_t linelen;
      size_t usable;
      StoreEntry *e = ftpState->entry;
!     int len = ftpState->data.offset;
      /*
       * We need a NULL-terminated buffer for scanning, ick
       */
--- 832,838 ----
      size_t linelen;
      size_t usable;
      StoreEntry *e = ftpState->entry;
!     size_t len = ftpState->data.offset;
      /*
       * We need a NULL-terminated buffer for scanning, ick
       */
***************
*** 834,840 ****
  	xfree(sbuf);
  	return;
      }
!     debug(9, 3) ("ftpParseListing: %d bytes to play with\n", len);
      line = memAllocate(MEM_4K_BUF);
      end++;
      storeBuffer(e);
--- 848,854 ----
  	xfree(sbuf);
  	return;
      }
!     debug(9, 3) ("ftpParseListing: %d bytes to play with\n", (int) len);
      line = memAllocate(MEM_4K_BUF);
      end++;
      storeBuffer(e);
***************
*** 1224,1231 ****
      wordlist *head = NULL;
      wordlist *list;
      wordlist **tail = &head;
!     off_t offset;
!     size_t linelen;
      int code = -1;
      debug(9, 5) ("ftpParseControlReply\n");
      /*
--- 1238,1245 ----
      wordlist *head = NULL;
      wordlist *list;
      wordlist **tail = &head;
!     int offset;
!     int linelen;
      int code = -1;
      debug(9, 5) ("ftpParseControlReply\n");
      /*
***************
*** 1699,1705 ****
      debug(9, 3) ("This is ftpReadSize\n");
      if (code == 213) {
  	ftpUnhack(ftpState);
! 	ftpState->size = atoi(ftpState->ctrl.last_reply);
  	if (ftpState->size == 0) {
  	    debug(9, 2) ("ftpReadSize: SIZE reported %s on %s\n",
  		ftpState->ctrl.last_reply,
--- 1713,1719 ----
      debug(9, 3) ("This is ftpReadSize\n");
      if (code == 213) {
  	ftpUnhack(ftpState);
! 	ftpState->size = strto_off_t(ftpState->ctrl.last_reply, NULL, 10);
  	if (ftpState->size == 0) {
  	    debug(9, 2) ("ftpReadSize: SIZE reported %s on %s\n",
  		ftpState->ctrl.last_reply,
***************
*** 2029,2035 ****
  	snprintf(cbuf, 1024, "STOR %s\r\n", ftpState->filepath);
  	ftpWriteCommand(cbuf, ftpState);
  	ftpState->state = SENT_STOR;
!     } else if (httpHeaderGetInt(&ftpState->request->header, HDR_CONTENT_LENGTH) > 0) {
  	/* File upload without a filename. use STOU to generate one */
  	snprintf(cbuf, 1024, "STOU\r\n");
  	ftpWriteCommand(cbuf, ftpState);
--- 2043,2049 ----
  	snprintf(cbuf, 1024, "STOR %s\r\n", ftpState->filepath);
  	ftpWriteCommand(cbuf, ftpState);
  	ftpState->state = SENT_STOR;
!     } else if (httpHeaderGetSize(&ftpState->request->header, HDR_CONTENT_LENGTH) > 0) {
  	/* File upload without a filename. use STOU to generate one */
  	snprintf(cbuf, 1024, "STOU\r\n");
  	ftpWriteCommand(cbuf, ftpState);
***************
*** 2079,2085 ****
  static void
  ftpSendRest(FtpStateData * ftpState)
  {
!     snprintf(cbuf, 1024, "REST %d\r\n", ftpState->restart_offset);
      ftpWriteCommand(cbuf, ftpState);
      ftpState->state = SENT_REST;
  }
--- 2093,2099 ----
  static void
  ftpSendRest(FtpStateData * ftpState)
  {
!     snprintf(cbuf, 1024, "REST %" PRINTF_OFF_T "\r\n", ftpState->restart_offset);
      ftpWriteCommand(cbuf, ftpState);
      ftpState->state = SENT_REST;
  }
Index: squid/src/globals.h
diff -c squid/src/globals.h:1.108.2.4 squid/src/globals.h:1.108.2.5
*** squid/src/globals.h:1.108.2.4	Fri Jan 21 04:48:25 2005
--- squid/src/globals.h	Fri Mar 25 19:50:53 2005
***************
*** 154,160 ****
  extern int store_swap_low;	/* 0 */
  extern int store_swap_high;	/* 0 */
  extern int store_pages_max;	/* 0 */
! extern ssize_t store_maxobjsize;	/* -1 */
  extern RemovalPolicy *mem_policy;
  extern hash_table *proxy_auth_username_cache;	/* NULL */
  extern int incoming_sockets_accepted;
--- 154,160 ----
  extern int store_swap_low;	/* 0 */
  extern int store_swap_high;	/* 0 */
  extern int store_pages_max;	/* 0 */
! extern squid_off_t store_maxobjsize;	/* -1 */
  extern RemovalPolicy *mem_policy;
  extern hash_table *proxy_auth_username_cache;	/* NULL */
  extern int incoming_sockets_accepted;
Index: squid/src/helper.c
diff -c squid/src/helper.c:1.34.2.17 squid/src/helper.c:1.34.2.18
*** squid/src/helper.c:1.34.2.17	Sat Nov  6 08:24:51 2004
--- squid/src/helper.c	Fri Mar 25 19:50:53 2005
***************
*** 374,380 ****
  	    srv->flags.closing ? 'C' : ' ',
  	    srv->flags.shutdown ? 'S' : ' ',
  	    tt < 0.0 ? 0.0 : tt,
! 	    (int) srv->offset,
  	    srv->request ? log_quote(srv->request->buf) : "(none)");
      }
      storeAppendPrintf(sentry, "\nFlags key:\n\n");
--- 374,380 ----
  	    srv->flags.closing ? 'C' : ' ',
  	    srv->flags.shutdown ? 'S' : ' ',
  	    tt < 0.0 ? 0.0 : tt,
! 	    srv->offset,
  	    srv->request ? log_quote(srv->request->buf) : "(none)");
      }
      storeAppendPrintf(sentry, "\nFlags key:\n\n");
***************
*** 423,429 ****
  	    srv->flags.reserved ? 'R' : ' ',
  	    srv->flags.shutdown ? 'S' : ' ',
  	    tt < 0.0 ? 0.0 : tt,
! 	    (int) srv->offset,
  	    srv->request ? log_quote(srv->request->buf) : "(none)");
      }
      storeAppendPrintf(sentry, "\nFlags key:\n\n");
--- 423,429 ----
  	    srv->flags.reserved ? 'R' : ' ',
  	    srv->flags.shutdown ? 'S' : ' ',
  	    tt < 0.0 ? 0.0 : tt,
! 	    srv->offset,
  	    srv->request ? log_quote(srv->request->buf) : "(none)");
      }
      storeAppendPrintf(sentry, "\nFlags key:\n\n");
Index: squid/src/htcp.c
diff -c squid/src/htcp.c:1.38.2.5 squid/src/htcp.c:1.38.2.6
*** squid/src/htcp.c:1.38.2.5	Sun Feb 20 12:07:45 2005
--- squid/src/htcp.c	Fri Mar 25 19:50:53 2005
***************
*** 227,240 ****
  {
      u_short length;
      size_t len;
!     off_t off = 0;
      if (buflen - off < 2)
  	return -1;
      if (s)
  	len = strlen(s);
      else
  	len = 0;
!     debug(31, 3) ("htcpBuildCountstr: LENGTH = %d\n", len);
      debug(31, 3) ("htcpBuildCountstr: TEXT = {%s}\n", s ? s : "<NULL>");
      length = htons((u_short) len);
      xmemcpy(buf + off, &length, 2);
--- 227,240 ----
  {
      u_short length;
      size_t len;
!     int off = 0;
      if (buflen - off < 2)
  	return -1;
      if (s)
  	len = strlen(s);
      else
  	len = 0;
!     debug(31, 3) ("htcpBuildCountstr: LENGTH = %d\n", (int) len);
      debug(31, 3) ("htcpBuildCountstr: TEXT = {%s}\n", s ? s : "<NULL>");
      length = htons((u_short) len);
      xmemcpy(buf + off, &length, 2);
Index: squid/src/http.c
diff -c squid/src/http.c:1.384.2.29 squid/src/http.c:1.384.2.30
*** squid/src/http.c:1.384.2.29	Wed Mar  9 07:40:04 2005
--- squid/src/http.c	Fri Mar 25 19:50:53 2005
***************
*** 528,536 ****
      /* return 1 if we got the last of the data on a persistent connection */
      MemObject *mem = httpState->entry->mem_obj;
      HttpReply *reply = mem->reply;
!     int clen;
      debug(11, 3) ("httpPconnTransferDone: FD %d\n", httpState->fd);
!     debug(11, 5) ("httpPconnTransferDone: content_length=%d\n",
  	reply->content_length);
      /* If we haven't seen the end of reply headers, we are not done */
      if (httpState->reply_hdr_state < 2)
--- 528,536 ----
      /* return 1 if we got the last of the data on a persistent connection */
      MemObject *mem = httpState->entry->mem_obj;
      HttpReply *reply = mem->reply;
!     squid_off_t clen;
      debug(11, 3) ("httpPconnTransferDone: FD %d\n", httpState->fd);
!     debug(11, 5) ("httpPconnTransferDone: content_length=%" PRINTF_OFF_T "\n",
  	reply->content_length);
      /* If we haven't seen the end of reply headers, we are not done */
      if (httpState->reply_hdr_state < 2)
***************
*** 1061,1067 ****
  
  /* build request prefix and append it to a given MemBuf; 
   * return the length of the prefix */
! mb_size_t
  httpBuildRequestPrefix(request_t * request,
      request_t * orig_request,
      StoreEntry * entry,
--- 1061,1067 ----
  
  /* build request prefix and append it to a given MemBuf; 
   * return the length of the prefix */
! int
  httpBuildRequestPrefix(request_t * request,
      request_t * orig_request,
      StoreEntry * entry,
Index: squid/src/mime.c
diff -c squid/src/mime.c:1.102.2.4 squid/src/mime.c:1.102.2.5
*** squid/src/mime.c:1.102.2.4	Fri Jan 21 17:56:14 2005
--- squid/src/mime.c	Fri Mar 25 19:50:53 2005
***************
*** 442,448 ****
      httpReplyReset(reply = e->mem_obj->reply);
      httpBuildVersion(&version, 1, 0);
      httpReplySetHeaders(reply, version, HTTP_OK, NULL,
! 	type, (int) sb.st_size, sb.st_mtime, -1);
      reply->cache_control = httpHdrCcCreate();
      httpHdrCcSetMaxAge(reply->cache_control, 86400);
      httpHeaderPutCc(&reply->header, reply->cache_control);
--- 442,448 ----
      httpReplyReset(reply = e->mem_obj->reply);
      httpBuildVersion(&version, 1, 0);
      httpReplySetHeaders(reply, version, HTTP_OK, NULL,
! 	type, sb.st_size, sb.st_mtime, -1);
      reply->cache_control = httpHdrCcCreate();
      httpHdrCcSetMaxAge(reply->cache_control, 86400);
      httpHeaderPutCc(&reply->header, reply->cache_control);
Index: squid/src/net_db.c
diff -c squid/src/net_db.c:1.158.2.8 squid/src/net_db.c:1.158.2.9
*** squid/src/net_db.c:1.158.2.8	Wed Mar 16 11:07:03 2005
--- squid/src/net_db.c	Fri Mar 25 19:50:53 2005
***************
*** 42,49 ****
      StoreEntry *e;
      store_client *sc;
      request_t *r;
!     off_t seen;
!     off_t used;
      size_t buf_sz;
      char *buf;
  } netdbExchangeState;
--- 42,49 ----
      StoreEntry *e;
      store_client *sc;
      request_t *r;
!     squid_off_t seen;
!     squid_off_t used;
      size_t buf_sz;
      char *buf;
  } netdbExchangeState;
***************
*** 531,537 ****
  {
      netdbExchangeState *ex = data;
      int rec_sz = 0;
!     off_t o;
      struct in_addr addr;
      double rtt;
      double hops;
--- 531,537 ----
  {
      netdbExchangeState *ex = data;
      int rec_sz = 0;
!     ssize_t o;
      struct in_addr addr;
      double rtt;
      double hops;
Index: squid/src/peer_digest.c
diff -c squid/src/peer_digest.c:1.83.2.1 squid/src/peer_digest.c:1.83.2.2
*** squid/src/peer_digest.c:1.83.2.1	Wed Jul 16 14:22:39 2003
--- squid/src/peer_digest.c	Fri Mar 25 19:50:53 2005
***************
*** 453,459 ****
      if (size >= StoreDigestCBlockSize) {
  	PeerDigest *pd = fetch->pd;
  	HttpReply *rep = fetch->entry->mem_obj->reply;
! 	const int seen = fetch->offset + size;
  
  	assert(pd && rep);
  	if (peerDigestSetCBlock(pd, buf)) {
--- 453,459 ----
      if (size >= StoreDigestCBlockSize) {
  	PeerDigest *pd = fetch->pd;
  	HttpReply *rep = fetch->entry->mem_obj->reply;
! 	const squid_off_t seen = fetch->offset + size;
  
  	assert(pd && rep);
  	if (peerDigestSetCBlock(pd, buf)) {
***************
*** 498,504 ****
      fetch->offset += size;
      fetch->mask_offset += size;
      if (fetch->mask_offset >= pd->cd->mask_size) {
! 	debug(72, 2) ("peerDigestSwapInMask: Done! Got %d, expected %d\n",
  	    fetch->mask_offset, pd->cd->mask_size);
  	assert(fetch->mask_offset == pd->cd->mask_size);
  	assert(peerDigestFetchedEnough(fetch, NULL, 0, "peerDigestSwapInMask"));
--- 498,504 ----
      fetch->offset += size;
      fetch->mask_offset += size;
      if (fetch->mask_offset >= pd->cd->mask_size) {
! 	debug(72, 2) ("peerDigestSwapInMask: Done! Got %" PRINTF_OFF_T ", expected %d\n",
  	    fetch->mask_offset, pd->cd->mask_size);
  	assert(fetch->mask_offset == pd->cd->mask_size);
  	assert(peerDigestFetchedEnough(fetch, NULL, 0, "peerDigestSwapInMask"));
***************
*** 540,547 ****
  	else
  	    host = strBuf(pd->host);
      }
!     debug(72, 6) ("%s: peer %s, offset: %d size: %d.\n",
! 	step_name, host, fcb_valid ? fetch->offset : -1, size);
  
      /* continue checking (with pd and host known and valid) */
      if (!reason) {
--- 540,547 ----
  	else
  	    host = strBuf(pd->host);
      }
!     debug(72, 6) ("%s: peer %s, offset: %" PRINTF_OFF_T " size: %d.\n",
! 	step_name, host, fcb_valid ? fetch->offset : (squid_off_t) - 1, (int) size);
  
      /* continue checking (with pd and host known and valid) */
      if (!reason) {
***************
*** 778,784 ****
      /* check consistency further */
      if (cblock.mask_size != cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry)) {
  	debug(72, 0) ("%s digest cblock is corrupted (mask size mismatch: %d ? %d).\n",
! 	    host, cblock.mask_size, cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry));
  	return 0;
      }
      /* there are some things we cannot do yet */
--- 778,784 ----
      /* check consistency further */
      if (cblock.mask_size != cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry)) {
  	debug(72, 0) ("%s digest cblock is corrupted (mask size mismatch: %d ? %d).\n",
! 	    host, cblock.mask_size, (int) cacheDigestCalcMaskSize(cblock.capacity, cblock.bits_per_entry));
  	return 0;
      }
      /* there are some things we cannot do yet */
Index: squid/src/protos.h
diff -c squid/src/protos.h:1.420.2.28 squid/src/protos.h:1.420.2.30
*** squid/src/protos.h:1.420.2.28	Fri Mar 18 17:01:52 2005
--- squid/src/protos.h	Sat Mar 26 10:36:01 2005
***************
*** 125,131 ****
  extern int cbdataLocked(const void *p);
  
  extern void clientdbInit(void);
! extern void clientdbUpdate(struct in_addr, log_type, protocol_t, size_t);
  extern int clientdbCutoffDenied(struct in_addr);
  extern void clientdbDump(StoreEntry *);
  extern void clientdbFreeMemory(void);
--- 125,131 ----
  extern int cbdataLocked(const void *p);
  
  extern void clientdbInit(void);
! extern void clientdbUpdate(struct in_addr, log_type, protocol_t, squid_off_t);
  extern int clientdbCutoffDenied(struct in_addr);
  extern void clientdbDump(StoreEntry *);
  extern void clientdbFreeMemory(void);
***************
*** 223,246 ****
  /* disk.c */
  extern int file_open(const char *path, int mode);
  extern void file_close(int fd);
! extern void file_write(int, off_t, void *, int len, DWCB *, void *, FREE *);
  extern void file_write_mbuf(int fd, off_t, MemBuf mb, DWCB * handler, void *handler_data);
! extern void file_read(int, char *, int, off_t, DRCB *, void *);
  extern void disk_init(void);
  
! /* diskd.c */
! extern diskd_queue *afile_create_queue(void);
! extern void afile_destroy_queue(diskd_queue *);
! extern void afile_sync_queue(diskd_queue *);
! extern void afile_sync(void);
! extern void afile_open(const char *path, int mode, DOCB *, void *);
! extern void afile_close(int fd, DCCB * callback, void *data);
! extern void afile_write(int, off_t, void *, int len, DWCB *, void *, FREE *);
! extern void afile_write_mbuf(int fd, off_t, MemBuf, DWCB *, void *);
! extern void afile_read(int, char *, int, off_t, DRCB *, void *);
! extern void afile_unlink(const char *path, DUCB *, void *);
! extern void afile_truncate(const char *path, DTCB *, void *);
! 
  extern void dnsShutdown(void);
  extern void dnsInit(void);
  extern void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
--- 223,234 ----
  /* disk.c */
  extern int file_open(const char *path, int mode);
  extern void file_close(int fd);
! extern void file_write(int, off_t, void *, size_t len, DWCB *, void *, FREE *);
  extern void file_write_mbuf(int fd, off_t, MemBuf mb, DWCB * handler, void *handler_data);
! extern void file_read(int, char *, size_t, off_t, DRCB *, void *);
  extern void disk_init(void);
  
! /* dns.s */
  extern void dnsShutdown(void);
  extern void dnsInit(void);
  extern void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
***************
*** 303,309 ****
  /* http.c */
  extern int httpCachable(method_t);
  extern void httpStart(FwdState *);
! extern mb_size_t httpBuildRequestPrefix(request_t * request,
      request_t * orig_request,
      StoreEntry * entry,
      MemBuf * mb,
--- 291,297 ----
  /* http.c */
  extern int httpCachable(method_t);
  extern void httpStart(FwdState *);
! extern int httpBuildRequestPrefix(request_t * request,
      request_t * orig_request,
      StoreEntry * entry,
      MemBuf * mb,
***************
*** 371,383 ****
  /* iterate through specs */
  extern HttpHdrRangeSpec *httpHdrRangeGetSpec(const HttpHdrRange * range, HttpHdrRangePos * pos);
  /* adjust specs after the length is known */
! extern int httpHdrRangeCanonize(HttpHdrRange *, ssize_t);
  /* other */
  extern String httpHdrRangeBoundaryStr(clientHttpRequest * http);
  extern int httpHdrRangeIsComplex(const HttpHdrRange * range);
  extern int httpHdrRangeWillBeComplex(const HttpHdrRange * range);
! extern ssize_t httpHdrRangeFirstOffset(const HttpHdrRange * range);
! extern ssize_t httpHdrRangeLowestOffset(const HttpHdrRange * range, ssize_t);
  extern int httpHdrRangeOffsetLimit(HttpHdrRange *);
  
  
--- 359,371 ----
  /* iterate through specs */
  extern HttpHdrRangeSpec *httpHdrRangeGetSpec(const HttpHdrRange * range, HttpHdrRangePos * pos);
  /* adjust specs after the length is known */
! extern int httpHdrRangeCanonize(HttpHdrRange *, squid_off_t);
  /* other */
  extern String httpHdrRangeBoundaryStr(clientHttpRequest * http);
  extern int httpHdrRangeIsComplex(const HttpHdrRange * range);
  extern int httpHdrRangeWillBeComplex(const HttpHdrRange * range);
! extern squid_off_t httpHdrRangeFirstOffset(const HttpHdrRange * range);
! extern squid_off_t httpHdrRangeLowestOffset(const HttpHdrRange * range, squid_off_t);
  extern int httpHdrRangeOffsetLimit(HttpHdrRange *);
  
  
***************
*** 390,396 ****
  extern HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
  extern void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
  /* inits with given spec */
! extern void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, ssize_t);
  
  /* Http Header Tools */
  extern HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
--- 378,384 ----
  extern HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
  extern void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
  /* inits with given spec */
! extern void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, squid_off_t);
  
  /* Http Header Tools */
  extern HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
***************
*** 401,414 ****
  extern void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
  extern void httpHeaderCalcMask(HttpHeaderMask * mask, const int *enums, int count);
  extern int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
! extern void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, ssize_t);
  extern void strListAdd(String * str, const char *item, char del);
  extern int strListIsMember(const String * str, const char *item, char del);
  extern int strListIsSubstr(const String * list, const char *s, char del);
  extern int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
  extern const char *getStringPrefix(const char *str, const char *end);
  extern int httpHeaderParseInt(const char *start, int *val);
! extern int httpHeaderParseSize(const char *start, ssize_t * sz);
  extern int httpHeaderReset(HttpHeader * hdr);
  #if STDC_HEADERS
  extern void
--- 389,402 ----
  extern void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
  extern void httpHeaderCalcMask(HttpHeaderMask * mask, const int *enums, int count);
  extern int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
! extern void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, squid_off_t);
  extern void strListAdd(String * str, const char *item, char del);
  extern int strListIsMember(const String * str, const char *item, char del);
  extern int strListIsSubstr(const String * list, const char *s, char del);
  extern int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
  extern const char *getStringPrefix(const char *str, const char *end);
  extern int httpHeaderParseInt(const char *start, int *val);
! extern squid_off_t httpHeaderParseSize(const char *start, squid_off_t * sz);
  extern int httpHeaderReset(HttpHeader * hdr);
  #if STDC_HEADERS
  extern void
***************
*** 433,438 ****
--- 421,427 ----
  /* field manipulation */
  extern int httpHeaderHas(const HttpHeader * hdr, http_hdr_type type);
  extern void httpHeaderPutInt(HttpHeader * hdr, http_hdr_type type, int number);
+ extern void httpHeaderPutSize(HttpHeader * hdr, http_hdr_type type, squid_off_t number);
  extern void httpHeaderPutTime(HttpHeader * hdr, http_hdr_type type, time_t htime);
  extern void httpHeaderPutStr(HttpHeader * hdr, http_hdr_type type, const char *str);
  extern void httpHeaderPutAuth(HttpHeader * hdr, const char *auth_scheme, const char *realm);
***************
*** 441,446 ****
--- 430,436 ----
  extern void httpHeaderPutRange(HttpHeader * hdr, const HttpHdrRange * range);
  extern void httpHeaderPutExt(HttpHeader * hdr, const char *name, const char *value);
  extern int httpHeaderGetInt(const HttpHeader * hdr, http_hdr_type id);
+ extern squid_off_t httpHeaderGetSize(const HttpHeader * hdr, http_hdr_type id);
  extern time_t httpHeaderGetTime(const HttpHeader * hdr, http_hdr_type id);
  extern TimeOrTag httpHeaderGetTimeOrTag(const HttpHeader * hdr, http_hdr_type id);
  extern HttpHdrCc *httpHeaderGetCc(const HttpHeader * hdr);
***************
*** 482,488 ****
  /* absorb: copy the contents of a new reply to the old one, destroy new one */
  extern void httpReplyAbsorb(HttpReply * rep, HttpReply * new_rep);
  /* parse returns -1,0,+1 on error,need-more-data,success */
! extern int httpReplyParse(HttpReply * rep, const char *buf, ssize_t);
  extern void httpReplyPackInto(const HttpReply * rep, Packer * p);
  /* ez-routines */
  /* mem-pack: returns a ready to use mem buffer with a packed reply */
--- 472,478 ----
  /* absorb: copy the contents of a new reply to the old one, destroy new one */
  extern void httpReplyAbsorb(HttpReply * rep, HttpReply * new_rep);
  /* parse returns -1,0,+1 on error,need-more-data,success */
! extern int httpReplyParse(HttpReply * rep, const char *buf, size_t);
  extern void httpReplyPackInto(const HttpReply * rep, Packer * p);
  /* ez-routines */
  /* mem-pack: returns a ready to use mem buffer with a packed reply */
***************
*** 491,500 ****
  extern void httpReplySwapOut(const HttpReply * rep, StoreEntry * e);
  /* set commonly used info with one call */
  extern void httpReplySetHeaders(HttpReply * rep, http_version_t ver, http_status status,
!     const char *reason, const char *ctype, int clen, time_t lmt, time_t expires);
  /* do everything in one call: init, set, pack, clean, return MemBuf */
  extern MemBuf httpPackedReply(http_version_t ver, http_status status, const char *ctype,
!     int clen, time_t lmt, time_t expires);
  /* construct 304 reply and pack it into MemBuf, return MemBuf */
  extern MemBuf httpPacked304Reply(const HttpReply * rep);
  /* update when 304 reply is received for a cached object */
--- 481,490 ----
  extern void httpReplySwapOut(const HttpReply * rep, StoreEntry * e);
  /* set commonly used info with one call */
  extern void httpReplySetHeaders(HttpReply * rep, http_version_t ver, http_status status,
!     const char *reason, const char *ctype, squid_off_t clen, time_t lmt, time_t expires);
  /* do everything in one call: init, set, pack, clean, return MemBuf */
  extern MemBuf httpPackedReply(http_version_t ver, http_status status, const char *ctype,
!     squid_off_t clen, time_t lmt, time_t expires);
  /* construct 304 reply and pack it into MemBuf, return MemBuf */
  extern MemBuf httpPacked304Reply(const HttpReply * rep);
  /* update when 304 reply is received for a cached object */
***************
*** 505,511 ****
  extern time_t httpReplyExpires(const HttpReply * rep);
  extern int httpReplyHasCc(const HttpReply * rep, http_hdr_cc_type type);
  extern void httpRedirectReply(HttpReply *, http_status, const char *);
! extern int httpReplyBodySize(method_t, const HttpReply *);
  
  /* Http Request */
  extern request_t *requestCreate(method_t, protocol_t, const char *urlpath);
--- 495,501 ----
  extern time_t httpReplyExpires(const HttpReply * rep);
  extern int httpReplyHasCc(const HttpReply * rep, http_hdr_cc_type type);
  extern void httpRedirectReply(HttpReply *, http_status, const char *);
! extern squid_off_t httpReplyBodySize(method_t, const HttpReply *);
  
  /* Http Request */
  extern request_t *requestCreate(method_t, protocol_t, const char *urlpath);
***************
*** 607,613 ****
  /* unfirtunate hack to test if the buffer has been Init()ialized */
  extern int memBufIsNull(MemBuf * mb);
  /* calls memcpy, appends exactly size bytes, extends buffer if needed */
! extern void memBufAppend(MemBuf * mb, const char *buf, mb_size_t size);
  /* calls snprintf, extends buffer if needed */
  #if STDC_HEADERS
  extern void
--- 597,603 ----
  /* unfirtunate hack to test if the buffer has been Init()ialized */
  extern int memBufIsNull(MemBuf * mb);
  /* calls memcpy, appends exactly size bytes, extends buffer if needed */
! extern void memBufAppend(MemBuf * mb, const char *buf, int size);
  /* calls snprintf, extends buffer if needed */
  #if STDC_HEADERS
  extern void
***************
*** 756,762 ****
  extern int authenticateAuthUserInuse(auth_user_t * auth_user);
  extern void authenticateAuthUserRequestRemoveIp(auth_user_request_t *, struct in_addr);
  extern void authenticateAuthUserRequestClearIp(auth_user_request_t *);
! extern size_t authenticateAuthUserRequestIPCount(auth_user_request_t *);
  extern int authenticateDirection(auth_user_request_t *);
  extern FREE authenticateFreeProxyAuthUser;
  extern void authenticateFreeProxyAuthUserACLResults(void *data);
--- 746,752 ----
  extern int authenticateAuthUserInuse(auth_user_t * auth_user);
  extern void authenticateAuthUserRequestRemoveIp(auth_user_request_t *, struct in_addr);
  extern void authenticateAuthUserRequestClearIp(auth_user_request_t *);
! extern int authenticateAuthUserRequestIPCount(auth_user_request_t *);
  extern int authenticateDirection(auth_user_request_t *);
  extern FREE authenticateFreeProxyAuthUser;
  extern void authenticateFreeProxyAuthUserACLResults(void *data);
***************
*** 788,794 ****
  
  
  extern void start_announce(void *unused);
! extern void sslStart(clientHttpRequest *, size_t *, int *);
  extern void waisStart(FwdState *);
  
  /* ident.c */
--- 778,784 ----
  
  
  extern void start_announce(void *unused);
! extern void sslStart(clientHttpRequest *, squid_off_t *, int *);
  extern void waisStart(FwdState *);
  
  /* ident.c */
***************
*** 851,857 ****
  extern void memFree32K(void *);
  extern void memFree64K(void *);
  extern int memInUse(mem_type);
! extern size_t memTotalAllocated(void);
  extern void memDataInit(mem_type, const char *, size_t, int);
  extern void memCheckInit(void);
  
--- 841,847 ----
  extern void memFree32K(void *);
  extern void memFree64K(void *);
  extern int memInUse(mem_type);
! extern int memTotalAllocated(void);
  extern void memDataInit(mem_type, const char *, size_t, int);
  extern void memCheckInit(void);
  
***************
*** 869,877 ****
  /* Mem */
  extern void memReport(StoreEntry * e);
  
! extern int stmemFreeDataUpto(mem_hdr *, int);
  extern void stmemAppend(mem_hdr *, const char *, int);
! extern ssize_t stmemCopy(const mem_hdr *, off_t, char *, size_t);
  extern void stmemFree(mem_hdr *);
  extern void stmemFreeData(mem_hdr *);
  extern void stmemNodeFree(void *);
--- 859,867 ----
  /* Mem */
  extern void memReport(StoreEntry * e);
  
! extern squid_off_t stmemFreeDataUpto(mem_hdr *, squid_off_t);
  extern void stmemAppend(mem_hdr *, const char *, int);
! extern ssize_t stmemCopy(const mem_hdr *, squid_off_t, char *, size_t);
  extern void stmemFree(mem_hdr *);
  extern void stmemFreeData(mem_hdr *);
  extern void stmemNodeFree(void *);
***************
*** 926,933 ****
  extern void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
  extern int storeCheckCachable(StoreEntry * e);
  extern void storeSetPrivateKey(StoreEntry *);
! extern int objectLen(const StoreEntry * e);
! extern int contentLen(const StoreEntry * e);
  extern HttpReply *storeEntryReply(StoreEntry *);
  extern int storeTooManyDiskFilesOpen(void);
  extern void storeEntryReset(StoreEntry *);
--- 916,923 ----
  extern void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
  extern int storeCheckCachable(StoreEntry * e);
  extern void storeSetPrivateKey(StoreEntry *);
! extern squid_off_t objectLen(const StoreEntry * e);
! extern squid_off_t contentLen(const StoreEntry * e);
  extern HttpReply *storeEntryReply(StoreEntry *);
  extern int storeTooManyDiskFilesOpen(void);
  extern void storeEntryReset(StoreEntry *);
***************
*** 948,957 ****
  extern storeIOState *storeCreate(StoreEntry *, STFNCB *, STIOCB *, void *);
  extern storeIOState *storeOpen(StoreEntry *, STFNCB *, STIOCB *, void *);
  extern void storeClose(storeIOState *);
! extern void storeRead(storeIOState *, char *, size_t, off_t, STRCB *, void *);
! extern void storeWrite(storeIOState *, char *, size_t, off_t, FREE *);
  extern void storeUnlink(StoreEntry *);
! extern off_t storeOffset(storeIOState *);
  
  /*
   * store_log.c
--- 938,947 ----
  extern storeIOState *storeCreate(StoreEntry *, STFNCB *, STIOCB *, void *);
  extern storeIOState *storeOpen(StoreEntry *, STFNCB *, STIOCB *, void *);
  extern void storeClose(storeIOState *);
! extern void storeRead(storeIOState *, char *, size_t, squid_off_t, STRCB *, void *);
! extern void storeWrite(storeIOState *, char *, size_t, squid_off_t, FREE *);
  extern void storeUnlink(StoreEntry *);
! extern squid_off_t storeOffset(storeIOState *);
  
  /*
   * store_log.c
***************
*** 1009,1015 ****
  extern void storeDirInit(void);
  extern void storeDirOpenSwapLogs(void);
  extern void storeDirSwapLog(const StoreEntry *, int op);
! extern void storeDirUpdateSwapSize(SwapDir *, size_t size, int sign);
  extern void storeDirSync(void);
  extern void storeDirCallback(void);
  extern void storeDirLRUDelete(StoreEntry *);
--- 999,1005 ----
  extern void storeDirInit(void);
  extern void storeDirOpenSwapLogs(void);
  extern void storeDirSwapLog(const StoreEntry *, int op);
! extern void storeDirUpdateSwapSize(SwapDir *, squid_off_t size, int sign);
  extern void storeDirSync(void);
  extern void storeDirCallback(void);
  extern void storeDirLRUDelete(StoreEntry *);
***************
*** 1042,1048 ****
   */
  extern void storeSwapOut(StoreEntry * e);
  extern void storeSwapOutFileClose(StoreEntry * e);
! extern int storeSwapOutAble(const StoreEntry * e);
  
  /*
   * store_client.c
--- 1032,1039 ----
   */
  extern void storeSwapOut(StoreEntry * e);
  extern void storeSwapOutFileClose(StoreEntry * e);
! extern int /* swapout_able */ storeSwapOutMaintainMemObject(StoreEntry * e);
! extern squid_off_t storeSwapOutObjectBytesOnDisk(const MemObject * mem);
  
  /*
   * store_client.c
***************
*** 1051,1060 ****
  extern store_client *storeClientListSearch(const MemObject * mem, void *data);
  #endif
  extern store_client *storeClientListAdd(StoreEntry * e, void *data);
! extern void storeClientCopy(store_client *, StoreEntry *, off_t, off_t, size_t, char *, STCB *, void *);
  extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
  extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
! extern off_t storeLowestMemReaderOffset(const StoreEntry * entry);
  extern void InvokeHandlers(StoreEntry * e);
  extern int storePendingNClients(const StoreEntry * e);
  
--- 1041,1050 ----
  extern store_client *storeClientListSearch(const MemObject * mem, void *data);
  #endif
  extern store_client *storeClientListAdd(StoreEntry * e, void *data);
! extern void storeClientCopy(store_client *, StoreEntry *, squid_off_t, squid_off_t, size_t, char *, STCB *, void *);
  extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
  extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
! extern squid_off_t storeLowestMemReaderOffset(const StoreEntry * entry);
  extern void InvokeHandlers(StoreEntry * e);
  extern int storePendingNClients(const StoreEntry * e);
  
***************
*** 1154,1160 ****
  extern void dlinkNodeDelete(dlink_node * m);
  extern dlink_node *dlinkNodeNew(void);
  
! extern void kb_incr(kb_t *, size_t);
  extern double gb_to_double(const gb_t *);
  extern const char *gb_to_str(const gb_t *);
  extern void gb_flush(gb_t *);	/* internal, do not use this */
--- 1144,1150 ----
  extern void dlinkNodeDelete(dlink_node * m);
  extern dlink_node *dlinkNodeNew(void);
  
! extern void kb_incr(kb_t *, squid_off_t);
  extern double gb_to_double(const gb_t *);
  extern const char *gb_to_str(const gb_t *);
  extern void gb_flush(gb_t *);	/* internal, do not use this */
Index: squid/src/squid.h
diff -c squid/src/squid.h:1.216.2.7 squid/src/squid.h:1.216.2.8
*** squid/src/squid.h:1.216.2.7	Mon Aug  9 07:54:23 2004
--- squid/src/squid.h	Fri Mar 25 19:50:53 2005
***************
*** 481,484 ****
--- 481,492 ----
  #define FD_READ_METHOD(fd, buf, len) (*fd_table[fd].read_method)(fd, buf, len)
  #define FD_WRITE_METHOD(fd, buf, len) (*fd_table[fd].write_method)(fd, buf, len)
  
+ /*
+  * Trap attempts to build large file cache support without support for
+  * large objects
+  */
+ #if LARGE_CACHE_FILES && SIZEOF_SQUID_OFF_T <= 4
+ #error Your platform does not support large integers. Can not build with --enable-large-cache-files
+ #endif
+ 
  #endif /* SQUID_H */
Index: squid/src/ssl.c
diff -c squid/src/ssl.c:1.118.2.9 squid/src/ssl.c:1.118.2.11
*** squid/src/ssl.c:1.118.2.9	Mon Mar 21 12:39:29 2005
--- squid/src/ssl.c	Sun Apr 17 18:54:30 2005
***************
*** 46,52 ****
  	int len;
  	char *buf;
      } client, server;
!     size_t *size_ptr;		/* pointer to size in an ConnStateData for logging */
      int *status_ptr;		/* pointer to status for logging */
  #if DELAY_POOLS
      delay_id delay_id;
--- 46,52 ----
  	int len;
  	char *buf;
      } client, server;
!     squid_off_t *size_ptr;	/* pointer to size in an ConnStateData for logging */
      int *status_ptr;		/* pointer to status for logging */
  #if DELAY_POOLS
      delay_id delay_id;
***************
*** 297,302 ****
--- 297,308 ----
  	fd_bytes(fd, len, FD_WRITE);
  	kb_incr(&statCounter.server.all.kbytes_out, len);
  	kb_incr(&statCounter.server.other.kbytes_out, len);
+ 	/* increment total object size */
+ 	if (sslState->size_ptr && sslState->client.fd != -1)
+ #if SIZEOF_SQUID_OFF_T <= 4
+ 	    if (*sslState->size_ptr < 0x7FFF0000)
+ #endif
+ 		*sslState->size_ptr += len;
  	assert(len <= sslState->client.len);
  	sslState->client.len -= len;
  	if (sslState->client.len > 0) {
***************
*** 339,345 ****
  	sslState->server.len -= len;
  	/* increment total object size */
  	if (sslState->size_ptr)
! #if SIZEOF_SIZE_T == 4
  	    if (*sslState->size_ptr < 0x7FFF0000)
  #endif
  		*sslState->size_ptr += len;
--- 345,351 ----
  	sslState->server.len -= len;
  	/* increment total object size */
  	if (sslState->size_ptr)
! #if SIZEOF_SQUID_OFF_T <= 4
  	    if (*sslState->size_ptr < 0x7FFF0000)
  #endif
  		*sslState->size_ptr += len;
***************
*** 471,477 ****
  
  CBDATA_TYPE(SslStateData);
  void
! sslStart(clientHttpRequest * http, size_t * size_ptr, int *status_ptr)
  {
      /* Create state structure. */
      SslStateData *sslState = NULL;
--- 477,483 ----
  
  CBDATA_TYPE(SslStateData);
  void
! sslStart(clientHttpRequest * http, squid_off_t * size_ptr, int *status_ptr)
  {
      /* Create state structure. */
      SslStateData *sslState = NULL;
Index: squid/src/stat.c
diff -c squid/src/stat.c:1.351.2.12 squid/src/stat.c:1.351.2.14
*** squid/src/stat.c:1.351.2.12	Sun Feb 13 14:19:44 2005
--- squid/src/stat.c	Sat Mar 26 17:40:59 2005
***************
*** 274,295 ****
      memBufPrintf(mb, "\tSwap Dir %d, File %#08X\n",
  	e->swap_dirn, e->swap_filen);
      if (mem != NULL) {
! 	memBufPrintf(mb, "\tinmem_lo: %d\n", (int) mem->inmem_lo);
! 	memBufPrintf(mb, "\tinmem_hi: %d\n", (int) mem->inmem_hi);
! 	memBufPrintf(mb, "\tswapout: %d bytes queued\n",
! 	    (int) mem->swapout.queue_offset);
  	if (mem->swapout.sio)
! 	    memBufPrintf(mb, "\tswapout: %d bytes written\n",
! 		(int) storeOffset(mem->swapout.sio));
  	for (i = 0, node = mem->clients.head; node; node = node->next, i++) {
  	    sc = (store_client *) node->data;
  	    if (sc->callback_data == NULL)
  		continue;
  	    memBufPrintf(mb, "\tClient #%d, %p\n", i, sc->callback_data);
! 	    memBufPrintf(mb, "\t\tcopy_offset: %d\n",
! 		(int) sc->copy_offset);
! 	    memBufPrintf(mb, "\t\tseen_offset: %d\n",
! 		(int) sc->seen_offset);
  	    memBufPrintf(mb, "\t\tcopy_size: %d\n",
  		(int) sc->copy_size);
  	    memBufPrintf(mb, "\t\tflags:");
--- 274,295 ----
      memBufPrintf(mb, "\tSwap Dir %d, File %#08X\n",
  	e->swap_dirn, e->swap_filen);
      if (mem != NULL) {
! 	memBufPrintf(mb, "\tinmem_lo: %" PRINTF_OFF_T "\n", mem->inmem_lo);
! 	memBufPrintf(mb, "\tinmem_hi: %" PRINTF_OFF_T "\n", mem->inmem_hi);
! 	memBufPrintf(mb, "\tswapout: %" PRINTF_OFF_T " bytes queued\n",
! 	    mem->swapout.queue_offset);
  	if (mem->swapout.sio)
! 	    memBufPrintf(mb, "\tswapout: %" PRINTF_OFF_T " bytes written\n",
! 		storeOffset(mem->swapout.sio));
  	for (i = 0, node = mem->clients.head; node; node = node->next, i++) {
  	    sc = (store_client *) node->data;
  	    if (sc->callback_data == NULL)
  		continue;
  	    memBufPrintf(mb, "\tClient #%d, %p\n", i, sc->callback_data);
! 	    memBufPrintf(mb, "\t\tcopy_offset: %" PRINTF_OFF_T "\n",
! 		sc->copy_offset);
! 	    memBufPrintf(mb, "\t\tseen_offset: %" PRINTF_OFF_T "\n",
! 		sc->seen_offset);
  	    memBufPrintf(mb, "\t\tcopy_size: %d\n",
  		(int) sc->copy_size);
  	    memBufPrintf(mb, "\t\tflags:");
***************
*** 432,438 ****
  	f = &fd_table[i];
  	if (!f->flags.open)
  	    continue;
! 	storeAppendPrintf(sentry, "%4d %-6.6s %4d %7d%c %7d%c %-21s %s\n",
  	    i,
  	    fdTypeStr[f->type],
  	    f->timeout_handler ? (int) (f->timeout - squid_curtime) / 60 : 0,
--- 432,438 ----
  	f = &fd_table[i];
  	if (!f->flags.open)
  	    continue;
! 	storeAppendPrintf(sentry, "%4d %-6.6s %4d %7" PRINTF_OFF_T "%c %7" PRINTF_OFF_T "%c %-21s %s\n",
  	    i,
  	    fdTypeStr[f->type],
  	    f->timeout_handler ? (int) (f->timeout - squid_curtime) / 60 : 0,
***************
*** 1397,1403 ****
       */
      cd = CountHist[0].cd.kbytes_recv.kb - CountHist[minutes].cd.kbytes_recv.kb;
      if (s < cd)
! 	debug(18, 1) ("STRANGE: srv_kbytes=%d, cd_kbytes=%d\n", s, cd);
      s -= cd;
  #endif
      if (c > s)
--- 1397,1403 ----
       */
      cd = CountHist[0].cd.kbytes_recv.kb - CountHist[minutes].cd.kbytes_recv.kb;
      if (s < cd)
! 	debug(18, 1) ("STRANGE: srv_kbytes=%d, cd_kbytes=%d\n", (int) s, (int) cd);
      s -= cd;
  #endif
      if (c > s)
***************
*** 1421,1427 ****
  	storeAppendPrintf(s, "Connection: %p\n", conn);
  	if (conn) {
  	    fd = conn->fd;
! 	    storeAppendPrintf(s, "\tFD %d, read %d, wrote %d\n", fd,
  		fd_table[fd].bytes_read, fd_table[fd].bytes_written);
  	    storeAppendPrintf(s, "\tFD desc: %s\n", fd_table[fd].desc);
  	    storeAppendPrintf(s, "\tin: buf %p, offset %ld, size %ld\n",
--- 1421,1427 ----
  	storeAppendPrintf(s, "Connection: %p\n", conn);
  	if (conn) {
  	    fd = conn->fd;
! 	    storeAppendPrintf(s, "\tFD %d, read %" PRINTF_OFF_T ", wrote %" PRINTF_OFF_T "\n", fd,
  		fd_table[fd].bytes_read, fd_table[fd].bytes_written);
  	    storeAppendPrintf(s, "\tFD desc: %s\n", fd_table[fd].desc);
  	    storeAppendPrintf(s, "\tin: buf %p, offset %ld, size %ld\n",
Index: squid/src/stmem.c
diff -c squid/src/stmem.c:1.70.2.2 squid/src/stmem.c:1.70.2.3
*** squid/src/stmem.c:1.70.2.2	Sat Mar 19 04:41:39 2005
--- squid/src/stmem.c	Fri Mar 25 19:50:53 2005
***************
*** 65,74 ****
      mem->origin_offset = 0;
  }
  
! int
! stmemFreeDataUpto(mem_hdr * mem, int target_offset)
  {
!     int current_offset = mem->origin_offset;
      mem_node *p = mem->head;
      while (p && ((current_offset + p->len) <= target_offset)) {
  	if (p == mem->tail) {
--- 65,74 ----
      mem->origin_offset = 0;
  }
  
! squid_off_t
! stmemFreeDataUpto(mem_hdr * mem, squid_off_t target_offset)
  {
!     squid_off_t current_offset = mem->origin_offset;
      mem_node *p = mem->head;
      while (p && ((current_offset + p->len) <= target_offset)) {
  	if (p == mem->tail) {
***************
*** 135,149 ****
  }
  
  ssize_t
! stmemCopy(const mem_hdr * mem, off_t offset, char *buf, size_t size)
  {
      mem_node *p = mem->head;
!     off_t t_off = mem->origin_offset;
      size_t bytes_to_go = size;
      char *ptr_to_buf = NULL;
      int bytes_from_this_packet = 0;
      int bytes_into_this_packet = 0;
!     debug(19, 6) ("memCopy: offset %ld: size %d\n", (long int) offset, (int) size);
      if (p == NULL)
  	return 0;
      assert(size > 0);
--- 135,149 ----
  }
  
  ssize_t
! stmemCopy(const mem_hdr * mem, squid_off_t offset, char *buf, size_t size)
  {
      mem_node *p = mem->head;
!     squid_off_t t_off = mem->origin_offset;
      size_t bytes_to_go = size;
      char *ptr_to_buf = NULL;
      int bytes_from_this_packet = 0;
      int bytes_into_this_packet = 0;
!     debug(19, 6) ("memCopy: offset %" PRINTF_OFF_T ": size %d\n", offset, (int) size);
      if (p == NULL)
  	return 0;
      assert(size > 0);
Index: squid/src/store.c
diff -c squid/src/store.c:1.544.2.7 squid/src/store.c:1.544.2.8
*** squid/src/store.c:1.544.2.7	Fri Jan 21 04:57:38 2005
--- squid/src/store.c	Fri Mar 25 19:50:53 2005
***************
*** 606,612 ****
  	if (mem->object_sz < Config.Store.minObjectSize)
  	    return 1;
      if (mem->reply->content_length > -1)
! 	if (mem->reply->content_length < (int) Config.Store.minObjectSize)
  	    return 1;
      return 0;
  }
--- 606,612 ----
  	if (mem->object_sz < Config.Store.minObjectSize)
  	    return 1;
      if (mem->reply->content_length > -1)
! 	if (mem->reply->content_length < Config.Store.minObjectSize)
  	    return 1;
      return 0;
  }
***************
*** 638,646 ****
  	e->mem_obj->inmem_hi > Config.Store.maxObjectSize) {
  	debug(20, 2) ("storeCheckCachable: NO: too big\n");
  	store_check_cachable_hist.no.too_big++;
-     } else if (e->mem_obj->reply->content_length > (int) Config.Store.maxObjectSize) {
- 	debug(20, 2) ("storeCheckCachable: NO: too big\n");
- 	store_check_cachable_hist.no.too_big++;
      } else if (storeCheckTooSmall(e)) {
  	debug(20, 2) ("storeCheckCachable: NO: too small\n");
  	store_check_cachable_hist.no.too_small++;
--- 638,643 ----
***************
*** 939,956 ****
  static int
  storeEntryValidLength(const StoreEntry * e)
  {
!     int diff;
!     int clen;
      const HttpReply *reply;
      assert(e->mem_obj != NULL);
      reply = e->mem_obj->reply;
      debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", storeKeyText(e->hash.key));
!     debug(20, 5) ("storeEntryValidLength:     object_len = %d\n",
  	objectLen(e));
      debug(20, 5) ("storeEntryValidLength:         hdr_sz = %d\n",
  	reply->hdr_sz);
      clen = httpReplyBodySize(e->mem_obj->method, reply);
!     debug(20, 5) ("storeEntryValidLength: content_length = %d\n",
  	clen);
      if (clen < 0) {
  	debug(20, 5) ("storeEntryValidLength: Unspecified content length: %s\n",
--- 936,953 ----
  static int
  storeEntryValidLength(const StoreEntry * e)
  {
!     squid_off_t diff;
!     squid_off_t clen;
      const HttpReply *reply;
      assert(e->mem_obj != NULL);
      reply = e->mem_obj->reply;
      debug(20, 3) ("storeEntryValidLength: Checking '%s'\n", storeKeyText(e->hash.key));
!     debug(20, 5) ("storeEntryValidLength:     object_len = %" PRINTF_OFF_T "\n",
  	objectLen(e));
      debug(20, 5) ("storeEntryValidLength:         hdr_sz = %d\n",
  	reply->hdr_sz);
      clen = httpReplyBodySize(e->mem_obj->method, reply);
!     debug(20, 5) ("storeEntryValidLength: content_length = %" PRINTF_OFF_T "\n",
  	clen);
      if (clen < 0) {
  	debug(20, 5) ("storeEntryValidLength: Unspecified content length: %s\n",
***************
*** 960,966 ****
      diff = reply->hdr_sz + clen - objectLen(e);
      if (diff == 0)
  	return 1;
!     debug(20, 2) ("storeEntryValidLength: %d bytes too %s; '%s'\n",
  	diff < 0 ? -diff : diff,
  	diff < 0 ? "big" : "small",
  	storeKeyText(e->hash.key));
--- 957,963 ----
      diff = reply->hdr_sz + clen - objectLen(e);
      if (diff == 0)
  	return 1;
!     debug(20, 2) ("storeEntryValidLength: %" PRINTF_OFF_T " bytes too %s; '%s'\n",
  	diff < 0 ? -diff : diff,
  	diff < 0 ? "big" : "small",
  	storeKeyText(e->hash.key));
***************
*** 1128,1142 ****
  	mem->data_hdr.head);
      debug(20, 1) ("MemObject->data.tail: %p\n",
  	mem->data_hdr.tail);
!     debug(20, 1) ("MemObject->data.origin_offset: %d\n",
  	mem->data_hdr.origin_offset);
!     debug(20, 1) ("MemObject->start_ping: %d.%06d\n",
! 	(int) mem->start_ping.tv_sec,
  	(int) mem->start_ping.tv_usec);
!     debug(20, 1) ("MemObject->inmem_hi: %d\n",
! 	(int) mem->inmem_hi);
!     debug(20, 1) ("MemObject->inmem_lo: %d\n",
! 	(int) mem->inmem_lo);
      debug(20, 1) ("MemObject->nclients: %d\n",
  	mem->nclients);
      debug(20, 1) ("MemObject->reply: %p\n",
--- 1125,1139 ----
  	mem->data_hdr.head);
      debug(20, 1) ("MemObject->data.tail: %p\n",
  	mem->data_hdr.tail);
!     debug(20, 1) ("MemObject->data.origin_offset: %" PRINTF_OFF_T "\n",
  	mem->data_hdr.origin_offset);
!     debug(20, 1) ("MemObject->start_ping: %ld.%06d\n",
! 	(long int) mem->start_ping.tv_sec,
  	(int) mem->start_ping.tv_usec);
!     debug(20, 1) ("MemObject->inmem_hi: %" PRINTF_OFF_T "\n",
! 	mem->inmem_hi);
!     debug(20, 1) ("MemObject->inmem_lo: %" PRINTF_OFF_T "\n",
! 	mem->inmem_lo);
      debug(20, 1) ("MemObject->nclients: %d\n",
  	mem->nclients);
      debug(20, 1) ("MemObject->reply: %p\n",
***************
*** 1154,1164 ****
      debug(20, l) ("StoreEntry->key: %s\n", storeKeyText(e->hash.key));
      debug(20, l) ("StoreEntry->next: %p\n", e->hash.next);
      debug(20, l) ("StoreEntry->mem_obj: %p\n", e->mem_obj);
!     debug(20, l) ("StoreEntry->timestamp: %d\n", (int) e->timestamp);
!     debug(20, l) ("StoreEntry->lastref: %d\n", (int) e->lastref);
!     debug(20, l) ("StoreEntry->expires: %d\n", (int) e->expires);
!     debug(20, l) ("StoreEntry->lastmod: %d\n", (int) e->lastmod);
!     debug(20, l) ("StoreEntry->swap_file_sz: %d\n", (int) e->swap_file_sz);
      debug(20, l) ("StoreEntry->refcount: %d\n", e->refcount);
      debug(20, l) ("StoreEntry->flags: %s\n", storeEntryFlags(e));
      debug(20, l) ("StoreEntry->swap_dirn: %d\n", (int) e->swap_dirn);
--- 1151,1161 ----
      debug(20, l) ("StoreEntry->key: %s\n", storeKeyText(e->hash.key));
      debug(20, l) ("StoreEntry->next: %p\n", e->hash.next);
      debug(20, l) ("StoreEntry->mem_obj: %p\n", e->mem_obj);
!     debug(20, l) ("StoreEntry->timestamp: %ld\n", (long int) e->timestamp);
!     debug(20, l) ("StoreEntry->lastref: %ld\n", (long int) e->lastref);
!     debug(20, l) ("StoreEntry->expires: %ld\n", (long int) e->expires);
!     debug(20, l) ("StoreEntry->lastmod: %ld\n", (long int) e->lastmod);
!     debug(20, l) ("StoreEntry->swap_file_sz: %" PRINTF_OFF_T "\n", (squid_off_t) e->swap_file_sz);
      debug(20, l) ("StoreEntry->refcount: %d\n", e->refcount);
      debug(20, l) ("StoreEntry->flags: %s\n", storeEntryFlags(e));
      debug(20, l) ("StoreEntry->swap_dirn: %d\n", (int) e->swap_dirn);
***************
*** 1240,1253 ****
      storeSwapOut(e);
  }
  
! int
  objectLen(const StoreEntry * e)
  {
      assert(e->mem_obj != NULL);
      return e->mem_obj->object_sz;
  }
  
! int
  contentLen(const StoreEntry * e)
  {
      assert(e->mem_obj != NULL);
--- 1237,1250 ----
      storeSwapOut(e);
  }
  
! squid_off_t
  objectLen(const StoreEntry * e)
  {
      assert(e->mem_obj != NULL);
      return e->mem_obj->object_sz;
  }
  
! squid_off_t
  contentLen(const StoreEntry * e)
  {
      assert(e->mem_obj != NULL);
Index: squid/src/store_client.c
diff -c squid/src/store_client.c:1.105.2.2 squid/src/store_client.c:1.105.2.4
*** squid/src/store_client.c:1.105.2.2	Wed Aug  6 07:49:03 2003
--- squid/src/store_client.c	Tue Apr 19 16:19:27 2005
***************
*** 141,150 ****
      sc->flags.disk_io_pending = 0;
      sc->entry = e;
      sc->type = storeClientType(e);
-     if (sc->type == STORE_DISK_CLIENT)
- 	/* assert we'll be able to get the data we want */
- 	/* maybe we should open swapin_fd here */
- 	assert(e->swap_filen > -1 || storeSwapOutAble(e));
      dlinkAdd(sc, &sc->node, &mem->clients);
  #if DELAY_POOLS
      sc->delay_id = 0;
--- 141,146 ----
***************
*** 179,196 ****
  void
  storeClientCopy(store_client * sc,
      StoreEntry * e,
!     off_t seen_offset,
!     off_t copy_offset,
      size_t size,
      char *buf,
      STCB * callback,
      void *data)
  {
      assert(!EBIT_TEST(e->flags, ENTRY_ABORTED));
!     debug(20, 3) ("storeClientCopy: %s, seen %d, want %d, size %d, cb %p, cbdata %p\n",
  	storeKeyText(e->hash.key),
! 	(int) seen_offset,
! 	(int) copy_offset,
  	(int) size,
  	callback,
  	data);
--- 175,192 ----
  void
  storeClientCopy(store_client * sc,
      StoreEntry * e,
!     squid_off_t seen_offset,
!     squid_off_t copy_offset,
      size_t size,
      char *buf,
      STCB * callback,
      void *data)
  {
      assert(!EBIT_TEST(e->flags, ENTRY_ABORTED));
!     debug(20, 3) ("storeClientCopy: %s, seen %" PRINTF_OFF_T ", want %" PRINTF_OFF_T ", size %d, cb %p, cbdata %p\n",
  	storeKeyText(e->hash.key),
! 	seen_offset,
! 	copy_offset,
  	(int) size,
  	callback,
  	data);
***************
*** 220,226 ****
  static int
  storeClientNoMoreToSend(StoreEntry * e, store_client * sc)
  {
!     ssize_t len;
      if (e->store_status == STORE_PENDING)
  	return 0;
      if ((len = objectLen(e)) < 0)
--- 216,222 ----
  static int
  storeClientNoMoreToSend(StoreEntry * e, store_client * sc)
  {
!     squid_off_t len;
      if (e->store_status == STORE_PENDING)
  	return 0;
      if ((len = objectLen(e)) < 0)
***************
*** 265,271 ****
  storeClientCopy3(StoreEntry * e, store_client * sc)
  {
      MemObject *mem = e->mem_obj;
!     size_t sz;
  
      if (storeClientNoMoreToSend(e, sc)) {
  	/* There is no more to send! */
--- 261,267 ----
  storeClientCopy3(StoreEntry * e, store_client * sc)
  {
      MemObject *mem = e->mem_obj;
!     ssize_t sz;
  
      if (storeClientNoMoreToSend(e, sc)) {
  	/* There is no more to send! */
***************
*** 316,321 ****
--- 312,319 ----
  	debug(20, 3) ("storeClientCopy3: Copying from memory\n");
  	sz = stmemCopy(&mem->data_hdr,
  	    sc->copy_offset, sc->copy_buf, sc->copy_size);
+ 	if (EBIT_TEST(e->flags, RELEASE_REQUEST))
+ 	    storeSwapOutMaintainMemObject(e);
  	storeClientCallback(sc, sz);
  	return;
      }
***************
*** 342,348 ****
  	    sc);
      } else {
  	if (sc->entry->swap_status == SWAPOUT_WRITING)
! 	    assert(storeOffset(mem->swapout.sio) > sc->copy_offset + mem->swap_hdr_sz);
  	storeRead(sc->swapin_sio,
  	    sc->copy_buf,
  	    sc->copy_size,
--- 340,346 ----
  	    sc);
      } else {
  	if (sc->entry->swap_status == SWAPOUT_WRITING)
! 	    assert(storeSwapOutObjectBytesOnDisk(mem) > sc->copy_offset);
  	storeRead(sc->swapin_sio,
  	    sc->copy_buf,
  	    sc->copy_size,
***************
*** 431,436 ****
--- 429,435 ----
  	    }
  	    break;
  	case STORE_META_STD:
+ 	case STORE_META_STD_LFS:
  	    break;
  	case STORE_META_VARY_HEADERS:
  	    if (mem->vary_headers) {
***************
*** 534,549 ****
      /*assert(!sc->flags.disk_io_pending); */
      cbdataFree(sc);
      assert(e->lock_count > 0);
      if (mem->nclients == 0)
  	CheckQuickAbort(e);
      return 1;
  }
  
! off_t
  storeLowestMemReaderOffset(const StoreEntry * entry)
  {
      const MemObject *mem = entry->mem_obj;
!     off_t lowest = mem->inmem_hi + 1;
      store_client *sc;
      dlink_node *nx = NULL;
      dlink_node *node;
--- 533,550 ----
      /*assert(!sc->flags.disk_io_pending); */
      cbdataFree(sc);
      assert(e->lock_count > 0);
+     storeSwapOutMaintainMemObject(e);
      if (mem->nclients == 0)
  	CheckQuickAbort(e);
      return 1;
  }
  
! squid_off_t
  storeLowestMemReaderOffset(const StoreEntry * entry)
  {
      const MemObject *mem = entry->mem_obj;
!     squid_off_t lowest = mem->inmem_hi + 1;
!     squid_off_t highest = -1;
      store_client *sc;
      dlink_node *nx = NULL;
      dlink_node *node;
***************
*** 553,566 ****
  	nx = node->next;
  	if (sc->callback_data == NULL)	/* open slot */
  	    continue;
! 	if (sc->type != STORE_MEM_CLIENT)
  	    continue;
- 	if (sc->type == STORE_DISK_CLIENT)
- 	    if (NULL != sc->swapin_sio)
- 		continue;
  	if (sc->copy_offset < lowest)
  	    lowest = sc->copy_offset;
      }
      return lowest;
  }
  
--- 554,568 ----
  	nx = node->next;
  	if (sc->callback_data == NULL)	/* open slot */
  	    continue;
! 	if (sc->copy_offset > highest)
! 	    highest = sc->copy_offset;
! 	if (mem->swapout.sio != NULL && sc->type != STORE_MEM_CLIENT)
  	    continue;
  	if (sc->copy_offset < lowest)
  	    lowest = sc->copy_offset;
      }
+     if (highest < lowest && highest >= 0)
+ 	return highest;
      return lowest;
  }
  
***************
*** 603,611 ****
  static int
  CheckQuickAbort2(StoreEntry * entry)
  {
!     int curlen;
!     int minlen;
!     int expectlen;
      MemObject *mem = entry->mem_obj;
      assert(mem);
      debug(20, 3) ("CheckQuickAbort2: entry=%p, mem=%p\n", entry, mem);
--- 605,613 ----
  static int
  CheckQuickAbort2(StoreEntry * entry)
  {
!     squid_off_t curlen;
!     squid_off_t minlen;
!     squid_off_t expectlen;
      MemObject *mem = entry->mem_obj;
      assert(mem);
      debug(20, 3) ("CheckQuickAbort2: entry=%p, mem=%p\n", entry, mem);
***************
*** 618,625 ****
  	return 1;
      }
      expectlen = mem->reply->content_length + mem->reply->hdr_sz;
!     curlen = (int) mem->inmem_hi;
!     minlen = (int) Config.quickAbort.min << 10;
      if (minlen < 0) {
  	debug(20, 3) ("CheckQuickAbort2: NO disabled\n");
  	return 0;
--- 620,627 ----
  	return 1;
      }
      expectlen = mem->reply->content_length + mem->reply->hdr_sz;
!     curlen = mem->inmem_hi;
!     minlen = Config.quickAbort.min << 10;
      if (minlen < 0) {
  	debug(20, 3) ("CheckQuickAbort2: NO disabled\n");
  	return 0;
Index: squid/src/store_dir.c
diff -c squid/src/store_dir.c:1.135.2.2 squid/src/store_dir.c:1.135.2.3
*** squid/src/store_dir.c:1.135.2.2	Thu Jul 17 09:39:49 2003
--- squid/src/store_dir.c	Fri Mar 25 19:50:54 2005
***************
*** 45,51 ****
  #include <sys/vfs.h>
  #endif
  
! static int storeDirValidSwapDirSize(int, ssize_t);
  static STDIRSELECT storeDirSelectSwapDirRoundRobin;
  static STDIRSELECT storeDirSelectSwapDirLeastLoad;
  
--- 45,51 ----
  #include <sys/vfs.h>
  #endif
  
! static int storeDirValidSwapDirSize(int, squid_off_t);
  static STDIRSELECT storeDirSelectSwapDirRoundRobin;
  static STDIRSELECT storeDirSelectSwapDirLeastLoad;
  
***************
*** 106,112 ****
   * ie any-sized-object swapdirs. This is a good thing.
   */
  static int
! storeDirValidSwapDirSize(int swapdir, ssize_t objsize)
  {
      /*
       * If the swapdir's max_obj_size is -1, then it definitely can
--- 106,112 ----
   * ie any-sized-object swapdirs. This is a good thing.
   */
  static int
! storeDirValidSwapDirSize(int swapdir, squid_off_t objsize)
  {
      /*
       * If the swapdir's max_obj_size is -1, then it definitely can
***************
*** 144,150 ****
      int i;
      int load;
      SwapDir *sd;
!     ssize_t objsize = (ssize_t) objectLen(e);
      for (i = 0; i <= Config.cacheSwap.n_configured; i++) {
  	if (++dirn >= Config.cacheSwap.n_configured)
  	    dirn = 0;
--- 144,150 ----
      int i;
      int load;
      SwapDir *sd;
!     squid_off_t objsize = objectLen(e);
      for (i = 0; i <= Config.cacheSwap.n_configured; i++) {
  	if (++dirn >= Config.cacheSwap.n_configured)
  	    dirn = 0;
***************
*** 181,189 ****
  static int
  storeDirSelectSwapDirLeastLoad(const StoreEntry * e)
  {
!     ssize_t objsize;
!     ssize_t most_free = 0, cur_free;
!     ssize_t least_objsize = -1;
      int least_load = INT_MAX;
      int load;
      int dirn = -1;
--- 181,189 ----
  static int
  storeDirSelectSwapDirLeastLoad(const StoreEntry * e)
  {
!     squid_off_t objsize;
!     int most_free = 0, cur_free;
!     squid_off_t least_objsize = -1;
      int least_load = INT_MAX;
      int load;
      int dirn = -1;
***************
*** 191,197 ****
      SwapDir *SD;
  
      /* Calculate the object size */
!     objsize = (ssize_t) objectLen(e);
      if (objsize != -1)
  	objsize += e->mem_obj->swap_hdr_sz;
      for (i = 0; i < Config.cacheSwap.n_configured; i++) {
--- 191,197 ----
      SwapDir *SD;
  
      /* Calculate the object size */
!     objsize = objectLen(e);
      if (objsize != -1)
  	objsize += e->mem_obj->swap_hdr_sz;
      for (i = 0; i < Config.cacheSwap.n_configured; i++) {
***************
*** 270,276 ****
  }
  
  void
! storeDirUpdateSwapSize(SwapDir * SD, size_t size, int sign)
  {
      int blks = (size + SD->fs.blksize - 1) / SD->fs.blksize;
      int k = (blks * SD->fs.blksize >> 10) * sign;
--- 270,276 ----
  }
  
  void
! storeDirUpdateSwapSize(SwapDir * SD, squid_off_t size, int sign)
  {
      int blks = (size + SD->fs.blksize - 1) / SD->fs.blksize;
      int k = (blks * SD->fs.blksize >> 10) * sign;
Index: squid/src/store_io.c
diff -c squid/src/store_io.c:1.10 squid/src/store_io.c:1.10.2.1
*** squid/src/store_io.c:1.10	Wed Oct 24 02:19:09 2001
--- squid/src/store_io.c	Fri Mar 25 19:50:54 2005
***************
*** 76,89 ****
  }
  
  void
! storeRead(storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
  {
      SwapDir *SD = &Config.cacheSwap.swapDirs[sio->swap_dirn];
      SD->obj.read(SD, sio, buf, size, offset, callback, callback_data);
  }
  
  void
! storeWrite(storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
  {
      SwapDir *SD = &Config.cacheSwap.swapDirs[sio->swap_dirn];
      SD->obj.write(SD, sio, buf, size, offset, free_func);
--- 76,89 ----
  }
  
  void
! storeRead(storeIOState * sio, char *buf, size_t size, squid_off_t offset, STRCB * callback, void *callback_data)
  {
      SwapDir *SD = &Config.cacheSwap.swapDirs[sio->swap_dirn];
      SD->obj.read(SD, sio, buf, size, offset, callback, callback_data);
  }
  
  void
! storeWrite(storeIOState * sio, char *buf, size_t size, squid_off_t offset, FREE * free_func)
  {
      SwapDir *SD = &Config.cacheSwap.swapDirs[sio->swap_dirn];
      SD->obj.write(SD, sio, buf, size, offset, free_func);
***************
*** 96,102 ****
      SD->obj.unlink(SD, e);
  }
  
! off_t
  storeOffset(storeIOState * sio)
  {
      return sio->offset;
--- 96,102 ----
      SD->obj.unlink(SD, e);
  }
  
! squid_off_t
  storeOffset(storeIOState * sio)
  {
      return sio->offset;
Index: squid/src/store_log.c
diff -c squid/src/store_log.c:1.23 squid/src/store_log.c:1.23.2.1
*** squid/src/store_log.c:1.23	Wed Oct 17 14:25:03 2001
--- squid/src/store_log.c	Fri Mar 25 19:50:54 2005
***************
*** 69,94 ****
  	 * Because if we print it before the swap file number, it'll break
  	 * the existing log format.
  	 */
! 	logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d %s %d/%d %s %s\n",
! 	    (int) current_time.tv_sec,
  	    (int) current_time.tv_usec / 1000,
  	    storeLogTags[tag],
  	    e->swap_dirn,
  	    e->swap_filen,
  	    storeKeyText(e->hash.key),
  	    reply->sline.status,
! 	    (int) reply->date,
! 	    (int) reply->last_modified,
! 	    (int) reply->expires,
  	    strLen(reply->content_type) ? strBuf(reply->content_type) : "unknown",
  	    reply->content_length,
! 	    (int) (mem->inmem_hi - mem->reply->hdr_sz),
  	    RequestMethodStr[mem->method],
  	    mem->log_url);
      } else {
  	/* no mem object. Most RELEASE cases */
! 	logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s   ?         ?         ?         ? ?/? ?/? ? ?\n",
! 	    (int) current_time.tv_sec,
  	    (int) current_time.tv_usec / 1000,
  	    storeLogTags[tag],
  	    e->swap_dirn,
--- 69,94 ----
  	 * Because if we print it before the swap file number, it'll break
  	 * the existing log format.
  	 */
! 	logfilePrintf(storelog, "%9ld.%03d %-7s %02d %08X %s %4d %9ld %9ld %9ld %s %" PRINTF_OFF_T "/%" PRINTF_OFF_T " %s %s\n",
! 	    (long int) current_time.tv_sec,
  	    (int) current_time.tv_usec / 1000,
  	    storeLogTags[tag],
  	    e->swap_dirn,
  	    e->swap_filen,
  	    storeKeyText(e->hash.key),
  	    reply->sline.status,
! 	    (long int) reply->date,
! 	    (long int) reply->last_modified,
! 	    (long int) reply->expires,
  	    strLen(reply->content_type) ? strBuf(reply->content_type) : "unknown",
  	    reply->content_length,
! 	    mem->inmem_hi - mem->reply->hdr_sz,
  	    RequestMethodStr[mem->method],
  	    mem->log_url);
      } else {
  	/* no mem object. Most RELEASE cases */
! 	logfilePrintf(storelog, "%9ld.%03d %-7s %02d %08X %s   ?         ?         ?         ? ?/? ?/? ? ?\n",
! 	    (long int) current_time.tv_sec,
  	    (int) current_time.tv_usec / 1000,
  	    storeLogTags[tag],
  	    e->swap_dirn,
Index: squid/src/store_swapmeta.c
diff -c squid/src/store_swapmeta.c:1.17 squid/src/store_swapmeta.c:1.17.2.1
*** squid/src/store_swapmeta.c:1.17	Wed Oct 24 02:52:37 2001
--- squid/src/store_swapmeta.c	Fri Mar 25 19:50:54 2005
***************
*** 73,79 ****
--- 73,83 ----
      url = storeUrl(e);
      debug(20, 3) ("storeSwapMetaBuild: %s\n", url);
      T = storeSwapTLVAdd(STORE_META_KEY, e->hash.key, MD5_DIGEST_CHARS, T);
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
      T = storeSwapTLVAdd(STORE_META_STD, &e->timestamp, STORE_HDR_METASIZE, T);
+ #else
+     T = storeSwapTLVAdd(STORE_META_STD_LFS, &e->timestamp, STORE_HDR_METASIZE, T);
+ #endif
      T = storeSwapTLVAdd(STORE_META_URL, url, strlen(url) + 1, T);
      vary = e->mem_obj->vary_headers;
      if (vary)
***************
*** 86,92 ****
  {
      int buflen = 0;
      tlv *t;
!     off_t j = 0;
      char *buf;
      assert(length != NULL);
      buflen++;			/* STORE_META_OK */
--- 90,96 ----
  {
      int buflen = 0;
      tlv *t;
!     int j = 0;
      char *buf;
      assert(length != NULL);
      buflen++;			/* STORE_META_OK */
***************
*** 119,125 ****
      char type;
      int length;
      int buflen;
!     off_t j = 0;
      assert(buf != NULL);
      assert(hdr_len != NULL);
      if (buf[j++] != (char) STORE_META_OK)
--- 123,129 ----
      char type;
      int length;
      int buflen;
!     int j = 0;
      assert(buf != NULL);
      assert(hdr_len != NULL);
      if (buf[j++] != (char) STORE_META_OK)
Index: squid/src/store_swapout.c
diff -c squid/src/store_swapout.c:1.85.2.2 squid/src/store_swapout.c:1.85.2.9
*** squid/src/store_swapout.c:1.85.2.2	Fri Mar 18 17:01:52 2005
--- squid/src/store_swapout.c	Wed Apr 20 08:57:29 2005
***************
*** 35,44 ****
  
  #include "squid.h"
  
- static off_t storeSwapOutObjectBytesOnDisk(const MemObject *);
  static void storeSwapOutStart(StoreEntry * e);
  static STIOCB storeSwapOutFileClosed;
  static STIOCB storeSwapOutFileNotify;
  
  /* start swapping object to disk */
  static void
--- 35,44 ----
  
  #include "squid.h"
  
  static void storeSwapOutStart(StoreEntry * e);
  static STIOCB storeSwapOutFileClosed;
  static STIOCB storeSwapOutFileNotify;
+ static int storeSwapOutAble(const StoreEntry * e);
  
  /* start swapping object to disk */
  static void
***************
*** 95,109 ****
      e->swap_dirn = mem->swapout.sio->swap_dirn;
  }
  
  void
  storeSwapOut(StoreEntry * e)
  {
      MemObject *mem = e->mem_obj;
!     off_t lowest_offset;
!     off_t new_mem_lo;
!     off_t on_disk = 0;
!     ssize_t swapout_size;
!     ssize_t swap_buf_len;
      if (mem == NULL)
  	return;
      /* should we swap something out to disk? */
--- 95,159 ----
      e->swap_dirn = mem->swapout.sio->swap_dirn;
  }
  
+ /* as sideeffect returns if the object can be cached */
+ int
+ storeSwapOutMaintainMemObject(StoreEntry * e)
+ {
+     MemObject *mem = e->mem_obj;
+     squid_off_t lowest_offset;
+     squid_off_t new_mem_lo;
+     int swapout_able = storeSwapOutAble(e);
+ 
+     /* Don't pollute the disk with icons and other special entries */
+     if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
+ 	return -1;
+ 
+     if (!swapout_able) {
+ 	/* Stop writing to disk */
+ 	storeReleaseRequest(e);
+ 	if (e->mem_obj->swapout.sio != NULL)
+ 	    storeSwapOutFileClose(e);
+     }
+     /* storeLowestMemReaderOffset must be after the storeSwapOutFileClose
+      * call above as storeLowestMemReaderOffset needs to know if we are
+      * still writing to disk or not
+      */
+     lowest_offset = storeLowestMemReaderOffset(e);
+     debug(20, 7) ("storeSwapOut: lowest_offset = %" PRINTF_OFF_T "\n",
+ 	lowest_offset);
+     /*
+      * Careful.  lowest_offset can be greater than inmem_hi, such
+      * as in the case of a range request.
+      */
+     if (mem->inmem_hi < lowest_offset)
+ 	new_mem_lo = lowest_offset;
+     else if (mem->inmem_hi > Config.Store.maxInMemObjSize)
+ 	new_mem_lo = lowest_offset;
+     else if (mem->reply->content_length > Config.Store.maxInMemObjSize)
+ 	new_mem_lo = lowest_offset;
+     else
+ 	new_mem_lo = mem->inmem_lo;
+     /* The -1 makes sure the page isn't freed until storeSwapOut has
+      * walked to the next page. (mem->swapout.memnode) */
+     if (swapout_able) {
+ 	squid_off_t on_disk = storeSwapOutObjectBytesOnDisk(e->mem_obj);
+ 	if (on_disk - 1 < new_mem_lo)
+ 	    new_mem_lo = on_disk - 1;
+     }
+     if (new_mem_lo < mem->inmem_lo)
+ 	new_mem_lo = mem->inmem_lo;
+     if (mem->inmem_lo != new_mem_lo)
+ 	mem->inmem_lo = stmemFreeDataUpto(&mem->data_hdr, new_mem_lo);
+     return swapout_able;
+ }
+ 
  void
  storeSwapOut(StoreEntry * e)
  {
      MemObject *mem = e->mem_obj;
!     int swapout_able;
!     squid_off_t swapout_size;
!     size_t swap_buf_len;
      if (mem == NULL)
  	return;
      /* should we swap something out to disk? */
***************
*** 119,142 ****
  	debug(20, 3) ("storeSwapOut: %s SPECIAL\n", storeUrl(e));
  	return;
      }
!     debug(20, 7) ("storeSwapOut: mem->inmem_lo = %d\n",
! 	(int) mem->inmem_lo);
!     debug(20, 7) ("storeSwapOut: mem->inmem_hi = %d\n",
! 	(int) mem->inmem_hi);
!     debug(20, 7) ("storeSwapOut: swapout.queue_offset = %d\n",
! 	(int) mem->swapout.queue_offset);
      if (mem->swapout.sio)
! 	debug(20, 7) ("storeSwapOut: storeOffset() = %d\n",
! 	    (int) storeOffset(mem->swapout.sio));
      assert(mem->inmem_hi >= mem->swapout.queue_offset);
-     lowest_offset = storeLowestMemReaderOffset(e);
-     debug(20, 7) ("storeSwapOut: lowest_offset = %d\n",
- 	(int) lowest_offset);
      /*
       * Grab the swapout_size and check to see whether we're going to defer
       * the swapout based upon size
       */
!     swapout_size = (ssize_t) (mem->inmem_hi - mem->swapout.queue_offset);
      if ((e->store_status != STORE_OK) && (swapout_size < store_maxobjsize)) {
  	/*
  	 * NOTE: the store_maxobjsize here is the max of optional
--- 169,189 ----
  	debug(20, 3) ("storeSwapOut: %s SPECIAL\n", storeUrl(e));
  	return;
      }
!     debug(20, 7) ("storeSwapOut: mem->inmem_lo = %" PRINTF_OFF_T "\n",
! 	mem->inmem_lo);
!     debug(20, 7) ("storeSwapOut: mem->inmem_hi = %" PRINTF_OFF_T "\n",
! 	mem->inmem_hi);
!     debug(20, 7) ("storeSwapOut: swapout.queue_offset = %" PRINTF_OFF_T "\n",
! 	mem->swapout.queue_offset);
      if (mem->swapout.sio)
! 	debug(20, 7) ("storeSwapOut: storeOffset() = %" PRINTF_OFF_T "\n",
! 	    storeOffset(mem->swapout.sio));
      assert(mem->inmem_hi >= mem->swapout.queue_offset);
      /*
       * Grab the swapout_size and check to see whether we're going to defer
       * the swapout based upon size
       */
!     swapout_size = mem->inmem_hi - mem->swapout.queue_offset;
      if ((e->store_status != STORE_OK) && (swapout_size < store_maxobjsize)) {
  	/*
  	 * NOTE: the store_maxobjsize here is the max of optional
***************
*** 151,203 ****
  	debug(20, 5) ("storeSwapOut: Deferring starting swapping out\n");
  	return;
      }
!     /*
!      * Careful.  lowest_offset can be greater than inmem_hi, such
!      * as in the case of a range request.
!      */
!     if (mem->inmem_hi < lowest_offset)
! 	new_mem_lo = lowest_offset;
!     else if (mem->inmem_hi - mem->inmem_lo > Config.Store.maxInMemObjSize)
! 	new_mem_lo = lowest_offset;
!     else
! 	new_mem_lo = mem->inmem_lo;
!     assert(new_mem_lo >= mem->inmem_lo);
!     if (storeSwapOutAble(e)) {
! 	/*
! 	 * We should only free up to what we know has been written
! 	 * to disk, not what has been queued for writing.  Otherwise
! 	 * there will be a chunk of the data which is not in memory
! 	 * and is not yet on disk.
! 	 * The -1 makes sure the page isn't freed until storeSwapOut has
! 	 * walked to the next page. (mem->swapout.memnode)
! 	 */
! 	if ((on_disk = storeSwapOutObjectBytesOnDisk(mem)) - 1 < new_mem_lo)
! 	    new_mem_lo = on_disk - 1;
! 	if (new_mem_lo == -1)
! 	    new_mem_lo = 0;	/* the above might become -1 */
!     } else if (new_mem_lo > 0) {
! 	/*
! 	 * Its not swap-able, and we're about to delete a chunk,
! 	 * so we must make it PRIVATE.  This is tricky/ugly because
! 	 * for the most part, we treat swapable == cachable here.
! 	 */
! 	storeReleaseRequest(e);
!     }
!     stmemFreeDataUpto(&mem->data_hdr, new_mem_lo);
!     mem->inmem_lo = new_mem_lo;
! #if SIZEOF_OFF_T == 4
      if (mem->inmem_hi > 0x7FFF0000) {
! 	debug(20, 0) ("WARNING: preventing off_t overflow for %s\n", storeUrl(e));
  	storeAbort(e);
  	return;
      }
  #endif
!     if (e->swap_status == SWAPOUT_WRITING)
! 	assert(mem->inmem_lo <= on_disk);
!     if (!storeSwapOutAble(e))
  	return;
!     debug(20, 7) ("storeSwapOut: swapout_size = %d\n",
! 	(int) swapout_size);
      if (swapout_size == 0) {
  	if (e->store_status == STORE_OK)
  	    storeSwapOutFileClose(e);
--- 198,215 ----
  	debug(20, 5) ("storeSwapOut: Deferring starting swapping out\n");
  	return;
      }
!     swapout_able = storeSwapOutMaintainMemObject(e);
! #if SIZEOF_SQUID_OFF_T <= 4
      if (mem->inmem_hi > 0x7FFF0000) {
! 	debug(20, 0) ("WARNING: preventing squid_off_t overflow for %s\n", storeUrl(e));
  	storeAbort(e);
  	return;
      }
  #endif
!     if (!swapout_able)
  	return;
!     debug(20, 7) ("storeSwapOut: swapout_size = %" PRINTF_OFF_T "\n",
! 	swapout_size);
      if (swapout_size == 0) {
  	if (e->store_status == STORE_OK)
  	    storeSwapOutFileClose(e);
***************
*** 253,266 ****
  
  	debug(20, 3) ("storeSwapOut: swap_buf_len = %d\n", (int) swap_buf_len);
  	assert(swap_buf_len > 0);
! 	debug(20, 3) ("storeSwapOut: swapping out %ld bytes from %ld\n",
! 	    (long int) swap_buf_len, (long int) mem->swapout.queue_offset);
  	mem->swapout.queue_offset += swap_buf_len;
  	storeWrite(mem->swapout.sio, stmemNodeGet(mem->swapout.memnode), swap_buf_len, -1, stmemNodeFree);
  	/* the storeWrite() call might generate an error */
  	if (e->swap_status != SWAPOUT_WRITING)
  	    break;
! 	swapout_size = (ssize_t) (mem->inmem_hi - mem->swapout.queue_offset);
  	if (e->store_status == STORE_PENDING)
  	    if (swapout_size < SM_PAGE_SIZE)
  		break;
--- 265,278 ----
  
  	debug(20, 3) ("storeSwapOut: swap_buf_len = %d\n", (int) swap_buf_len);
  	assert(swap_buf_len > 0);
! 	debug(20, 3) ("storeSwapOut: swapping out %d bytes from %" PRINTF_OFF_T "\n",
! 	    (int) swap_buf_len, mem->swapout.queue_offset);
  	mem->swapout.queue_offset += swap_buf_len;
  	storeWrite(mem->swapout.sio, stmemNodeGet(mem->swapout.memnode), swap_buf_len, -1, stmemNodeFree);
  	/* the storeWrite() call might generate an error */
  	if (e->swap_status != SWAPOUT_WRITING)
  	    break;
! 	swapout_size = mem->inmem_hi - mem->swapout.queue_offset;
  	if (e->store_status == STORE_PENDING)
  	    if (swapout_size < SM_PAGE_SIZE)
  		break;
***************
*** 283,294 ****
  storeSwapOutFileClose(StoreEntry * e)
  {
      MemObject *mem = e->mem_obj;
      assert(mem != NULL);
      debug(20, 3) ("storeSwapOutFileClose: %s\n", storeKeyText(e->hash.key));
      debug(20, 3) ("storeSwapOutFileClose: sio = %p\n", mem->swapout.sio);
!     if (mem->swapout.sio == NULL)
  	return;
!     storeClose(mem->swapout.sio);
  }
  
  static void
--- 295,308 ----
  storeSwapOutFileClose(StoreEntry * e)
  {
      MemObject *mem = e->mem_obj;
+     storeIOState *sio = mem->swapout.sio;
      assert(mem != NULL);
      debug(20, 3) ("storeSwapOutFileClose: %s\n", storeKeyText(e->hash.key));
      debug(20, 3) ("storeSwapOutFileClose: sio = %p\n", mem->swapout.sio);
!     if (sio == NULL)
  	return;
!     mem->swapout.sio = NULL;
!     storeClose(sio);
  }
  
  static void
***************
*** 329,341 ****
      debug(20, 3) ("storeSwapOutFileClosed: %s:%d\n", __FILE__, __LINE__);
      mem->swapout.sio = NULL;
      cbdataUnlock(sio);
      storeUnlockObject(e);
  }
  
  /*
   * How much of the object data is on the disk?
   */
! static off_t
  storeSwapOutObjectBytesOnDisk(const MemObject * mem)
  {
      /*
--- 343,356 ----
      debug(20, 3) ("storeSwapOutFileClosed: %s:%d\n", __FILE__, __LINE__);
      mem->swapout.sio = NULL;
      cbdataUnlock(sio);
+     storeSwapOutMaintainMemObject(e);
      storeUnlockObject(e);
  }
  
  /*
   * How much of the object data is on the disk?
   */
! squid_off_t
  storeSwapOutObjectBytesOnDisk(const MemObject * mem)
  {
      /*
***************
*** 351,357 ****
       */
      off_t nwritten;
      if (mem->swapout.sio == NULL)
! 	return 0;
      nwritten = storeOffset(mem->swapout.sio);
      if (nwritten <= mem->swap_hdr_sz)
  	return 0;
--- 366,372 ----
       */
      off_t nwritten;
      if (mem->swapout.sio == NULL)
! 	return mem->swapout.queue_offset;
      nwritten = storeOffset(mem->swapout.sio);
      if (nwritten <= mem->swap_hdr_sz)
  	return 0;
***************
*** 361,384 ****
  /*
   * Is this entry a candidate for writing to disk?
   */
! int
  storeSwapOutAble(const StoreEntry * e)
  {
!     dlink_node *node;
      if (e->mem_obj->swapout.sio != NULL)
  	return 1;
!     if (e->mem_obj->inmem_lo > 0)
! 	return 0;
!     /*
!      * If there are DISK clients, we must write to disk
!      * even if its not cachable
!      */
!     for (node = e->mem_obj->clients.head; node; node = node->next) {
! 	if (((store_client *) node->data)->type == STORE_DISK_CLIENT)
  	    return 1;
!     }
!     /* Don't pollute the disk with icons and other special entries */
!     if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
  	return 0;
!     return EBIT_TEST(e->flags, ENTRY_CACHABLE);
  }
--- 376,394 ----
  /*
   * Is this entry a candidate for writing to disk?
   */
! static int
  storeSwapOutAble(const StoreEntry * e)
  {
!     if (e->mem_obj->inmem_hi > Config.Store.maxObjectSize)
! 	return 0;
!     if (!EBIT_TEST(e->flags, ENTRY_CACHABLE))
! 	return 0;
      if (e->mem_obj->swapout.sio != NULL)
  	return 1;
!     if (e->mem_obj->swapout.queue_offset)
! 	if (e->mem_obj->swapout.queue_offset == e->mem_obj->inmem_hi)
  	    return 1;
!     if (e->mem_obj->inmem_lo > 0)
  	return 0;
!     return 1;
  }
Index: squid/src/structs.h
diff -c squid/src/structs.h:1.408.2.39 squid/src/structs.h:1.408.2.41
*** squid/src/structs.h:1.408.2.39	Fri Mar 18 17:01:52 2005
--- squid/src/structs.h	Sat Mar 26 10:36:01 2005
***************
*** 57,63 ****
  };
  
  struct _acl_user_ip_data {
!     size_t max;
      struct {
  	unsigned int strict:1;
      } flags;
--- 57,63 ----
  };
  
  struct _acl_user_ip_data {
!     int max;
      struct {
  	unsigned int strict:1;
      } flags;
***************
*** 122,131 ****
      dlink_list proxy_match_cache;
      /* what ip addresses has this user been seen at?, plus a list length cache */
      dlink_list ip_list;
!     size_t ipcount;
      long expiretime;
      /* how many references are outstanding to this instance */
!     size_t references;
      /* the auth scheme has it's own private data area */
      void *scheme_data;
      /* the auth_user_request structures that link to this. Yes it could be a splaytree
--- 122,131 ----
      dlink_list proxy_match_cache;
      /* what ip addresses has this user been seen at?, plus a list length cache */
      dlink_list ip_list;
!     int ipcount;
      long expiretime;
      /* how many references are outstanding to this instance */
!     int references;
      /* the auth scheme has it's own private data area */
      void *scheme_data;
      /* the auth_user_request structures that link to this. Yes it could be a splaytree
***************
*** 143,149 ****
      /* any scheme specific request related data */
      void *scheme_data;
      /* how many 'processes' are working on this data */
!     size_t references;
      /* We only attempt authentication once per http request. This 
       * is to allow multiple auth acl references from different _access areas
       * when using connection based authentication
--- 143,149 ----
      /* any scheme specific request related data */
      void *scheme_data;
      /* how many 'processes' are working on this data */
!     int references;
      /* We only attempt authentication once per http request. This 
       * is to allow multiple auth acl references from different _access areas
       * when using connection based authentication
***************
*** 228,234 ****
  struct _body_size {
      dlink_node node;
      acl_access *access_list;
!     size_t maxsize;
  };
  
  struct _http_version_t {
--- 228,234 ----
  struct _body_size {
      dlink_node node;
      acl_access *access_list;
!     squid_off_t maxsize;
  };
  
  struct _http_version_t {
***************
*** 385,404 ****
  
  struct _SquidConfig {
      struct {
! 	size_t maxSize;
  	int highWaterMark;
  	int lowWaterMark;
      } Swap;
!     size_t memMaxSize;
      struct {
  	char *relayHost;
  	u_short relayPort;
  	peer *peer;
      } Wais;
      struct {
! 	size_t min;
  	int pct;
! 	size_t max;
      } quickAbort;
      RemovalPolicySettings *replPolicy;
      RemovalPolicySettings *memPolicy;
--- 385,404 ----
  
  struct _SquidConfig {
      struct {
! 	squid_off_t maxSize;
  	int highWaterMark;
  	int lowWaterMark;
      } Swap;
!     squid_off_t memMaxSize;
      struct {
  	char *relayHost;
  	u_short relayPort;
  	peer *peer;
      } Wais;
      struct {
! 	squid_off_t min;
  	int pct;
! 	squid_off_t max;
      } quickAbort;
      RemovalPolicySettings *replPolicy;
      RemovalPolicySettings *memPolicy;
***************
*** 428,436 ****
  	time_t idns_query;
  #endif
      } Timeout;
!     size_t maxRequestHeaderSize;
!     size_t maxRequestBodySize;
!     size_t maxReplyHeaderSize;
      dlink_list ReplyBodySize;
      struct {
  	u_short icp;
--- 428,436 ----
  	time_t idns_query;
  #endif
      } Timeout;
!     squid_off_t maxRequestHeaderSize;
!     squid_off_t maxRequestBodySize;
!     squid_off_t maxReplyHeaderSize;
      dlink_list ReplyBodySize;
      struct {
  	u_short icp;
***************
*** 507,513 ****
  	u_short port;
      } Accel;
      char *appendDomain;
!     size_t appendDomainLen;
      char *debugOptions;
      char *pidFilename;
      char *mimeTablePathname;
--- 507,513 ----
  	u_short port;
      } Accel;
      char *appendDomain;
!     int appendDomainLen;
      char *debugOptions;
      char *pidFilename;
      char *mimeTablePathname;
***************
*** 531,538 ****
  #endif
  	struct in_addr client_netmask;
      } Addrs;
!     size_t tcpRcvBufsz;
!     size_t udpMaxHitObjsz;
      wordlist *hierarchy_stoplist;
      wordlist *mcast_group_list;
      wordlist *dns_testname_list;
--- 531,538 ----
  #endif
  	struct in_addr client_netmask;
      } Addrs;
!     squid_off_t tcpRcvBufsz;
!     squid_off_t udpMaxHitObjsz;
      wordlist *hierarchy_stoplist;
      wordlist *mcast_group_list;
      wordlist *dns_testname_list;
***************
*** 552,561 ****
      cachemgr_passwd *passwd_list;
      struct {
  	int objectsPerBucket;
! 	size_t avgObjectSize;
! 	size_t maxObjectSize;
! 	size_t minObjectSize;
! 	size_t maxInMemObjSize;
      } Store;
      struct {
  	int high;
--- 552,561 ----
      cachemgr_passwd *passwd_list;
      struct {
  	int objectsPerBucket;
! 	squid_off_t avgObjectSize;
! 	squid_off_t maxObjectSize;
! 	squid_off_t minObjectSize;
! 	squid_off_t maxInMemObjSize;
      } Store;
      struct {
  	int high;
***************
*** 637,643 ****
  	int n_configured;
      } authConfig;
      struct {
! 	size_t list_width;
  	int list_wrap;
  	char *anon_user;
  	int passive;
--- 637,643 ----
  	int n_configured;
      } authConfig;
      struct {
! 	int list_width;
  	int list_wrap;
  	char *anon_user;
  	int passive;
***************
*** 660,666 ****
  	int onerror;
      } retry;
      struct {
! 	size_t limit;
      } MemPools;
  #if DELAY_POOLS
      delayConfig Delay;
--- 660,666 ----
  	int onerror;
      } retry;
      struct {
! 	squid_off_t limit;
      } MemPools;
  #if DELAY_POOLS
      delayConfig Delay;
***************
*** 675,681 ****
      } comm_incoming;
      int max_open_disk_fds;
      int uri_whitespace;
!     size_t rangeOffsetLimit;
  #if MULTICAST_MISS_STREAM
      struct {
  	struct in_addr addr;
--- 675,681 ----
      } comm_incoming;
      int max_open_disk_fds;
      int uri_whitespace;
!     squid_off_t rangeOffsetLimit;
  #if MULTICAST_MISS_STREAM
      struct {
  	struct in_addr addr;
***************
*** 692,698 ****
  	int bits_per_entry;
  	time_t rebuild_period;
  	time_t rewrite_period;
! 	size_t swapout_chunk_size;
  	int rebuild_chunk_percentage;
      } digest;
  #endif
--- 692,698 ----
  	int bits_per_entry;
  	time_t rebuild_period;
  	time_t rewrite_period;
! 	squid_off_t swapout_chunk_size;
  	int rebuild_chunk_percentage;
      } digest;
  #endif
***************
*** 705,711 ****
      struct {
  	int high_rptm;
  	int high_pf;
! 	size_t high_memory;
      } warnings;
      char *store_dir_select_algorithm;
      int sleep_after_fork;	/* microseconds */
--- 705,711 ----
      struct {
  	int high_rptm;
  	int high_pf;
! 	squid_off_t high_memory;
      } warnings;
      char *store_dir_select_algorithm;
      int sleep_after_fork;	/* microseconds */
***************
*** 732,762 ****
  
  struct _dread_ctrl {
      int fd;
!     off_t offset;
!     int req_len;
      char *buf;
      int end_of_file;
      DRCB *handler;
      void *client_data;
  };
  
- struct _dnsserver_t {
-     int id;
-     int inpipe;
-     int outpipe;
-     time_t answer;
-     off_t offset;
-     size_t size;
-     char ip_inbuf[DNS_INBUF_SZ];
-     struct timeval dispatch_time;
-     void *data;
- };
- 
  struct _dwrite_q {
      off_t file_offset;
      char *buf;
!     int len;
!     off_t buf_offset;
      dwrite_q *next;
      FREE *free_func;
  };
--- 732,750 ----
  
  struct _dread_ctrl {
      int fd;
!     off_t file_offset;
!     size_t req_len;
      char *buf;
      int end_of_file;
      DRCB *handler;
      void *client_data;
  };
  
  struct _dwrite_q {
      off_t file_offset;
      char *buf;
!     size_t len;
!     size_t buf_offset;
      dwrite_q *next;
      FREE *free_func;
  };
***************
*** 793,800 ****
  	unsigned int close_on_exec:1;
  	unsigned int read_pending:1;
      } flags;
!     int bytes_read;
!     int bytes_written;
      int uses;			/* ie # req's over persistent conn */
      struct _fde_disk {
  	DWCB *wrt_handle;
--- 781,788 ----
  	unsigned int close_on_exec:1;
  	unsigned int read_pending:1;
      } flags;
!     squid_off_t bytes_read;
!     squid_off_t bytes_written;
      int uses;			/* ie # req's over persistent conn */
      struct _fde_disk {
  	DWCB *wrt_handle;
***************
*** 849,855 ****
      /* protected, use interface functions instead */
      append_f append;
      vprintf_f vprintf;
!     void *real_handler;		/* first parameter to real append and vprintf */
  };
  
  /* http status line */
--- 837,843 ----
      /* protected, use interface functions instead */
      append_f append;
      vprintf_f vprintf;
!     void *real_handle;		/* first parameter to real append and vprintf */
  };
  
  /* http status line */
***************
*** 885,892 ****
  
  /* http byte-range-spec */
  struct _HttpHdrRangeSpec {
!     ssize_t offset;
!     ssize_t length;
  };
  
  /* There may be more than one byte range specified in the request.
--- 873,880 ----
  
  /* http byte-range-spec */
  struct _HttpHdrRangeSpec {
!     squid_off_t offset;
!     squid_off_t length;
  };
  
  /* There may be more than one byte range specified in the request.
***************
*** 900,906 ****
  /* http content-range header field */
  struct _HttpHdrContRange {
      HttpHdrRangeSpec spec;
!     ssize_t elength;		/* entity length, not content length */
  };
  
  /* some fields can hold either time or etag specs (e.g. If-Range) */
--- 888,894 ----
  /* http content-range header field */
  struct _HttpHdrContRange {
      HttpHdrRangeSpec spec;
!     squid_off_t elength;	/* entity length, not content length */
  };
  
  /* some fields can hold either time or etag specs (e.g. If-Range) */
***************
*** 914,921 ****
  struct _HttpHdrRangeIter {
      HttpHdrRangePos pos;
      const HttpHdrRangeSpec *spec;	/* current spec at pos */
!     ssize_t debt_size;		/* bytes left to send from the current spec */
!     ssize_t prefix_size;	/* the size of the incoming HTTP msg prefix */
      String boundary;		/* boundary for multipart responses */
  };
  
--- 902,909 ----
  struct _HttpHdrRangeIter {
      HttpHdrRangePos pos;
      const HttpHdrRangeSpec *spec;	/* current spec at pos */
!     squid_off_t debt_size;	/* bytes left to send from the current spec */
!     squid_off_t prefix_size;	/* the size of the incoming HTTP msg prefix */
      String boundary;		/* boundary for multipart responses */
  };
  
***************
*** 962,968 ****
      int hdr_sz;			/* sums _stored_ status-line, headers, and <CRLF> */
  
      /* public, readable; never update these or their .hdr equivalents directly */
!     int content_length;
      time_t date;
      time_t last_modified;
      time_t expires;
--- 950,956 ----
      int hdr_sz;			/* sums _stored_ status-line, headers, and <CRLF> */
  
      /* public, readable; never update these or their .hdr equivalents directly */
!     squid_off_t content_length;
      time_t date;
      time_t last_modified;
      time_t expires;
***************
*** 1053,1059 ****
      } icp;
      struct {
  	struct in_addr caddr;
! 	size_t size;
  	log_type code;
  	int msec;
  	const char *rfc931;
--- 1041,1047 ----
      } icp;
      struct {
  	struct in_addr caddr;
! 	squid_off_t size;
  	log_type code;
  	int msec;
  	const char *rfc931;
***************
*** 1077,1084 ****
      char *uri;
      char *log_uri;
      struct {
! 	off_t offset;
! 	size_t size;
      } out;
      HttpHdrRangeIter range_iter;	/* data for iterating thru range specs */
      size_t req_sz;		/* raw request size on input, not current request size */
--- 1065,1072 ----
      char *uri;
      char *log_uri;
      struct {
! 	squid_off_t offset;
! 	squid_off_t size;
      } out;
      HttpHdrRangeIter range_iter;	/* data for iterating thru range specs */
      size_t req_sz;		/* raw request size on input, not current request size */
***************
*** 1106,1123 ****
  	char *location;
      } redirect;
      dlink_node active;
!     size_t maxBodySize;
  };
  
  struct _ConnStateData {
      int fd;
      struct {
  	char *buf;
! 	off_t offset;
  	size_t size;
      } in;
      struct {
! 	size_t size_left;	/* How much body left to process */
  	request_t *request;	/* Parameters passed to clientReadBody */
  	char *buf;
  	size_t bufsize;
--- 1094,1111 ----
  	char *location;
      } redirect;
      dlink_node active;
!     squid_off_t maxBodySize;
  };
  
  struct _ConnStateData {
      int fd;
      struct {
  	char *buf;
! 	size_t offset;
  	size_t size;
      } in;
      struct {
! 	squid_off_t size_left;	/* How much body left to process */
  	request_t *request;	/* Parameters passed to clientReadBody */
  	char *buf;
  	size_t bufsize;
***************
*** 1187,1194 ****
      store_client *sc;
      store_client *old_sc;
      request_t *request;
!     int offset;
!     int mask_offset;
      time_t start_time;
      time_t resp_time;
      time_t expires;
--- 1175,1182 ----
      store_client *sc;
      store_client *old_sc;
      request_t *request;
!     squid_off_t offset;
!     squid_off_t mask_offset;
      time_t start_time;
      time_t resp_time;
      time_t expires;
***************
*** 1438,1451 ****
  struct _mem_hdr {
      mem_node *head;
      mem_node *tail;
!     int origin_offset;
  };
  
  /* keep track each client receiving data from that particular StoreEntry */
  struct _store_client {
      int type;
!     off_t copy_offset;
!     off_t seen_offset;
      size_t copy_size;
      char *copy_buf;
      STCB *callback;
--- 1426,1439 ----
  struct _mem_hdr {
      mem_node *head;
      mem_node *tail;
!     squid_off_t origin_offset;
  };
  
  /* keep track each client receiving data from that particular StoreEntry */
  struct _store_client {
      int type;
!     squid_off_t copy_offset;
!     squid_off_t seen_offset;
      size_t copy_size;
      char *copy_buf;
      STCB *callback;
***************
*** 1503,1514 ****
      method_t method;
      char *url;
      mem_hdr data_hdr;
!     off_t inmem_hi;
!     off_t inmem_lo;
      dlink_list clients;
      int nclients;
      struct {
! 	off_t queue_offset;	/* relative to in-mem data */
  	mem_node *memnode;	/* which node we're currently paging out */
  	storeIOState *sio;
      } swapout;
--- 1491,1502 ----
      method_t method;
      char *url;
      mem_hdr data_hdr;
!     squid_off_t inmem_hi;
!     squid_off_t inmem_lo;
      dlink_list clients;
      int nclients;
      struct {
! 	squid_off_t queue_offset;	/* relative to in-mem data */
  	mem_node *memnode;	/* which node we're currently paging out */
  	storeIOState *sio;
      } swapout;
***************
*** 1524,1530 ****
      char *log_url;
      RemovalPolicyNode repl;
      int id;
!     ssize_t object_sz;
      size_t swap_hdr_sz;
  #if URL_CHECKSUM_DEBUG
      unsigned int chksum;
--- 1512,1518 ----
      char *log_url;
      RemovalPolicyNode repl;
      int id;
!     squid_off_t object_sz;
      size_t swap_hdr_sz;
  #if URL_CHECKSUM_DEBUG
      unsigned int chksum;
***************
*** 1541,1547 ****
      time_t lastref;
      time_t expires;
      time_t lastmod;
!     size_t swap_file_sz;
      u_short refcount;
      u_short flags;
      /* END OF ON-DISK STORE_META_STD */
--- 1529,1535 ----
      time_t lastref;
      time_t expires;
      time_t lastmod;
!     squid_file_sz swap_file_sz;
      u_short refcount;
      u_short flags;
      /* END OF ON-DISK STORE_META_STD */
***************
*** 1561,1567 ****
      int max_size;
      char *path;
      int index;			/* This entry's index into the swapDirs array */
!     ssize_t max_objsize;
      RemovalPolicy *repl;
      int removals;
      int scanned;
--- 1549,1555 ----
      int max_size;
      char *path;
      int index;			/* This entry's index into the swapDirs array */
!     squid_off_t max_objsize;
      RemovalPolicy *repl;
      int removals;
      int scanned;
***************
*** 1641,1648 ****
      sfileno swap_filen;
      StoreEntry *e;		/* Need this so the FS layers can play god */
      mode_t mode;
!     size_t st_size;		/* do stat(2) after read open */
!     off_t offset;		/* current on-disk offset pointer */
      STFNCB *file_callback;	/* called on delayed sfileno assignments */
      STIOCB *callback;
      void *callback_data;
--- 1629,1636 ----
      sfileno swap_filen;
      StoreEntry *e;		/* Need this so the FS layers can play god */
      mode_t mode;
!     squid_off_t st_size;	/* do stat(2) after read open */
!     squid_off_t offset;		/* current on-disk offset pointer */
      STFNCB *file_callback;	/* called on delayed sfileno assignments */
      STIOCB *callback;
      void *callback_data;
***************
*** 1678,1684 ****
      struct in_addr my_addr;
      unsigned short my_port;
      HttpHeader header;
!     int content_length;
      HierarchyLogEntry hier;
      err_type err_type;
      char *peer_login;		/* Configured peer login:password */
--- 1666,1672 ----
      struct in_addr my_addr;
      unsigned short my_port;
      HttpHeader header;
!     squid_off_t content_length;
      HierarchyLogEntry hier;
      err_type err_type;
      char *peer_login;		/* Configured peer login:password */
***************
*** 1715,1721 ****
  struct _CommWriteStateData {
      char *buf;
      size_t size;
!     off_t offset;
      CWCB *handler;
      void *handler_data;
      FREE *free_func;
--- 1703,1709 ----
  struct _CommWriteStateData {
      char *buf;
      size_t size;
!     size_t offset;
      CWCB *handler;
      void *handler_data;
      FREE *free_func;
***************
*** 1912,1923 ****
--- 1900,1934 ----
      time_t lastref;
      time_t expires;
      time_t lastmod;
+     squid_file_sz swap_file_sz;
+     u_short refcount;
+     u_short flags;
+     unsigned char key[MD5_DIGEST_CHARS];
+ };
+ 
+ struct _storeSwapLogHeader {
+     char op;
+     int version;
+     int record_size;
+ };
+ 
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ struct _storeSwapLogDataOld {
+     char op;
+     sfileno swap_filen;
+     time_t timestamp;
+     time_t lastref;
+     time_t expires;
+     time_t lastmod;
      size_t swap_file_sz;
      u_short refcount;
      u_short flags;
      unsigned char key[MD5_DIGEST_CHARS];
  };
  
+ #endif
+ 
+ 
  /* object to track per-action memory usage (e.g. #idle objects) */
  struct _MemMeter {
      ssize_t level;		/* current level (count or volume) */
***************
*** 1964,1970 ****
  struct _CacheDigest {
      /* public, read-only */
      char *mask;			/* bit mask */
!     size_t mask_size;		/* mask size in bytes */
      int capacity;		/* expected maximum for .count, not a hard limit */
      int bits_per_entry;		/* number of bits allocated for each entry from capacity */
      int count;			/* number of digested entries */
--- 1975,1981 ----
  struct _CacheDigest {
      /* public, read-only */
      char *mask;			/* bit mask */
!     int mask_size;		/* mask size in bytes */
      int capacity;		/* expected maximum for .count, not a hard limit */
      int bits_per_entry;		/* number of bits allocated for each entry from capacity */
      int count;			/* number of digested entries */
***************
*** 2076,2082 ****
      int wfd;
      char *buf;
      size_t buf_sz;
!     off_t offset;
      struct timeval dispatch_time;
      struct timeval answer_time;
      dlink_node link;
--- 2087,2093 ----
      int wfd;
      char *buf;
      size_t buf_sz;
!     int offset;
      struct timeval dispatch_time;
      struct timeval answer_time;
      dlink_node link;
***************
*** 2100,2106 ****
      int wfd;
      char *buf;
      size_t buf_sz;
!     off_t offset;
      struct timeval dispatch_time;
      struct timeval answer_time;
      dlink_node link;
--- 2111,2117 ----
      int wfd;
      char *buf;
      size_t buf_sz;
!     int offset;
      struct timeval dispatch_time;
      struct timeval answer_time;
      dlink_node link;
***************
*** 2185,2191 ****
      char path[MAXPATHLEN];
      char *buf;
      size_t bufsz;
!     off_t offset;
      struct {
  	unsigned int fatal:1;
      } flags;
--- 2196,2202 ----
      char path[MAXPATHLEN];
      char *buf;
      size_t bufsz;
!     ssize_t offset;
      struct {
  	unsigned int fatal:1;
      } flags;
Index: squid/src/tools.c
diff -c squid/src/tools.c:1.213.2.12 squid/src/tools.c:1.213.2.13
*** squid/src/tools.c:1.213.2.12	Fri Mar  4 09:22:16 2005
--- squid/src/tools.c	Fri Mar 25 19:50:54 2005
***************
*** 841,847 ****
  }
  
  void
! kb_incr(kb_t * k, size_t v)
  {
      k->bytes += v;
      k->kb += (k->bytes >> 10);
--- 841,847 ----
  }
  
  void
! kb_incr(kb_t * k, squid_off_t v)
  {
      k->bytes += v;
      k->kb += (k->bytes >> 10);
Index: squid/src/typedefs.h
diff -c squid/src/typedefs.h:1.132.2.6 squid/src/typedefs.h:1.132.2.8
*** squid/src/typedefs.h:1.132.2.6	Tue Oct  5 16:34:42 2004
--- squid/src/typedefs.h	Sat Mar 26 17:20:13 2005
***************
*** 41,49 ****
  typedef signed int sfileno;
  typedef signed int sdirno;
  
  typedef struct {
!     size_t bytes;
!     size_t kb;
  } kb_t;
  
  typedef struct {
--- 41,69 ----
  typedef signed int sfileno;
  typedef signed int sdirno;
  
+ #if SIZEOF_INT64_T > SIZEOF_LONG && defined(PRId64) && defined(INT64_MAX) && HAVE_STRTOLL
+ typedef int64_t squid_off_t;
+ #define SIZEOF_SQUID_OFF_T SIZEOF_INT64_T
+ #define PRINTF_OFF_T PRId64
+ #define strto_off_t (int64_t)strtoll
+ #else
+ typedef long squid_off_t;
+ #define SIZEOF_SQUID_OFF_T SIZEOF_LONG
+ #define PRINTF_OFF_T "ld"
+ #define strto_off_t strtol
+ #endif
+ 
+ #if LARGE_CACHE_FILES
+ typedef squid_off_t squid_file_sz;
+ #define SIZEOF_SQUID_FILE_SZ SIZEOF_SQUID_OFF_T
+ #else
+ typedef size_t squid_file_sz;
+ #define SIZEOF_SQUID_FILE_SZ SIZEOF_SIZE_T
+ #endif
+ 
  typedef struct {
!     squid_off_t bytes;
!     squid_off_t kb;
  } kb_t;
  
  typedef struct {
***************
*** 90,96 ****
  typedef struct _SquidConfig2 SquidConfig2;
  typedef struct _close_handler close_handler;
  typedef struct _dread_ctrl dread_ctrl;
- typedef struct _dnsserver_t dnsserver_t;
  typedef struct _dwrite_q dwrite_q;
  typedef struct _ETag ETag;
  typedef struct _fde fde;
--- 110,115 ----
***************
*** 160,165 ****
--- 179,186 ----
  typedef struct _StatCounters StatCounters;
  typedef struct _tlv tlv;
  typedef struct _storeSwapLogData storeSwapLogData;
+ typedef struct _storeSwapLogDataOld storeSwapLogDataOld;
+ typedef struct _storeSwapLogHeader storeSwapLogHeader;
  typedef struct _authConfig authConfig;
  typedef struct _cacheSwap cacheSwap;
  typedef struct _StatHist StatHist;
***************
*** 275,282 ****
  typedef storeIOState *STOBJCREATE(SwapDir *, StoreEntry *, STFNCB *, STIOCB *, void *);
  typedef storeIOState *STOBJOPEN(SwapDir *, StoreEntry *, STFNCB *, STIOCB *, void *);
  typedef void STOBJCLOSE(SwapDir *, storeIOState *);
! typedef void STOBJREAD(SwapDir *, storeIOState *, char *, size_t, off_t, STRCB *, void *);
! typedef void STOBJWRITE(SwapDir *, storeIOState *, char *, size_t, off_t, FREE *);
  typedef void STOBJUNLINK(SwapDir *, StoreEntry *);
  
  typedef void STLOGOPEN(SwapDir *);
--- 296,303 ----
  typedef storeIOState *STOBJCREATE(SwapDir *, StoreEntry *, STFNCB *, STIOCB *, void *);
  typedef storeIOState *STOBJOPEN(SwapDir *, StoreEntry *, STFNCB *, STIOCB *, void *);
  typedef void STOBJCLOSE(SwapDir *, storeIOState *);
! typedef void STOBJREAD(SwapDir *, storeIOState *, char *, size_t, squid_off_t, STRCB *, void *);
! typedef void STOBJWRITE(SwapDir *, storeIOState *, char *, size_t, squid_off_t, FREE *);
  typedef void STOBJUNLINK(SwapDir *, StoreEntry *);
  
  typedef void STLOGOPEN(SwapDir *);
***************
*** 322,328 ****
  typedef const char *AUTHSCONNLASTHEADER(auth_user_request_t *);
  
  /* append/vprintf's for Packer */
! typedef void (*append_f) (void *, const char *buf, int size);
  #if STDC_HEADERS
  typedef void (*vprintf_f) (void *, const char *fmt, va_list args);
  #else
--- 343,349 ----
  typedef const char *AUTHSCONNLASTHEADER(auth_user_request_t *);
  
  /* append/vprintf's for Packer */
! typedef void (*append_f) (void *, const char *buf, size_t size);
  #if STDC_HEADERS
  typedef void (*vprintf_f) (void *, const char *fmt, va_list args);
  #else
***************
*** 336,348 ****
  typedef int Ctx;
  
  /* in case we want to change it later */
! typedef ssize_t mb_size_t;
  
  /* iteration for HttpHdrRange */
  typedef int HttpHdrRangePos;
  
  /*iteration for headers; use HttpHeaderPos as opaque type, do not interpret */
! typedef ssize_t HttpHeaderPos;
  
  /* big mask for http headers */
  typedef char HttpHeaderMask[8];
--- 357,369 ----
  typedef int Ctx;
  
  /* in case we want to change it later */
! typedef int mb_size_t;
  
  /* iteration for HttpHdrRange */
  typedef int HttpHdrRangePos;
  
  /*iteration for headers; use HttpHeaderPos as opaque type, do not interpret */
! typedef int HttpHeaderPos;
  
  /* big mask for http headers */
  typedef char HttpHeaderMask[8];
Index: squid/src/fs/aufs/async_io.c
diff -c squid/src/fs/aufs/async_io.c:1.10.2.6 squid/src/fs/aufs/async_io.c:1.10.2.7
*** squid/src/fs/aufs/async_io.c:1.10.2.6	Sat Mar 19 16:02:29 2005
--- squid/src/fs/aufs/async_io.c	Fri Mar 25 19:50:54 2005
***************
*** 186,192 ****
  
  
  void
! aioWrite(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callback_data, FREE * free_func)
  {
      squidaio_ctrl_t *ctrlp;
      int seekmode;
--- 186,192 ----
  
  
  void
! aioWrite(int fd, off_t offset, char *bufp, int len, AIOCB * callback, void *callback_data, FREE * free_func)
  {
      squidaio_ctrl_t *ctrlp;
      int seekmode;
***************
*** 214,220 ****
  
  
  void
! aioRead(int fd, int offset, int len, AIOCB * callback, void *callback_data)
  {
      squidaio_ctrl_t *ctrlp;
      int seekmode;
--- 214,220 ----
  
  
  void
! aioRead(int fd, off_t offset, int len, AIOCB * callback, void *callback_data)
  {
      squidaio_ctrl_t *ctrlp;
      int seekmode;
Index: squid/src/fs/aufs/store_asyncufs.h
diff -c squid/src/fs/aufs/store_asyncufs.h:1.9.2.4 squid/src/fs/aufs/store_asyncufs.h:1.9.2.5
*** squid/src/fs/aufs/store_asyncufs.h:1.9.2.4	Sat Mar 19 16:02:29 2005
--- squid/src/fs/aufs/store_asyncufs.h	Fri Mar 25 19:50:54 2005
***************
*** 64,71 ****
  void aioCancel(int);
  void aioOpen(const char *, int, mode_t, AIOCB *, void *);
  void aioClose(int);
! void aioWrite(int, int offset, char *, int size, AIOCB *, void *, FREE *);
! void aioRead(int, int offset, int size, AIOCB *, void *);
  void aioStat(char *, struct stat *, AIOCB *, void *);
  void aioUnlink(const char *, AIOCB *, void *);
  void aioTruncate(const char *, off_t length, AIOCB *, void *);
--- 64,71 ----
  void aioCancel(int);
  void aioOpen(const char *, int, mode_t, AIOCB *, void *);
  void aioClose(int);
! void aioWrite(int, off_t offset, char *, int size, AIOCB *, void *, FREE *);
! void aioRead(int, off_t offset, int size, AIOCB *, void *);
  void aioStat(char *, struct stat *, AIOCB *, void *);
  void aioUnlink(const char *, AIOCB *, void *);
  void aioTruncate(const char *, off_t length, AIOCB *, void *);
Index: squid/src/fs/aufs/store_dir_aufs.c
diff -c squid/src/fs/aufs/store_dir_aufs.c:1.40.2.11 squid/src/fs/aufs/store_dir_aufs.c:1.40.2.13
*** squid/src/fs/aufs/store_dir_aufs.c:1.40.2.11	Sat Mar 19 16:43:10 2005
--- squid/src/fs/aufs/store_dir_aufs.c	Sat Mar 26 15:29:25 2005
***************
*** 82,88 ****
  static int storeAufsDirGetNextFile(RebuildState *, sfileno *, int *size);
  static StoreEntry *storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      sfileno file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 82,88 ----
  static int storeAufsDirGetNextFile(RebuildState *, sfileno *, int *size);
  static StoreEntry *storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      sfileno file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 366,371 ****
--- 366,389 ----
  }
  
  static void
+ storeAufsDirRebuildComplete(RebuildState * rb)
+ {
+     if (rb->log) {
+ 	debug(47, 1) ("Done reading %s swaplog (%d entries)\n",
+ 	    rb->sd->path, rb->n_read);
+ 	fclose(rb->log);
+ 	rb->log = NULL;
+     } else {
+ 	debug(47, 1) ("Done scanning %s (%d entries)\n",
+ 	    rb->sd->path, rb->counts.scancount);
+     }
+     store_dirs_rebuilding--;
+     storeAufsDirCloseTmpSwapLog(rb->sd);
+     storeRebuildComplete(&rb->counts);
+     cbdataFree(rb);
+ }
+ 
+ static void
  storeAufsDirRebuildFromDirectory(void *data)
  {
      RebuildState *rb = data;
***************
*** 388,399 ****
  	assert(fd == -1);
  	fd = storeAufsDirGetNextFile(rb, &filn, &size);
  	if (fd == -2) {
! 	    debug(47, 1) ("Done scanning %s swaplog (%d entries)\n",
! 		rb->sd->path, rb->n_read);
! 	    store_dirs_rebuilding--;
! 	    storeAufsDirCloseTmpSwapLog(rb->sd);
! 	    storeRebuildComplete(&rb->counts);
! 	    cbdataFree(rb);
  	    return;
  	} else if (fd < 0) {
  	    continue;
--- 406,412 ----
  	assert(fd == -1);
  	fd = storeAufsDirGetNextFile(rb, &filn, &size);
  	if (fd == -2) {
! 	    storeAufsDirRebuildComplete(rb);
  	    return;
  	} else if (fd < 0) {
  	    continue;
***************
*** 445,454 ****
--- 458,496 ----
  		assert(t->length == MD5_DIGEST_CHARS);
  		xmemcpy(key, t->value, MD5_DIGEST_CHARS);
  		break;
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
  	    case STORE_META_STD:
  		assert(t->length == STORE_HDR_METASIZE);
  		xmemcpy(&tmpe.timestamp, t->value, STORE_HDR_METASIZE);
  		break;
+ #else
+ 	    case STORE_META_STD_LFS:
+ 		assert(t->length == STORE_HDR_METASIZE);
+ 		xmemcpy(&tmpe.timestamp, t->value, STORE_HDR_METASIZE);
+ 		break;
+ 	    case STORE_META_STD:
+ 		assert(t->length == STORE_HDR_METASIZE_OLD);
+ 		{
+ 		    struct {
+ 			time_t timestamp;
+ 			time_t lastref;
+ 			time_t expires;
+ 			time_t lastmod;
+ 			size_t swap_file_sz;
+ 			u_short refcount;
+ 			u_short flags;
+ 		    }     *tmp = t->value;
+ 		    assert(sizeof(*tmp) == STORE_HDR_METASIZE_OLD);
+ 		    tmpe.timestamp = tmp->timestamp;
+ 		    tmpe.lastref = tmp->lastref;
+ 		    tmpe.expires = tmp->expires;
+ 		    tmpe.lastmod = tmp->lastmod;
+ 		    tmpe.swap_file_sz = tmp->swap_file_sz;
+ 		    tmpe.refcount = tmp->refcount;
+ 		    tmpe.flags = tmp->flags;
+ 		}
+ 		break;
+ #endif
  	    default:
  		break;
  	    }
***************
*** 522,542 ****
      /* load a number of objects per invocation */
      for (count = 0; count < rb->speed; count++) {
  	if (fread(&s, ss, 1, rb->log) != 1) {
! 	    debug(47, 1) ("Done reading %s swaplog (%d entries)\n",
! 		rb->sd->path, rb->n_read);
! 	    fclose(rb->log);
! 	    rb->log = NULL;
! 	    store_dirs_rebuilding--;
! 	    storeAufsDirCloseTmpSwapLog(rb->sd);
! 	    storeRebuildComplete(&rb->counts);
! 	    cbdataFree(rb);
  	    return;
  	}
  	rb->n_read++;
! 	if (s.op <= SWAP_LOG_NOP)
  	    continue;
! 	if (s.op >= SWAP_LOG_MAX)
  	    continue;
  	/*
  	 * BC: during 2.4 development, we changed the way swap file
  	 * numbers are assigned and stored.  The high 16 bits used
--- 564,741 ----
      /* load a number of objects per invocation */
      for (count = 0; count < rb->speed; count++) {
  	if (fread(&s, ss, 1, rb->log) != 1) {
! 	    storeAufsDirRebuildComplete(rb);
  	    return;
  	}
  	rb->n_read++;
! 	/*
! 	 * BC: during 2.4 development, we changed the way swap file
! 	 * numbers are assigned and stored.  The high 16 bits used
! 	 * to encode the SD index number.  There used to be a call
! 	 * to storeDirProperFileno here that re-assigned the index 
! 	 * bits.  Now, for backwards compatibility, we just need
! 	 * to mask it off.
! 	 */
! 	s.swap_filen &= 0x00FFFFFF;
! 	debug(47, 3) ("storeAufsDirRebuildFromSwapLog: %s %s %08X\n",
! 	    swap_log_op_str[(int) s.op],
! 	    storeKeyText(s.key),
! 	    s.swap_filen);
! 	if (s.op == SWAP_LOG_ADD) {
! 	    (void) 0;
! 	} else if (s.op == SWAP_LOG_DEL) {
! 	    /* Delete unless we already have a newer copy */
! 	    if ((e = storeGet(s.key)) != NULL && s.lastref > e->lastref) {
! 		/*
! 		 * Make sure we don't unlink the file, it might be
! 		 * in use by a subsequent entry.  Also note that
! 		 * we don't have to subtract from store_swap_size
! 		 * because adding to store_swap_size happens in
! 		 * the cleanup procedure.
! 		 */
! 		storeExpireNow(e);
! 		storeReleaseRequest(e);
! 		if (e->swap_filen > -1) {
! 		    storeAufsDirReplRemove(e);
! 		    storeAufsDirMapBitReset(SD, e->swap_filen);
! 		    e->swap_filen = -1;
! 		    e->swap_dirn = -1;
! 		}
! 		storeRelease(e);
! 		rb->counts.objcount--;
! 		rb->counts.cancelcount++;
! 	    }
  	    continue;
! 	} else {
! 	    x = log(++rb->counts.bad_log_op) / log(10.0);
! 	    if (0.0 == x - (double) (int) x)
! 		debug(47, 1) ("WARNING: %d invalid swap log entries found\n",
! 		    rb->counts.bad_log_op);
! 	    rb->counts.invalid++;
! 	    continue;
! 	}
! 	if ((++rb->counts.scancount & 0xFFF) == 0) {
! 	    struct stat sb;
! 	    if (0 == fstat(fileno(rb->log), &sb))
! 		storeRebuildProgress(SD->index,
! 		    (int) sb.st_size / ss, rb->n_read);
! 	}
! 	if (!storeAufsDirValidFileno(SD, s.swap_filen, 0)) {
! 	    rb->counts.invalid++;
! 	    continue;
! 	}
! 	if (EBIT_TEST(s.flags, KEY_PRIVATE)) {
! 	    rb->counts.badflags++;
! 	    continue;
! 	}
! 	e = storeGet(s.key);
! 	used = storeAufsDirMapBitTest(SD, s.swap_filen);
! 	/* If this URL already exists in the cache, does the swap log
! 	 * appear to have a newer entry?  Compare 'lastref' from the
! 	 * swap log to e->lastref. */
! 	disk_entry_newer = e ? (s.lastref > e->lastref ? 1 : 0) : 0;
! 	if (used && !disk_entry_newer) {
! 	    /* log entry is old, ignore it */
! 	    rb->counts.clashcount++;
  	    continue;
+ 	} else if (used && e && e->swap_filen == s.swap_filen && e->swap_dirn == SD->index) {
+ 	    /* swapfile taken, same URL, newer, update meta */
+ 	    if (e->store_status == STORE_OK) {
+ 		e->lastref = s.timestamp;
+ 		e->timestamp = s.timestamp;
+ 		e->expires = s.expires;
+ 		e->lastmod = s.lastmod;
+ 		e->flags = s.flags;
+ 		e->refcount += s.refcount;
+ 		storeAufsDirUnrefObj(SD, e);
+ 	    } else {
+ 		debug_trap("storeAufsDirRebuildFromSwapLog: bad condition");
+ 		debug(47, 1) ("\tSee %s:%d\n", __FILE__, __LINE__);
+ 	    }
+ 	    continue;
+ 	} else if (used) {
+ 	    /* swapfile in use, not by this URL, log entry is newer */
+ 	    /* This is sorta bad: the log entry should NOT be newer at this
+ 	     * point.  If the log is dirty, the filesize check should have
+ 	     * caught this.  If the log is clean, there should never be a
+ 	     * newer entry. */
+ 	    debug(47, 1) ("WARNING: newer swaplog entry for dirno %d, fileno %08X\n",
+ 		SD->index, s.swap_filen);
+ 	    /* I'm tempted to remove the swapfile here just to be safe,
+ 	     * but there is a bad race condition in the NOVM version if
+ 	     * the swapfile has recently been opened for writing, but
+ 	     * not yet opened for reading.  Because we can't map
+ 	     * swapfiles back to StoreEntrys, we don't know the state
+ 	     * of the entry using that file.  */
+ 	    /* We'll assume the existing entry is valid, probably because
+ 	     * were in a slow rebuild and the the swap file number got taken
+ 	     * and the validation procedure hasn't run. */
+ 	    assert(rb->flags.need_to_validate);
+ 	    rb->counts.clashcount++;
+ 	    continue;
+ 	} else if (e && !disk_entry_newer) {
+ 	    /* key already exists, current entry is newer */
+ 	    /* keep old, ignore new */
+ 	    rb->counts.dupcount++;
+ 	    continue;
+ 	} else if (e) {
+ 	    /* key already exists, this swapfile not being used */
+ 	    /* junk old, load new */
+ 	    storeExpireNow(e);
+ 	    storeReleaseRequest(e);
+ 	    if (e->swap_filen > -1) {
+ 		storeAufsDirReplRemove(e);
+ 		/* Make sure we don't actually unlink the file */
+ 		storeAufsDirMapBitReset(SD, e->swap_filen);
+ 		e->swap_filen = -1;
+ 		e->swap_dirn = -1;
+ 	    }
+ 	    storeRelease(e);
+ 	    rb->counts.dupcount++;
+ 	} else {
+ 	    /* URL doesnt exist, swapfile not in use */
+ 	    /* load new */
+ 	    (void) 0;
+ 	}
+ 	/* update store_swap_size */
+ 	rb->counts.objcount++;
+ 	e = storeAufsDirAddDiskRestore(SD, s.key,
+ 	    s.swap_filen,
+ 	    s.swap_file_sz,
+ 	    s.expires,
+ 	    s.timestamp,
+ 	    s.lastref,
+ 	    s.lastmod,
+ 	    s.refcount,
+ 	    s.flags,
+ 	    (int) rb->flags.clean);
+ 	storeDirSwapLog(e, SWAP_LOG_ADD);
+     }
+     eventAdd("storeRebuild", storeAufsDirRebuildFromSwapLog, rb, 0.0, 1);
+ }
+ 
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ /* This is an exact copy of the above, but using storeSwapLogDataOld entry type */
+ static void
+ storeAufsDirRebuildFromSwapLogOld(void *data)
+ {
+     RebuildState *rb = data;
+     SwapDir *SD = rb->sd;
+     StoreEntry *e = NULL;
+     storeSwapLogDataOld s;
+     size_t ss = sizeof(storeSwapLogDataOld);
+     int count;
+     int used;			/* is swapfile already in use? */
+     int disk_entry_newer;	/* is the log entry newer than current entry? */
+     double x;
+     assert(rb != NULL);
+     /* load a number of objects per invocation */
+     for (count = 0; count < rb->speed; count++) {
+ 	if (fread(&s, ss, 1, rb->log) != 1) {
+ 	    storeAufsDirRebuildComplete(rb);
+ 	    return;
+ 	}
+ 	rb->n_read++;
  	/*
  	 * BC: during 2.4 development, we changed the way swap file
  	 * numbers are assigned and stored.  The high 16 bits used
***************
*** 680,686 ****
--- 879,927 ----
  	    (int) rb->flags.clean);
  	storeDirSwapLog(e, SWAP_LOG_ADD);
      }
+     eventAdd("storeRebuild", storeAufsDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ }
+ 
+ #endif
+ 
+ static void
+ storeAufsDirRebuildFromSwapLogCheckVersion(void *data)
+ {
+     RebuildState *rb = data;
+     storeSwapLogHeader hdr;
+ 
+     if (fread(&hdr, sizeof(hdr), 1, rb->log) != 1) {
+ 	storeAufsDirRebuildComplete(rb);
+ 	return;
+     }
+     if (hdr.op == SWAP_LOG_VERSION) {
+ 	if (fseek(rb->log, hdr.record_size, SEEK_SET) != 0) {
+ 	    storeAufsDirRebuildComplete(rb);
+ 	    return;
+ 	}
+ 	if (hdr.version == 1 && hdr.record_size == sizeof(storeSwapLogData)) {
+ 	    eventAdd("storeRebuild", storeAufsDirRebuildFromSwapLog, rb, 0.0, 1);
+ 	    return;
+ 	}
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ 	if (hdr.version == 1 && hdr.record_size == sizeof(storeSwapLogDataOld)) {
+ 	    debug(47, 1) ("storeAufsDirRebuildFromSwapLog: Found current version but without large file support. Upgrading\n");
+ 	    eventAdd("storeRebuild", storeAufsDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ 	    return;
+ 	}
+ #endif
+ 	debug(47, 1) ("storeAufsDirRebuildFromSwapLog: Unsupported swap.state version %d size %d\n",
+ 	    hdr.version, hdr.record_size);
+ 	storeAufsDirRebuildComplete(rb);
+ 	return;
+     }
+     rewind(rb->log);
+     debug(47, 1) ("storeAufsDirRebuildFromSwapLog: Old version detected. Upgrading\n");
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
      eventAdd("storeRebuild", storeAufsDirRebuildFromSwapLog, rb, 0.0, 1);
+ #else
+     eventAdd("storeRebuild", storeAufsDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ #endif
  }
  
  static int
***************
*** 775,781 ****
  static StoreEntry *
  storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      sfileno file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 1016,1022 ----
  static StoreEntry *
  storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      sfileno file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 839,845 ****
  	    fclose(fp);
  	func = storeAufsDirRebuildFromDirectory;
      } else {
! 	func = storeAufsDirRebuildFromSwapLog;
  	rb->log = fp;
  	rb->flags.clean = (unsigned int) clean;
      }
--- 1080,1086 ----
  	    fclose(fp);
  	func = storeAufsDirRebuildFromDirectory;
      } else {
! 	func = storeAufsDirRebuildFromSwapLogCheckVersion;
  	rb->log = fp;
  	rb->flags.clean = (unsigned int) clean;
      }
***************
*** 879,884 ****
--- 1120,1150 ----
      debug(47, 3) ("Cache Dir #%d log opened on FD %d\n", sd->index, fd);
  }
  
+ static void
+ storeSwapLogDataFree(void *s)
+ {
+     memFree(s, MEM_SWAP_LOG_DATA);
+ }
+ 
+ static void
+ storeAufsWriteSwapLogheader(int fd)
+ {
+     storeSwapLogHeader *hdr = memAllocate(MEM_SWAP_LOG_DATA);
+     hdr->op = SWAP_LOG_VERSION;
+     hdr->version = 1;
+     hdr->record_size = sizeof(storeSwapLogData);
+     /* The header size is a full log record to keep some level of backward
+      * compatibility even if the actual header is smaller
+      */
+     file_write(fd,
+ 	-1,
+ 	hdr,
+ 	sizeof(storeSwapLogData),
+ 	NULL,
+ 	NULL,
+ 	(FREE *) storeSwapLogDataFree);
+ }
+ 
  static FILE *
  storeAufsDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
  {
***************
*** 908,913 ****
--- 1174,1180 ----
  	fatal("storeDirOpenTmpSwapLog: Failed to open swap log.");
      }
      aioinfo->swaplog_fd = fd;
+     storeAufsWriteSwapLogheader(fd);
      /* open a read-only stream of the old log */
      fp = fopen(swaplog_path, "r");
      if (fp == NULL) {
***************
*** 936,942 ****
      char *new;
      char *cln;
      char *outbuf;
!     off_t outbuf_offset;
      int fd;
      RemovalPolicyWalker *walker;
  };
--- 1203,1209 ----
      char *new;
      char *cln;
      char *outbuf;
!     int outbuf_offset;
      int fd;
      RemovalPolicyWalker *walker;
  };
***************
*** 967,972 ****
--- 1234,1240 ----
  	xfree(state);
  	return -1;
      }
+     storeAufsWriteSwapLogheader(state->fd);
      state->cur = xstrdup(storeAufsDirSwapLogFile(sd, NULL));
      state->cln = xstrdup(storeAufsDirSwapLogFile(sd, ".last-clean"));
      state->outbuf = xcalloc(CLEAN_BUF_SZ, 1);
***************
*** 1095,1106 ****
  }
  
  static void
- storeSwapLogDataFree(void *s)
- {
-     memFree(s, MEM_SWAP_LOG_DATA);
- }
- 
- static void
  storeAufsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
  {
      squidaioinfo_t *aioinfo = (squidaioinfo_t *) sd->fsdata;
--- 1363,1368 ----
Index: squid/src/fs/aufs/store_io_aufs.c
diff -c squid/src/fs/aufs/store_io_aufs.c:1.15.2.13 squid/src/fs/aufs/store_io_aufs.c:1.15.2.14
*** squid/src/fs/aufs/store_io_aufs.c:1.15.2.13	Fri Mar 18 17:01:52 2005
--- squid/src/fs/aufs/store_io_aufs.c	Fri Mar 25 19:50:54 2005
***************
*** 153,159 ****
  
  /* Read */
  void
! storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
  {
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
      assert(sio->read.callback == NULL);
--- 153,159 ----
  
  /* Read */
  void
! storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, STRCB * callback, void *callback_data)
  {
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
      assert(sio->read.callback == NULL);
***************
*** 167,173 ****
  	q = memPoolAlloc(aufs_qread_pool);
  	q->buf = buf;
  	q->size = size;
! 	q->offset = offset;
  	q->callback = callback;
  	q->callback_data = callback_data;
  	cbdataLock(q->callback_data);
--- 167,173 ----
  	q = memPoolAlloc(aufs_qread_pool);
  	q->buf = buf;
  	q->size = size;
! 	q->offset = (off_t) offset;
  	q->callback = callback;
  	q->callback_data = callback_data;
  	cbdataLock(q->callback_data);
***************
*** 183,192 ****
      sio->offset = offset;
      aiostate->flags.reading = 1;
  #if ASYNC_READ
!     aioRead(aiostate->fd, offset, size, storeAufsReadDone, sio);
      statCounter.syscalls.disk.reads++;
  #else
!     file_read(aiostate->fd, buf, size, offset, storeAufsReadDone, sio);
      /* file_read() increments syscalls.disk.reads */
  #endif
  }
--- 183,192 ----
      sio->offset = offset;
      aiostate->flags.reading = 1;
  #if ASYNC_READ
!     aioRead(aiostate->fd, (off_t) offset, size, storeAufsReadDone, sio);
      statCounter.syscalls.disk.reads++;
  #else
!     file_read(aiostate->fd, buf, size, (off_t) offset, storeAufsReadDone, sio);
      /* file_read() increments syscalls.disk.reads */
  #endif
  }
***************
*** 194,200 ****
  
  /* Write */
  void
! storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
  {
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
      debug(79, 3) ("storeAufsWrite: dirno %d, fileno %08X, FD %d\n",
--- 194,200 ----
  
  /* Write */
  void
! storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, FREE * free_func)
  {
      squidaiostate_t *aiostate = (squidaiostate_t *) sio->fsstate;
      debug(79, 3) ("storeAufsWrite: dirno %d, fileno %08X, FD %d\n",
***************
*** 206,212 ****
  	q = memPoolAlloc(aufs_qwrite_pool);
  	q->buf = buf;
  	q->size = size;
! 	q->offset = offset;
  	q->free_func = free_func;
  	linklistPush(&(aiostate->pending_writes), q);
  	return;
--- 206,212 ----
  	q = memPoolAlloc(aufs_qwrite_pool);
  	q->buf = buf;
  	q->size = size;
! 	q->offset = (off_t) offset;
  	q->free_func = free_func;
  	linklistPush(&(aiostate->pending_writes), q);
  	return;
***************
*** 218,234 ****
  	q = memPoolAlloc(aufs_qwrite_pool);
  	q->buf = buf;
  	q->size = size;
! 	q->offset = offset;
  	q->free_func = free_func;
  	linklistPush(&(aiostate->pending_writes), q);
  	return;
      }
      aiostate->flags.writing = 1;
!     aioWrite(aiostate->fd, offset, buf, size, storeAufsWriteDone, sio,
  	free_func);
      statCounter.syscalls.disk.writes++;
  #else
!     file_write(aiostate->fd, offset, buf, size, storeAufsWriteDone, sio,
  	free_func);
      /* file_write() increments syscalls.disk.writes */
  #endif
--- 218,234 ----
  	q = memPoolAlloc(aufs_qwrite_pool);
  	q->buf = buf;
  	q->size = size;
! 	q->offset = (off_t) offset;
  	q->free_func = free_func;
  	linklistPush(&(aiostate->pending_writes), q);
  	return;
      }
      aiostate->flags.writing = 1;
!     aioWrite(aiostate->fd, (off_t) offset, buf, size, storeAufsWriteDone, sio,
  	free_func);
      statCounter.syscalls.disk.writes++;
  #else
!     file_write(aiostate->fd, (off_t) offset, buf, size, storeAufsWriteDone, sio,
  	free_func);
      /* file_write() increments syscalls.disk.writes */
  #endif
***************
*** 330,336 ****
  	debug(79, 3) ("storeAufsReadDone: got failure (%d)\n", errflag);
  	rlen = -1;
      } else {
! 	rlen = (ssize_t) len;
  	sio->offset += len;
      }
  #if ASYNC_READ
--- 330,336 ----
  	debug(79, 3) ("storeAufsReadDone: got failure (%d)\n", errflag);
  	rlen = -1;
      } else {
! 	rlen = len;
  	sio->offset += len;
      }
  #if ASYNC_READ
Index: squid/src/fs/coss/store_dir_coss.c
diff -c squid/src/fs/coss/store_dir_coss.c:1.30.2.9 squid/src/fs/coss/store_dir_coss.c:1.30.2.10
*** squid/src/fs/coss/store_dir_coss.c:1.30.2.9	Mon Aug  4 06:41:51 2003
--- squid/src/fs/coss/store_dir_coss.c	Fri Mar 25 19:50:55 2005
***************
*** 63,69 ****
  static EVH storeCossRebuildFromSwapLog;
  static StoreEntry *storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 63,69 ----
  static EVH storeCossRebuildFromSwapLog;
  static StoreEntry *storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 318,324 ****
  static StoreEntry *
  storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 318,324 ----
  static StoreEntry *
  storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 485,491 ****
      char *new;
      char *cln;
      char *outbuf;
!     off_t outbuf_offset;
      int fd;
      dlink_node *current;
  };
--- 485,491 ----
      char *new;
      char *cln;
      char *outbuf;
!     int outbuf_offset;
      int fd;
      dlink_node *current;
  };
Index: squid/src/fs/coss/store_io_coss.c
diff -c squid/src/fs/coss/store_io_coss.c:1.13.2.8 squid/src/fs/coss/store_io_coss.c:1.13.2.11
*** squid/src/fs/coss/store_io_coss.c:1.13.2.8	Tue Jul 29 16:19:43 2003
--- squid/src/fs/coss/store_io_coss.c	Sat Mar 26 16:40:21 2005
***************
*** 296,302 ****
  }
  
  void
! storeCossRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
  {
      char *p;
      CossState *cstate = (CossState *) sio->fsstate;
--- 296,302 ----
  }
  
  void
! storeCossRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, STRCB * callback, void *callback_data)
  {
      char *p;
      CossState *cstate = (CossState *) sio->fsstate;
***************
*** 337,343 ****
  }
  
  void
! storeCossWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
  {
      char *dest;
      CossMemBuf *membuf;
--- 337,343 ----
  }
  
  void
! storeCossWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, FREE * free_func)
  {
      char *dest;
      CossMemBuf *membuf;
***************
*** 373,379 ****
      void *their_data = sio->read.callback_data;
      SwapDir *SD = INDEXSD(sio->swap_dirn);
      CossState *cstate = (CossState *) sio->fsstate;
!     size_t rlen;
  
      debug(79, 3) ("storeCossReadDone: fileno %d, FD %d, len %d\n",
  	sio->swap_filen, fd, len);
--- 373,379 ----
      void *their_data = sio->read.callback_data;
      SwapDir *SD = INDEXSD(sio->swap_dirn);
      CossState *cstate = (CossState *) sio->fsstate;
!     ssize_t rlen;
  
      debug(79, 3) ("storeCossReadDone: fileno %d, FD %d, len %d\n",
  	sio->swap_filen, fd, len);
***************
*** 547,553 ****
      if (errflag) {
  	coss_stats.stripe_write.fail++;
  	debug(79, 1) ("storeCossWriteMemBufDone: got failure (%d)\n", errflag);
! 	debug(79, 1) ("FD %d, size=%x\n", fd, t->diskend - t->diskstart);
      } else {
  	coss_stats.stripe_write.success++;
      }
--- 547,553 ----
      if (errflag) {
  	coss_stats.stripe_write.fail++;
  	debug(79, 1) ("storeCossWriteMemBufDone: got failure (%d)\n", errflag);
! 	debug(79, 1) ("FD %d, size=%x\n", fd, (int) (t->diskend - t->diskstart));
      } else {
  	coss_stats.stripe_write.success++;
      }
Index: squid/src/fs/diskd/diskd.c
diff -c squid/src/fs/diskd/diskd.c:1.10 squid/src/fs/diskd/diskd.c:1.10.2.2
*** squid/src/fs/diskd/diskd.c:1.10	Wed Feb  7 11:56:54 2001
--- squid/src/fs/diskd/diskd.c	Sat Mar 26 16:29:56 2005
***************
*** 135,152 ****
      }
      if (r->offset > -1 && r->offset != fs->offset) {
  	DEBUG(2)
! 	    fprintf(stderr, "seeking to %d\n", r->offset);
  	if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
  	    DEBUG(1) {
! 		fprintf(stderr, "%d FD %d, offset %d: ", (int) mypid, fs->fd, r->offset);
  		perror("lseek");
  	    }
  	}
      }
      x = read(fs->fd, buf, readlen);
      DEBUG(2)
! 	fprintf(stderr, "%d READ %d,%d,%d ret %d\n", (int) mypid,
! 	fs->fd, readlen, r->offset, x);
      if (x < 0) {
  	DEBUG(1) {
  	    fprintf(stderr, "%d FD %d: ", (int) mypid, fs->fd);
--- 135,152 ----
      }
      if (r->offset > -1 && r->offset != fs->offset) {
  	DEBUG(2)
! 	    fprintf(stderr, "seeking to %" PRINTF_OFF_T "\n", (squid_off_t) r->offset);
  	if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
  	    DEBUG(1) {
! 		fprintf(stderr, "%d FD %d, offset %" PRINTF_OFF_T ": ", (int) mypid, fs->fd, (squid_off_t) r->offset);
  		perror("lseek");
  	    }
  	}
      }
      x = read(fs->fd, buf, readlen);
      DEBUG(2)
! 	fprintf(stderr, "%d READ %d,%d,%" PRINTF_OFF_T " ret %d\n", (int) mypid,
! 	fs->fd, readlen, (squid_off_t) r->offset, x);
      if (x < 0) {
  	DEBUG(1) {
  	    fprintf(stderr, "%d FD %d: ", (int) mypid, fs->fd);
***************
*** 176,189 ****
      if (r->offset > -1 && r->offset != fs->offset) {
  	if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
  	    DEBUG(1) {
! 		fprintf(stderr, "%d FD %d, offset %d: ", (int) mypid, fs->fd, r->offset);
  		perror("lseek");
  	    }
  	}
      }
      DEBUG(2)
! 	fprintf(stderr, "%d WRITE %d,%d,%d\n", (int) mypid,
! 	fs->fd, wrtlen, r->offset);
      x = write(fs->fd, buf, wrtlen);
      if (x < 0) {
  	DEBUG(1) {
--- 176,189 ----
      if (r->offset > -1 && r->offset != fs->offset) {
  	if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
  	    DEBUG(1) {
! 		fprintf(stderr, "%d FD %d, offset %" PRINTF_OFF_T ": ", (int) mypid, fs->fd, (squid_off_t) r->offset);
  		perror("lseek");
  	    }
  	}
      }
      DEBUG(2)
! 	fprintf(stderr, "%d WRITE %d,%d,%" PRINTF_OFF_T "\n", (int) mypid,
! 	fs->fd, wrtlen, (squid_off_t) r->offset);
      x = write(fs->fd, buf, wrtlen);
      if (x < 0) {
  	DEBUG(1) {
Index: squid/src/fs/diskd/store_dir_diskd.c
diff -c squid/src/fs/diskd/store_dir_diskd.c:1.58.2.8 squid/src/fs/diskd/store_dir_diskd.c:1.58.2.10
*** squid/src/fs/diskd/store_dir_diskd.c:1.58.2.8	Wed Jul 23 15:00:34 2003
--- squid/src/fs/diskd/store_dir_diskd.c	Sat Mar 26 15:29:25 2005
***************
*** 86,92 ****
  static int storeDiskdDirGetNextFile(RebuildState *, sfileno *, int *size);
  static StoreEntry *storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      sfileno file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 86,92 ----
  static int storeDiskdDirGetNextFile(RebuildState *, sfileno *, int *size);
  static StoreEntry *storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      sfileno file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 528,534 ****
  	storeDiskdHandle(&M);
  	retval = 1;		/* Return that we've actually done some work */
  	if (M.shm_offset > -1)
! 	    storeDiskdShmPut(SD, (off_t) M.shm_offset);
      }
      return retval;
  }
--- 528,534 ----
  	storeDiskdHandle(&M);
  	retval = 1;		/* Return that we've actually done some work */
  	if (M.shm_offset > -1)
! 	    storeDiskdShmPut(SD, M.shm_offset);
      }
      return retval;
  }
***************
*** 536,541 ****
--- 536,559 ----
  
  
  static void
+ storeDiskdDirRebuildComplete(RebuildState * rb)
+ {
+     if (rb->log) {
+ 	debug(47, 1) ("Done reading %s swaplog (%d entries)\n",
+ 	    rb->sd->path, rb->n_read);
+ 	fclose(rb->log);
+ 	rb->log = NULL;
+     } else {
+ 	debug(47, 1) ("Done scanning %s (%d entries)\n",
+ 	    rb->sd->path, rb->counts.scancount);
+     }
+     store_dirs_rebuilding--;
+     storeDiskdDirCloseTmpSwapLog(rb->sd);
+     storeRebuildComplete(&rb->counts);
+     cbdataFree(rb);
+ }
+ 
+ static void
  storeDiskdDirRebuildFromDirectory(void *data)
  {
      RebuildState *rb = data;
***************
*** 558,569 ****
  	assert(fd == -1);
  	fd = storeDiskdDirGetNextFile(rb, &filn, &size);
  	if (fd == -2) {
! 	    debug(20, 1) ("Done scanning %s swaplog (%d entries)\n",
! 		rb->sd->path, rb->n_read);
! 	    store_dirs_rebuilding--;
! 	    storeDiskdDirCloseTmpSwapLog(rb->sd);
! 	    storeRebuildComplete(&rb->counts);
! 	    cbdataFree(rb);
  	    return;
  	} else if (fd < 0) {
  	    continue;
--- 576,582 ----
  	assert(fd == -1);
  	fd = storeDiskdDirGetNextFile(rb, &filn, &size);
  	if (fd == -2) {
! 	    storeDiskdDirRebuildComplete(rb);
  	    return;
  	} else if (fd < 0) {
  	    continue;
***************
*** 615,624 ****
--- 628,666 ----
  		assert(t->length == MD5_DIGEST_CHARS);
  		xmemcpy(key, t->value, MD5_DIGEST_CHARS);
  		break;
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
  	    case STORE_META_STD:
  		assert(t->length == STORE_HDR_METASIZE);
  		xmemcpy(&tmpe.timestamp, t->value, STORE_HDR_METASIZE);
  		break;
+ #else
+ 	    case STORE_META_STD_LFS:
+ 		assert(t->length == STORE_HDR_METASIZE);
+ 		xmemcpy(&tmpe.timestamp, t->value, STORE_HDR_METASIZE);
+ 		break;
+ 	    case STORE_META_STD:
+ 		assert(t->length == STORE_HDR_METASIZE_OLD);
+ 		{
+ 		    struct {
+ 			time_t timestamp;
+ 			time_t lastref;
+ 			time_t expires;
+ 			time_t lastmod;
+ 			size_t swap_file_sz;
+ 			u_short refcount;
+ 			u_short flags;
+ 		    }     *tmp = t->value;
+ 		    assert(sizeof(*tmp) == STORE_HDR_METASIZE_OLD);
+ 		    tmpe.timestamp = tmp->timestamp;
+ 		    tmpe.lastref = tmp->lastref;
+ 		    tmpe.expires = tmp->expires;
+ 		    tmpe.lastmod = tmp->lastmod;
+ 		    tmpe.swap_file_sz = tmp->swap_file_sz;
+ 		    tmpe.refcount = tmp->refcount;
+ 		    tmpe.flags = tmp->flags;
+ 		}
+ 		break;
+ #endif
  	    default:
  		break;
  	    }
***************
*** 692,712 ****
      /* load a number of objects per invocation */
      for (count = 0; count < rb->speed; count++) {
  	if (fread(&s, ss, 1, rb->log) != 1) {
! 	    debug(20, 1) ("Done reading %s swaplog (%d entries)\n",
! 		rb->sd->path, rb->n_read);
! 	    fclose(rb->log);
! 	    rb->log = NULL;
! 	    store_dirs_rebuilding--;
! 	    storeDiskdDirCloseTmpSwapLog(rb->sd);
! 	    storeRebuildComplete(&rb->counts);
! 	    cbdataFree(rb);
  	    return;
  	}
  	rb->n_read++;
! 	if (s.op <= SWAP_LOG_NOP)
  	    continue;
! 	if (s.op >= SWAP_LOG_MAX)
  	    continue;
  	/*
  	 * BC: during 2.4 development, we changed the way swap file
  	 * numbers are assigned and stored.  The high 16 bits used
--- 734,936 ----
      /* load a number of objects per invocation */
      for (count = 0; count < rb->speed; count++) {
  	if (fread(&s, ss, 1, rb->log) != 1) {
! 	    storeDiskdDirRebuildComplete(rb);
  	    return;
  	}
  	rb->n_read++;
! 	/*
! 	 * BC: during 2.4 development, we changed the way swap file
! 	 * numbers are assigned and stored.  The high 16 bits used
! 	 * to encode the SD index number.  There used to be a call
! 	 * to storeDirProperFileno here that re-assigned the index
! 	 * bits.  Now, for backwards compatibility, we just need
! 	 * to mask it off.
! 	 */
! 	s.swap_filen &= 0x00FFFFFF;
! 	debug(20, 3) ("storeDiskdDirRebuildFromSwapLog: %s %s %08X\n",
! 	    swap_log_op_str[(int) s.op],
! 	    storeKeyText(s.key),
! 	    s.swap_filen);
! 	if (s.op == SWAP_LOG_ADD) {
! 	    /*
! 	     * Here we have some special checks for large files.
! 	     * I've been seeing a system crash followed by a reboot
! 	     * that seems to corrupt the swap log.  Squid believes
! 	     * that the disk holds some really large files.  It
! 	     * complains about using being over the high water mark
! 	     * and proceeds to delete files as fast as it can.  To
! 	     * prevent that, we call stat() on sufficiently large
! 	     * files (>128KB) and reject those that are missing or
! 	     * have the wrong size.
! 	     */
! 	    struct stat sb;
! 	    char *p = storeDiskdDirFullPath(SD, s.swap_filen, NULL);
! 	    if (s.swap_file_sz < (1 << 17)) {
! 		(void) 0;
! 	    } else if (stat(p, &sb) < 0) {
! 		debug(47, 2) ("its missing!: %s\n", p);
! 		continue;
! 	    } else if (sb.st_size != s.swap_file_sz) {
! 		debug(47, 2) ("size mismatch!: stat=%d, log=%d\n",
! 		    (int) sb.st_size, (int) s.swap_file_sz);
! 		continue;
! 	    } else {
! 		debug(47, 2) ("big file (%d bytes) checks out\n",
! 		    (int) s.swap_file_sz);
! 	    }
! 	} else if (s.op == SWAP_LOG_DEL) {
! 	    /* Delete unless we already have a newer copy */
! 	    if ((e = storeGet(s.key)) != NULL && s.lastref > e->lastref) {
! 		/*
! 		 * Make sure we don't unlink the file, it might be
! 		 * in use by a subsequent entry.  Also note that
! 		 * we don't have to subtract from store_swap_size
! 		 * because adding to store_swap_size happens in
! 		 * the cleanup procedure.
! 		 */
! 		storeExpireNow(e);
! 		storeReleaseRequest(e);
! 		if (e->swap_filen > -1) {
! 		    storeDiskdDirReplRemove(e);
! 		    storeDiskdDirMapBitReset(SD, e->swap_filen);
! 		    e->swap_filen = -1;
! 		    e->swap_dirn = -1;
! 		}
! 		storeRelease(e);
! 		rb->counts.objcount--;
! 		rb->counts.cancelcount++;
! 	    }
! 	    continue;
! 	} else {
! 	    x = log(++rb->counts.bad_log_op) / log(10.0);
! 	    if (0.0 == x - (double) (int) x)
! 		debug(20, 1) ("WARNING: %d invalid swap log entries found\n",
! 		    rb->counts.bad_log_op);
! 	    rb->counts.invalid++;
! 	    continue;
! 	}
! 	if ((++rb->counts.scancount & 0xFFF) == 0) {
! 	    struct stat sb;
! 	    if (0 == fstat(fileno(rb->log), &sb))
! 		storeRebuildProgress(SD->index,
! 		    (int) sb.st_size / ss, rb->n_read);
! 	}
! 	if (!storeDiskdDirValidFileno(SD, s.swap_filen, 0)) {
! 	    rb->counts.invalid++;
! 	    continue;
! 	}
! 	if (EBIT_TEST(s.flags, KEY_PRIVATE)) {
! 	    rb->counts.badflags++;
! 	    continue;
! 	}
! 	e = storeGet(s.key);
! 	used = storeDiskdDirMapBitTest(SD, s.swap_filen);
! 	/* If this URL already exists in the cache, does the swap log
! 	 * appear to have a newer entry?  Compare 'lastref' from the
! 	 * swap log to e->lastref. */
! 	disk_entry_newer = e ? (s.lastref > e->lastref ? 1 : 0) : 0;
! 	if (used && !disk_entry_newer) {
! 	    /* log entry is old, ignore it */
! 	    rb->counts.clashcount++;
! 	    continue;
! 	} else if (used && e && e->swap_filen == s.swap_filen && e->swap_dirn == SD->index) {
! 	    /* swapfile taken, same URL, newer, update meta */
! 	    if (e->store_status == STORE_OK) {
! 		e->lastref = s.timestamp;
! 		e->timestamp = s.timestamp;
! 		e->expires = s.expires;
! 		e->lastmod = s.lastmod;
! 		e->flags = s.flags;
! 		e->refcount += s.refcount;
! 		storeDiskdDirUnrefObj(SD, e);
! 	    } else {
! 		debug_trap("storeDiskdDirRebuildFromSwapLog: bad condition");
! 		debug(20, 1) ("\tSee %s:%d\n", __FILE__, __LINE__);
! 	    }
  	    continue;
! 	} else if (used) {
! 	    /* swapfile in use, not by this URL, log entry is newer */
! 	    /* This is sorta bad: the log entry should NOT be newer at this
! 	     * point.  If the log is dirty, the filesize check should have
! 	     * caught this.  If the log is clean, there should never be a
! 	     * newer entry. */
! 	    debug(20, 1) ("WARNING: newer swaplog entry for dirno %d, fileno %08X\n",
! 		SD->index, s.swap_filen);
! 	    /* I'm tempted to remove the swapfile here just to be safe,
! 	     * but there is a bad race condition in the NOVM version if
! 	     * the swapfile has recently been opened for writing, but
! 	     * not yet opened for reading.  Because we can't map
! 	     * swapfiles back to StoreEntrys, we don't know the state
! 	     * of the entry using that file.  */
! 	    /* We'll assume the existing entry is valid, probably because
! 	     * were in a slow rebuild and the the swap file number got taken
! 	     * and the validation procedure hasn't run. */
! 	    assert(rb->flags.need_to_validate);
! 	    rb->counts.clashcount++;
  	    continue;
+ 	} else if (e && !disk_entry_newer) {
+ 	    /* key already exists, current entry is newer */
+ 	    /* keep old, ignore new */
+ 	    rb->counts.dupcount++;
+ 	    continue;
+ 	} else if (e) {
+ 	    /* key already exists, this swapfile not being used */
+ 	    /* junk old, load new */
+ 	    storeExpireNow(e);
+ 	    storeReleaseRequest(e);
+ 	    if (e->swap_filen > -1) {
+ 		storeDiskdDirReplRemove(e);
+ 		/* Make sure we don't actually unlink the file */
+ 		storeDiskdDirMapBitReset(SD, e->swap_filen);
+ 		e->swap_filen = -1;
+ 		e->swap_dirn = -1;
+ 	    }
+ 	    storeRelease(e);
+ 	    rb->counts.dupcount++;
+ 	} else {
+ 	    /* URL doesnt exist, swapfile not in use */
+ 	    /* load new */
+ 	    (void) 0;
+ 	}
+ 	/* update store_swap_size */
+ 	rb->counts.objcount++;
+ 	e = storeDiskdDirAddDiskRestore(SD, s.key,
+ 	    s.swap_filen,
+ 	    s.swap_file_sz,
+ 	    s.expires,
+ 	    s.timestamp,
+ 	    s.lastref,
+ 	    s.lastmod,
+ 	    s.refcount,
+ 	    s.flags,
+ 	    (int) rb->flags.clean);
+ 	storeDirSwapLog(e, SWAP_LOG_ADD);
+     }
+     eventAdd("storeRebuild", storeDiskdDirRebuildFromSwapLog, rb, 0.0, 1);
+ }
+ 
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ /* This is an exact copy of the above, but using storeSwapLogDataOld entry type */
+ static void
+ storeDiskdDirRebuildFromSwapLogOld(void *data)
+ {
+     RebuildState *rb = data;
+     SwapDir *SD = rb->sd;
+     StoreEntry *e = NULL;
+     storeSwapLogDataOld s;
+     size_t ss = sizeof(storeSwapLogDataOld);
+     int count;
+     int used;			/* is swapfile already in use? */
+     int disk_entry_newer;	/* is the log entry newer than current entry? */
+     double x;
+     assert(rb != NULL);
+     /* load a number of objects per invocation */
+     for (count = 0; count < rb->speed; count++) {
+ 	if (fread(&s, ss, 1, rb->log) != 1) {
+ 	    storeDiskdDirRebuildComplete(rb);
+ 	    return;
+ 	}
+ 	rb->n_read++;
  	/*
  	 * BC: during 2.4 development, we changed the way swap file
  	 * numbers are assigned and stored.  The high 16 bits used
***************
*** 875,881 ****
--- 1099,1147 ----
  	    (int) rb->flags.clean);
  	storeDirSwapLog(e, SWAP_LOG_ADD);
      }
+     eventAdd("storeRebuild", storeDiskdDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ }
+ 
+ #endif
+ 
+ static void
+ storeDiskdDirRebuildFromSwapLogCheckVersion(void *data)
+ {
+     RebuildState *rb = data;
+     storeSwapLogHeader hdr;
+ 
+     if (fread(&hdr, sizeof(hdr), 1, rb->log) != 1) {
+ 	storeDiskdDirRebuildComplete(rb);
+ 	return;
+     }
+     if (hdr.op == SWAP_LOG_VERSION) {
+ 	if (fseek(rb->log, hdr.record_size, SEEK_SET) != 0) {
+ 	    storeDiskdDirRebuildComplete(rb);
+ 	    return;
+ 	}
+ 	if (hdr.version == 1 && hdr.record_size == sizeof(storeSwapLogData)) {
+ 	    eventAdd("storeRebuild", storeDiskdDirRebuildFromSwapLog, rb, 0.0, 1);
+ 	    return;
+ 	}
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ 	if (hdr.version == 1 && hdr.record_size == sizeof(storeSwapLogDataOld)) {
+ 	    debug(47, 1) ("storeDiskdDirRebuildFromSwapLog: Found current version but without large file support. Upgrading\n");
+ 	    eventAdd("storeRebuild", storeDiskdDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ 	    return;
+ 	}
+ #endif
+ 	debug(47, 1) ("storeDiskdDirRebuildFromSwapLog: Unsupported swap.state version %d size %d\n",
+ 	    hdr.version, hdr.record_size);
+ 	storeDiskdDirRebuildComplete(rb);
+ 	return;
+     }
+     rewind(rb->log);
+     debug(47, 1) ("storeDiskdDirRebuildFromSwapLog: Old version detected. Upgrading\n");
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
      eventAdd("storeRebuild", storeDiskdDirRebuildFromSwapLog, rb, 0.0, 1);
+ #else
+     eventAdd("storeRebuild", storeDiskdDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ #endif
  }
  
  static int
***************
*** 970,976 ****
  static StoreEntry *
  storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 1236,1242 ----
  static StoreEntry *
  storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 1034,1040 ****
  	    fclose(fp);
  	func = storeDiskdDirRebuildFromDirectory;
      } else {
! 	func = storeDiskdDirRebuildFromSwapLog;
  	rb->log = fp;
  	rb->flags.clean = (unsigned int) clean;
      }
--- 1300,1306 ----
  	    fclose(fp);
  	func = storeDiskdDirRebuildFromDirectory;
      } else {
! 	func = storeDiskdDirRebuildFromSwapLogCheckVersion;
  	rb->log = fp;
  	rb->flags.clean = (unsigned int) clean;
      }
***************
*** 1074,1079 ****
--- 1340,1370 ----
      debug(47, 3) ("Cache Dir #%d log opened on FD %d\n", sd->index, fd);
  }
  
+ static void
+ storeSwapLogDataFree(void *s)
+ {
+     memFree(s, MEM_SWAP_LOG_DATA);
+ }
+ 
+ static void
+ storeDiskdWriteSwapLogheader(int fd)
+ {
+     storeSwapLogHeader *hdr = memAllocate(MEM_SWAP_LOG_DATA);
+     hdr->op = SWAP_LOG_VERSION;
+     hdr->version = 1;
+     hdr->record_size = sizeof(storeSwapLogData);
+     /* The header size is a full log record to keep some level of backward
+      * compatibility even if the actual header is smaller
+      */
+     file_write(fd,
+ 	-1,
+ 	hdr,
+ 	sizeof(storeSwapLogData),
+ 	NULL,
+ 	NULL,
+ 	(FREE *) storeSwapLogDataFree);
+ }
+ 
  static FILE *
  storeDiskdDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
  {
***************
*** 1103,1108 ****
--- 1394,1400 ----
  	fatal("storeDirOpenTmpSwapLog: Failed to open swap log.");
      }
      diskdinfo->swaplog_fd = fd;
+     storeDiskdWriteSwapLogheader(fd);
      /* open a read-only stream of the old log */
      fp = fopen(swaplog_path, "r");
      if (fp == NULL) {
***************
*** 1128,1134 ****
      char *new;
      char *cln;
      char *outbuf;
!     off_t outbuf_offset;
      int fd;
      RemovalPolicyWalker *walker;
  };
--- 1420,1426 ----
      char *new;
      char *cln;
      char *outbuf;
!     int outbuf_offset;
      int fd;
      RemovalPolicyWalker *walker;
  };
***************
*** 1165,1170 ****
--- 1457,1463 ----
      }
      debug(20, 3) ("storeDirWriteCleanLogs: opened %s, FD %d\n",
  	state->new, state->fd);
+     storeDiskdWriteSwapLogheader(state->fd);
  #if HAVE_FCHMOD
      if (stat(state->cur, &sb) == 0)
  	fchmod(state->fd, sb.st_mode);
***************
*** 1282,1293 ****
  }
  
  static void
- storeSwapLogDataFree(void *s)
- {
-     memFree(s, MEM_SWAP_LOG_DATA);
- }
- 
- static void
  storeDiskdDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
  {
      diskdinfo_t *diskdinfo = sd->fsdata;
--- 1575,1580 ----
***************
*** 1636,1642 ****
   */
  
  void *
! storeDiskdShmGet(SwapDir * sd, off_t * shm_offset)
  {
      char *buf = NULL;
      diskdinfo_t *diskdinfo = sd->fsdata;
--- 1923,1929 ----
   */
  
  void *
! storeDiskdShmGet(SwapDir * sd, int *shm_offset)
  {
      char *buf = NULL;
      diskdinfo_t *diskdinfo = sd->fsdata;
***************
*** 1659,1665 ****
  }
  
  void
! storeDiskdShmPut(SwapDir * sd, off_t offset)
  {
      int i;
      diskdinfo_t *diskdinfo = sd->fsdata;
--- 1946,1952 ----
  }
  
  void
! storeDiskdShmPut(SwapDir * sd, int offset)
  {
      int i;
      diskdinfo_t *diskdinfo = sd->fsdata;
Index: squid/src/fs/diskd/store_diskd.h
diff -c squid/src/fs/diskd/store_diskd.h:1.8 squid/src/fs/diskd/store_diskd.h:1.8.2.2
*** squid/src/fs/diskd/store_diskd.h:1.8	Tue Jul 10 09:35:45 2001
--- squid/src/fs/diskd/store_diskd.h	Sat Mar 26 16:29:56 2005
***************
*** 59,65 ****
      int seq_no;
      void *callback_data;
      int size;
!     int offset;
      int status;
      int shm_offset;
  } diomsg;
--- 59,65 ----
      int seq_no;
      void *callback_data;
      int size;
!     off_t offset;
      int status;
      int shm_offset;
  } diomsg;
***************
*** 95,102 ****
  extern void storeDiskdDirUnlinkFile(SwapDir *, sfileno);
  extern void storeDiskdDirReplAdd(SwapDir *, StoreEntry *);
  extern void storeDiskdDirReplRemove(StoreEntry *);
! extern void storeDiskdShmPut(SwapDir *, off_t);
! extern void *storeDiskdShmGet(SwapDir *, off_t *);
  extern void storeDiskdHandle(diomsg * M);
  extern int storeDiskdDirCallback(SwapDir *);
  
--- 95,102 ----
  extern void storeDiskdDirUnlinkFile(SwapDir *, sfileno);
  extern void storeDiskdDirReplAdd(SwapDir *, StoreEntry *);
  extern void storeDiskdDirReplRemove(StoreEntry *);
! extern void storeDiskdShmPut(SwapDir *, int);
! extern void *storeDiskdShmGet(SwapDir *, int *);
  extern void storeDiskdHandle(diomsg * M);
  extern int storeDiskdDirCallback(SwapDir *);
  
Index: squid/src/fs/diskd/store_io_diskd.c
diff -c squid/src/fs/diskd/store_io_diskd.c:1.22.2.3 squid/src/fs/diskd/store_io_diskd.c:1.22.2.4
*** squid/src/fs/diskd/store_io_diskd.c:1.22.2.3	Thu Aug  8 14:17:41 2002
--- squid/src/fs/diskd/store_io_diskd.c	Fri Mar 25 19:50:55 2005
***************
*** 42,48 ****
  
  #include "store_diskd.h"
  
! static int storeDiskdSend(int, SwapDir *, int, storeIOState *, int, int, off_t);
  static void storeDiskdIOCallback(storeIOState * sio, int errflag);
  static CBDUNL storeDiskdIOFreeEntry;
  
--- 42,48 ----
  
  #include "store_diskd.h"
  
! static int storeDiskdSend(int, SwapDir *, int, storeIOState *, int, off_t, int);
  static void storeDiskdIOCallback(storeIOState * sio, int errflag);
  static CBDUNL storeDiskdIOFreeEntry;
  
***************
*** 59,65 ****
      storeIOState *sio;
      char *buf;
      diskdstate_t *diskdstate;
!     off_t shm_offset;
      diskdinfo_t *diskdinfo = SD->fsdata;
      debug(79, 3) ("storeDiskdOpen: fileno %08X\n", f);
      /*
--- 59,65 ----
      storeIOState *sio;
      char *buf;
      diskdstate_t *diskdstate;
!     int shm_offset;
      diskdinfo_t *diskdinfo = SD->fsdata;
      debug(79, 3) ("storeDiskdOpen: fileno %08X\n", f);
      /*
***************
*** 115,121 ****
      int x;
      storeIOState *sio;
      char *buf;
!     off_t shm_offset;
      diskdinfo_t *diskdinfo = SD->fsdata;
      diskdstate_t *diskdstate;
      /*
--- 115,121 ----
      int x;
      storeIOState *sio;
      char *buf;
!     int shm_offset;
      diskdinfo_t *diskdinfo = SD->fsdata;
      diskdstate_t *diskdstate;
      /*
***************
*** 191,200 ****
  }
  
  void
! storeDiskdRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
  {
      int x;
!     off_t shm_offset;
      char *rbuf;
      diskdstate_t *diskdstate = sio->fsstate;
      debug(79, 3) ("storeDiskdRead: dirno %d, fileno %08X\n", sio->swap_dirn, sio->swap_filen);
--- 191,200 ----
  }
  
  void
! storeDiskdRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, STRCB * callback, void *callback_data)
  {
      int x;
!     int shm_offset;
      char *rbuf;
      diskdstate_t *diskdstate = sio->fsstate;
      debug(79, 3) ("storeDiskdRead: dirno %d, fileno %08X\n", sio->swap_dirn, sio->swap_filen);
***************
*** 219,226 ****
  	SD,
  	diskdstate->id,
  	sio,
! 	(int) size,
! 	(int) offset,
  	shm_offset);
      if (x < 0) {
  	debug(79, 1) ("storeDiskdSend READ: %s\n", xstrerror());
--- 219,226 ----
  	SD,
  	diskdstate->id,
  	sio,
! 	size,
! 	(off_t) offset,
  	shm_offset);
      if (x < 0) {
  	debug(79, 1) ("storeDiskdSend READ: %s\n", xstrerror());
***************
*** 231,241 ****
  }
  
  void
! storeDiskdWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
  {
      int x;
      char *sbuf;
!     off_t shm_offset;
      diskdstate_t *diskdstate = sio->fsstate;
      debug(79, 3) ("storeDiskdWrite: dirno %d, fileno %08X\n", SD->index, sio->swap_filen);
      assert(!diskdstate->flags.close_request);
--- 231,241 ----
  }
  
  void
! storeDiskdWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, FREE * free_func)
  {
      int x;
      char *sbuf;
!     int shm_offset;
      diskdstate_t *diskdstate = sio->fsstate;
      debug(79, 3) ("storeDiskdWrite: dirno %d, fileno %08X\n", SD->index, sio->swap_filen);
      assert(!diskdstate->flags.close_request);
***************
*** 252,259 ****
  	SD,
  	diskdstate->id,
  	sio,
! 	(int) size,
! 	(int) offset,
  	shm_offset);
      if (x < 0) {
  	debug(79, 1) ("storeDiskdSend WRITE: %s\n", xstrerror());
--- 252,259 ----
  	SD,
  	diskdstate->id,
  	sio,
! 	size,
! 	(off_t) offset,
  	shm_offset);
      if (x < 0) {
  	debug(79, 1) ("storeDiskdSend WRITE: %s\n", xstrerror());
***************
*** 267,273 ****
  storeDiskdUnlink(SwapDir * SD, StoreEntry * e)
  {
      int x;
!     off_t shm_offset;
      char *buf;
      diskdinfo_t *diskdinfo = SD->fsdata;
  
--- 267,273 ----
  storeDiskdUnlink(SwapDir * SD, StoreEntry * e)
  {
      int x;
!     int shm_offset;
      char *buf;
      diskdinfo_t *diskdinfo = SD->fsdata;
  
***************
*** 462,468 ****
  }
  
  static int
! storeDiskdSend(int mtype, SwapDir * sd, int id, storeIOState * sio, int size, int offset, off_t shm_offset)
  {
      int x;
      diomsg M;
--- 462,468 ----
  }
  
  static int
! storeDiskdSend(int mtype, SwapDir * sd, int id, storeIOState * sio, int size, off_t offset, int shm_offset)
  {
      int x;
      diomsg M;
Index: squid/src/fs/ufs/store_dir_ufs.c
diff -c squid/src/fs/ufs/store_dir_ufs.c:1.39.2.10 squid/src/fs/ufs/store_dir_ufs.c:1.39.2.12
*** squid/src/fs/ufs/store_dir_ufs.c:1.39.2.10	Wed Aug 25 15:07:25 2004
--- squid/src/fs/ufs/store_dir_ufs.c	Sat Mar 26 15:29:26 2005
***************
*** 80,86 ****
  static int storeUfsDirGetNextFile(RebuildState *, sfileno *, int *size);
  static StoreEntry *storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 80,86 ----
  static int storeUfsDirGetNextFile(RebuildState *, sfileno *, int *size);
  static StoreEntry *storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 373,378 ****
--- 373,396 ----
  }
  
  static void
+ storeUfsDirRebuildComplete(RebuildState * rb)
+ {
+     if (rb->log) {
+ 	debug(47, 1) ("Done reading %s swaplog (%d entries)\n",
+ 	    rb->sd->path, rb->n_read);
+ 	fclose(rb->log);
+ 	rb->log = NULL;
+     } else {
+ 	debug(47, 1) ("Done scanning %s (%d entries)\n",
+ 	    rb->sd->path, rb->counts.scancount);
+     }
+     store_dirs_rebuilding--;
+     storeUfsDirCloseTmpSwapLog(rb->sd);
+     storeRebuildComplete(&rb->counts);
+     cbdataFree(rb);
+ }
+ 
+ static void
  storeUfsDirRebuildFromDirectory(void *data)
  {
      RebuildState *rb = data;
***************
*** 395,406 ****
  	assert(fd == -1);
  	fd = storeUfsDirGetNextFile(rb, &filn, &size);
  	if (fd == -2) {
! 	    debug(47, 1) ("Done scanning %s swaplog (%d entries)\n",
! 		rb->sd->path, rb->n_read);
! 	    store_dirs_rebuilding--;
! 	    storeUfsDirCloseTmpSwapLog(rb->sd);
! 	    storeRebuildComplete(&rb->counts);
! 	    cbdataFree(rb);
  	    return;
  	} else if (fd < 0) {
  	    continue;
--- 413,419 ----
  	assert(fd == -1);
  	fd = storeUfsDirGetNextFile(rb, &filn, &size);
  	if (fd == -2) {
! 	    storeUfsDirRebuildComplete(rb);
  	    return;
  	} else if (fd < 0) {
  	    continue;
***************
*** 452,461 ****
--- 465,503 ----
  		assert(t->length == MD5_DIGEST_CHARS);
  		xmemcpy(key, t->value, MD5_DIGEST_CHARS);
  		break;
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
  	    case STORE_META_STD:
  		assert(t->length == STORE_HDR_METASIZE);
  		xmemcpy(&tmpe.timestamp, t->value, STORE_HDR_METASIZE);
  		break;
+ #else
+ 	    case STORE_META_STD_LFS:
+ 		assert(t->length == STORE_HDR_METASIZE);
+ 		xmemcpy(&tmpe.timestamp, t->value, STORE_HDR_METASIZE);
+ 		break;
+ 	    case STORE_META_STD:
+ 		assert(t->length == STORE_HDR_METASIZE_OLD);
+ 		{
+ 		    struct {
+ 			time_t timestamp;
+ 			time_t lastref;
+ 			time_t expires;
+ 			time_t lastmod;
+ 			size_t swap_file_sz;
+ 			u_short refcount;
+ 			u_short flags;
+ 		    }     *tmp = t->value;
+ 		    assert(sizeof(*tmp) == STORE_HDR_METASIZE_OLD);
+ 		    tmpe.timestamp = tmp->timestamp;
+ 		    tmpe.lastref = tmp->lastref;
+ 		    tmpe.expires = tmp->expires;
+ 		    tmpe.lastmod = tmp->lastmod;
+ 		    tmpe.swap_file_sz = tmp->swap_file_sz;
+ 		    tmpe.refcount = tmp->refcount;
+ 		    tmpe.flags = tmp->flags;
+ 		}
+ 		break;
+ #endif
  	    default:
  		break;
  	    }
***************
*** 529,549 ****
      /* load a number of objects per invocation */
      for (count = 0; count < rb->speed; count++) {
  	if (fread(&s, ss, 1, rb->log) != 1) {
! 	    debug(47, 1) ("Done reading %s swaplog (%d entries)\n",
! 		rb->sd->path, rb->n_read);
! 	    fclose(rb->log);
! 	    rb->log = NULL;
! 	    store_dirs_rebuilding--;
! 	    storeUfsDirCloseTmpSwapLog(rb->sd);
! 	    storeRebuildComplete(&rb->counts);
! 	    cbdataFree(rb);
  	    return;
  	}
  	rb->n_read++;
! 	if (s.op <= SWAP_LOG_NOP)
  	    continue;
! 	if (s.op >= SWAP_LOG_MAX)
  	    continue;
  	/*
  	 * BC: during 2.4 development, we changed the way swap file
  	 * numbers are assigned and stored.  The high 16 bits used
--- 571,748 ----
      /* load a number of objects per invocation */
      for (count = 0; count < rb->speed; count++) {
  	if (fread(&s, ss, 1, rb->log) != 1) {
! 	    storeUfsDirRebuildComplete(rb);
  	    return;
  	}
  	rb->n_read++;
! 	/*
! 	 * BC: during 2.4 development, we changed the way swap file
! 	 * numbers are assigned and stored.  The high 16 bits used
! 	 * to encode the SD index number.  There used to be a call
! 	 * to storeDirProperFileno here that re-assigned the index 
! 	 * bits.  Now, for backwards compatibility, we just need
! 	 * to mask it off.
! 	 */
! 	s.swap_filen &= 0x00FFFFFF;
! 	debug(47, 3) ("storeUfsDirRebuildFromSwapLog: %s %s %08X\n",
! 	    swap_log_op_str[(int) s.op],
! 	    storeKeyText(s.key),
! 	    s.swap_filen);
! 	if (s.op == SWAP_LOG_ADD) {
! 	    (void) 0;
! 	} else if (s.op == SWAP_LOG_DEL) {
! 	    /* Delete unless we already have a newer copy */
! 	    if ((e = storeGet(s.key)) != NULL && s.lastref > e->lastref) {
! 		/*
! 		 * Make sure we don't unlink the file, it might be
! 		 * in use by a subsequent entry.  Also note that
! 		 * we don't have to subtract from store_swap_size
! 		 * because adding to store_swap_size happens in
! 		 * the cleanup procedure.
! 		 */
! 		storeExpireNow(e);
! 		storeReleaseRequest(e);
! 		if (e->swap_filen > -1) {
! 		    storeUfsDirReplRemove(e);
! 		    storeUfsDirMapBitReset(SD, e->swap_filen);
! 		    e->swap_filen = -1;
! 		    e->swap_dirn = -1;
! 		}
! 		storeRelease(e);
! 		rb->counts.objcount--;
! 		rb->counts.cancelcount++;
! 	    }
  	    continue;
! 	} else {
! 	    x = log(++rb->counts.bad_log_op) / log(10.0);
! 	    if (0.0 == x - (double) (int) x)
! 		debug(47, 1) ("WARNING: %d invalid swap log entries found\n",
! 		    rb->counts.bad_log_op);
! 	    rb->counts.invalid++;
! 	    continue;
! 	}
! 	if ((++rb->counts.scancount & 0xFFF) == 0) {
! 	    struct stat sb;
! 	    if (0 == fstat(fileno(rb->log), &sb))
! 		storeRebuildProgress(SD->index,
! 		    (int) sb.st_size / ss, rb->n_read);
! 	}
! 	if (!storeUfsDirValidFileno(SD, s.swap_filen, 0)) {
! 	    rb->counts.invalid++;
! 	    continue;
! 	}
! 	if (EBIT_TEST(s.flags, KEY_PRIVATE)) {
! 	    rb->counts.badflags++;
! 	    continue;
! 	}
! 	e = storeGet(s.key);
! 	used = storeUfsDirMapBitTest(SD, s.swap_filen);
! 	/* If this URL already exists in the cache, does the swap log
! 	 * appear to have a newer entry?  Compare 'lastref' from the
! 	 * swap log to e->lastref. */
! 	disk_entry_newer = e ? (s.lastref > e->lastref ? 1 : 0) : 0;
! 	if (used && !disk_entry_newer) {
! 	    /* log entry is old, ignore it */
! 	    rb->counts.clashcount++;
  	    continue;
+ 	} else if (used && e && e->swap_filen == s.swap_filen && e->swap_dirn == SD->index) {
+ 	    /* swapfile taken, same URL, newer, update meta */
+ 	    if (e->store_status == STORE_OK) {
+ 		e->lastref = s.timestamp;
+ 		e->timestamp = s.timestamp;
+ 		e->expires = s.expires;
+ 		e->lastmod = s.lastmod;
+ 		e->flags = s.flags;
+ 		e->refcount += s.refcount;
+ 		storeUfsDirUnrefObj(SD, e);
+ 	    } else {
+ 		debug_trap("storeUfsDirRebuildFromSwapLog: bad condition");
+ 		debug(47, 1) ("\tSee %s:%d\n", __FILE__, __LINE__);
+ 	    }
+ 	    continue;
+ 	} else if (used) {
+ 	    /* swapfile in use, not by this URL, log entry is newer */
+ 	    /* This is sorta bad: the log entry should NOT be newer at this
+ 	     * point.  If the log is dirty, the filesize check should have
+ 	     * caught this.  If the log is clean, there should never be a
+ 	     * newer entry. */
+ 	    debug(47, 1) ("WARNING: newer swaplog entry for dirno %d, fileno %08X\n",
+ 		SD->index, s.swap_filen);
+ 	    /* I'm tempted to remove the swapfile here just to be safe,
+ 	     * but there is a bad race condition in the NOVM version if
+ 	     * the swapfile has recently been opened for writing, but
+ 	     * not yet opened for reading.  Because we can't map
+ 	     * swapfiles back to StoreEntrys, we don't know the state
+ 	     * of the entry using that file.  */
+ 	    /* We'll assume the existing entry is valid, probably because
+ 	     * were in a slow rebuild and the the swap file number got taken
+ 	     * and the validation procedure hasn't run. */
+ 	    assert(rb->flags.need_to_validate);
+ 	    rb->counts.clashcount++;
+ 	    continue;
+ 	} else if (e && !disk_entry_newer) {
+ 	    /* key already exists, current entry is newer */
+ 	    /* keep old, ignore new */
+ 	    rb->counts.dupcount++;
+ 	    continue;
+ 	} else if (e) {
+ 	    /* key already exists, this swapfile not being used */
+ 	    /* junk old, load new */
+ 	    storeExpireNow(e);
+ 	    storeReleaseRequest(e);
+ 	    if (e->swap_filen > -1) {
+ 		storeUfsDirReplRemove(e);
+ 		/* Make sure we don't actually unlink the file */
+ 		storeUfsDirMapBitReset(SD, e->swap_filen);
+ 		e->swap_filen = -1;
+ 		e->swap_dirn = -1;
+ 	    }
+ 	    storeRelease(e);
+ 	    rb->counts.dupcount++;
+ 	} else {
+ 	    /* URL doesnt exist, swapfile not in use */
+ 	    /* load new */
+ 	    (void) 0;
+ 	}
+ 	/* update store_swap_size */
+ 	rb->counts.objcount++;
+ 	e = storeUfsDirAddDiskRestore(SD, s.key,
+ 	    s.swap_filen,
+ 	    s.swap_file_sz,
+ 	    s.expires,
+ 	    s.timestamp,
+ 	    s.lastref,
+ 	    s.lastmod,
+ 	    s.refcount,
+ 	    s.flags,
+ 	    (int) rb->flags.clean);
+ 	storeDirSwapLog(e, SWAP_LOG_ADD);
+     }
+     eventAdd("storeRebuild", storeUfsDirRebuildFromSwapLog, rb, 0.0, 1);
+ }
+ 
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ /* This is an exact copy of the above, but using storeSwapLogDataOld entry type */
+ static void
+ storeUfsDirRebuildFromSwapLogOld(void *data)
+ {
+     RebuildState *rb = data;
+     SwapDir *SD = rb->sd;
+     StoreEntry *e = NULL;
+     storeSwapLogDataOld s;
+     size_t ss = sizeof(storeSwapLogDataOld);
+     int count;
+     int used;			/* is swapfile already in use? */
+     int disk_entry_newer;	/* is the log entry newer than current entry? */
+     double x;
+     assert(rb != NULL);
+     /* load a number of objects per invocation */
+     for (count = 0; count < rb->speed; count++) {
+ 	if (fread(&s, ss, 1, rb->log) != 1) {
+ 	    storeUfsDirRebuildComplete(rb);
+ 	    return;
+ 	}
+ 	rb->n_read++;
  	/*
  	 * BC: during 2.4 development, we changed the way swap file
  	 * numbers are assigned and stored.  The high 16 bits used
***************
*** 687,693 ****
--- 886,934 ----
  	    (int) rb->flags.clean);
  	storeDirSwapLog(e, SWAP_LOG_ADD);
      }
+     eventAdd("storeRebuild", storeUfsDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ }
+ 
+ #endif
+ 
+ static void
+ storeUfsDirRebuildFromSwapLogCheckVersion(void *data)
+ {
+     RebuildState *rb = data;
+     storeSwapLogHeader hdr;
+ 
+     if (fread(&hdr, sizeof(hdr), 1, rb->log) != 1) {
+ 	storeUfsDirRebuildComplete(rb);
+ 	return;
+     }
+     if (hdr.op == SWAP_LOG_VERSION) {
+ 	if (fseek(rb->log, hdr.record_size, SEEK_SET) != 0) {
+ 	    storeUfsDirRebuildComplete(rb);
+ 	    return;
+ 	}
+ 	if (hdr.version == 1 && hdr.record_size == sizeof(storeSwapLogData)) {
+ 	    eventAdd("storeRebuild", storeUfsDirRebuildFromSwapLog, rb, 0.0, 1);
+ 	    return;
+ 	}
+ #if SIZEOF_SQUID_FILE_SZ != SIZEOF_SIZE_T
+ 	if (hdr.version == 1 && hdr.record_size == sizeof(storeSwapLogDataOld)) {
+ 	    debug(47, 1) ("storeUfsDirRebuildFromSwapLog: Found current version but without large file support. Upgrading\n");
+ 	    eventAdd("storeRebuild", storeUfsDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ 	    return;
+ 	}
+ #endif
+ 	debug(47, 1) ("storeUfsDirRebuildFromSwapLog: Unsupported swap.state version %d size %d\n",
+ 	    hdr.version, hdr.record_size);
+ 	storeUfsDirRebuildComplete(rb);
+ 	return;
+     }
+     rewind(rb->log);
+     debug(47, 1) ("storeUfsDirRebuildFromSwapLog: Old version detected. Upgrading\n");
+ #if SIZEOF_SQUID_FILE_SZ == SIZEOF_SIZE_T
      eventAdd("storeRebuild", storeUfsDirRebuildFromSwapLog, rb, 0.0, 1);
+ #else
+     eventAdd("storeRebuild", storeUfsDirRebuildFromSwapLogOld, rb, 0.0, 1);
+ #endif
  }
  
  static int
***************
*** 782,788 ****
  static StoreEntry *
  storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     size_t swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
--- 1023,1029 ----
  static StoreEntry *
  storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
      int file_number,
!     squid_file_sz swap_file_sz,
      time_t expires,
      time_t timestamp,
      time_t lastref,
***************
*** 845,851 ****
  	    fclose(fp);
  	func = storeUfsDirRebuildFromDirectory;
      } else {
! 	func = storeUfsDirRebuildFromSwapLog;
  	rb->log = fp;
  	rb->flags.clean = (unsigned int) clean;
      }
--- 1086,1092 ----
  	    fclose(fp);
  	func = storeUfsDirRebuildFromDirectory;
      } else {
! 	func = storeUfsDirRebuildFromSwapLogCheckVersion;
  	rb->log = fp;
  	rb->flags.clean = (unsigned int) clean;
      }
***************
*** 885,890 ****
--- 1126,1156 ----
      debug(47, 3) ("Cache Dir #%d log opened on FD %d\n", sd->index, fd);
  }
  
+ static void
+ storeSwapLogDataFree(void *s)
+ {
+     memFree(s, MEM_SWAP_LOG_DATA);
+ }
+ 
+ static void
+ storeUfsWriteSwapLogheader(int fd)
+ {
+     storeSwapLogHeader *hdr = memAllocate(MEM_SWAP_LOG_DATA);
+     hdr->op = SWAP_LOG_VERSION;
+     hdr->version = 1;
+     hdr->record_size = sizeof(storeSwapLogData);
+     /* The header size is a full log record to keep some level of backward
+      * compatibility even if the actual header is smaller
+      */
+     file_write(fd,
+ 	-1,
+ 	hdr,
+ 	sizeof(storeSwapLogData),
+ 	NULL,
+ 	NULL,
+ 	(FREE *) storeSwapLogDataFree);
+ }
+ 
  static FILE *
  storeUfsDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
  {
***************
*** 914,919 ****
--- 1180,1186 ----
  	fatal("storeDirOpenTmpSwapLog: Failed to open swap log.");
      }
      ufsinfo->swaplog_fd = fd;
+     storeUfsWriteSwapLogheader(fd);
      /* open a read-only stream of the old log */
      fp = fopen(swaplog_path, "r");
      if (fp == NULL) {
***************
*** 942,948 ****
      char *new;
      char *cln;
      char *outbuf;
!     off_t outbuf_offset;
      int fd;
      RemovalPolicyWalker *walker;
  };
--- 1209,1215 ----
      char *new;
      char *cln;
      char *outbuf;
!     int outbuf_offset;
      int fd;
      RemovalPolicyWalker *walker;
  };
***************
*** 973,978 ****
--- 1240,1246 ----
  	xfree(state);
  	return -1;
      }
+     storeUfsWriteSwapLogheader(state->fd);
      state->cur = xstrdup(storeUfsDirSwapLogFile(sd, NULL));
      state->cln = xstrdup(storeUfsDirSwapLogFile(sd, ".last-clean"));
      state->outbuf = xcalloc(CLEAN_BUF_SZ, 1);
***************
*** 1101,1112 ****
  }
  
  static void
- storeSwapLogDataFree(void *s)
- {
-     memFree(s, MEM_SWAP_LOG_DATA);
- }
- 
- static void
  storeUfsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
  {
      ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
--- 1369,1374 ----
Index: squid/src/fs/ufs/store_io_ufs.c
diff -c squid/src/fs/ufs/store_io_ufs.c:1.9.2.4 squid/src/fs/ufs/store_io_ufs.c:1.9.2.6
*** squid/src/fs/ufs/store_io_ufs.c:1.9.2.4	Sat Jul 17 13:44:20 2004
--- squid/src/fs/ufs/store_io_ufs.c	Sat Mar 26 15:44:10 2005
***************
*** 150,156 ****
  }
  
  void
! storeUfsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
  {
      ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
  
--- 150,156 ----
  }
  
  void
! storeUfsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, STRCB * callback, void *callback_data)
  {
      ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
  
***************
*** 166,184 ****
      file_read(ufsstate->fd,
  	buf,
  	size,
! 	offset,
  	storeUfsReadDone,
  	sio);
  }
  
  void
! storeUfsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
  {
      ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
      debug(79, 3) ("storeUfsWrite: dirn %d, fileno %08X, FD %d\n", sio->swap_dirn, sio->swap_filen, ufsstate->fd);
      ufsstate->flags.writing = 1;
      file_write(ufsstate->fd,
! 	offset,
  	buf,
  	size,
  	storeUfsWriteDone,
--- 166,184 ----
      file_read(ufsstate->fd,
  	buf,
  	size,
! 	(off_t) offset,
  	storeUfsReadDone,
  	sio);
  }
  
  void
! storeUfsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, squid_off_t offset, FREE * free_func)
  {
      ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
      debug(79, 3) ("storeUfsWrite: dirn %d, fileno %08X, FD %d\n", sio->swap_dirn, sio->swap_filen, ufsstate->fd);
      ufsstate->flags.writing = 1;
      file_write(ufsstate->fd,
! 	(off_t) offset,
  	buf,
  	size,
  	storeUfsWriteDone,
***************
*** 213,219 ****
  	debug(79, 3) ("storeUfsReadDone: got failure (%d)\n", errflag);
  	rlen = -1;
      } else {
! 	rlen = (ssize_t) len;
  	sio->offset += len;
      }
      assert(callback);
--- 213,219 ----
  	debug(79, 3) ("storeUfsReadDone: got failure (%d)\n", errflag);
  	rlen = -1;
      } else {
! 	rlen = len;
  	sio->offset += len;
      }
      assert(callback);
***************
*** 221,227 ****
      sio->read.callback = NULL;
      sio->read.callback_data = NULL;
      if (cbdataValid(their_data))
! 	callback(their_data, buf, (size_t) rlen);
      cbdataUnlock(their_data);
  }
  
--- 221,227 ----
      sio->read.callback = NULL;
      sio->read.callback_data = NULL;
      if (cbdataValid(their_data))
! 	callback(their_data, buf, rlen);
      cbdataUnlock(their_data);
  }
  
