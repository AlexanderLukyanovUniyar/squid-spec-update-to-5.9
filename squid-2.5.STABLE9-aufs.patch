Index: squid/src/protos.h
diff -c squid/src/protos.h:1.420.2.27 squid/src/protos.h:1.420.2.28
*** squid/src/protos.h:1.420.2.27	Sun Feb 20 19:55:04 2005
--- squid/src/protos.h	Fri Mar 18 17:01:52 2005
***************
*** 874,879 ****
--- 874,881 ----
  extern ssize_t stmemCopy(const mem_hdr *, off_t, char *, size_t);
  extern void stmemFree(mem_hdr *);
  extern void stmemFreeData(mem_hdr *);
+ extern void stmemNodeFree(void *);
+ extern char *stmemNodeGet(mem_node *);
  
  /* ----------------------------------------------------------------- */
  
Index: squid/src/stmem.c
diff -c squid/src/stmem.c:1.70 squid/src/stmem.c:1.70.2.2
*** squid/src/stmem.c:1.70	Wed Oct 24 02:19:08 2001
--- squid/src/stmem.c	Sat Mar 19 04:41:39 2005
***************
*** 36,51 ****
  #include "squid.h"
  
  void
  stmemFree(mem_hdr * mem)
  {
      mem_node *p;
      while ((p = mem->head)) {
  	mem->head = p->next;
  	store_mem_size -= SM_PAGE_SIZE;
! 	if (p) {
! 	    memFree(p, MEM_MEM_NODE);
! 	    p = NULL;
! 	}
      }
      mem->head = mem->tail = NULL;
      mem->origin_offset = 0;
--- 36,65 ----
  #include "squid.h"
  
  void
+ stmemNodeFree(void *buf)
+ {
+     mem_node *p = (mem_node *) buf;
+     if (!p->uses)
+ 	memFree(p, MEM_MEM_NODE);
+     else
+ 	p->uses--;
+ }
+ 
+ char *
+ stmemNodeGet(mem_node * p)
+ {
+     p->uses++;
+     return p->data;
+ }
+ 
+ void
  stmemFree(mem_hdr * mem)
  {
      mem_node *p;
      while ((p = mem->head)) {
  	mem->head = p->next;
  	store_mem_size -= SM_PAGE_SIZE;
! 	stmemNodeFree(p);
      }
      mem->head = mem->tail = NULL;
      mem->origin_offset = 0;
***************
*** 55,61 ****
  stmemFreeDataUpto(mem_hdr * mem, int target_offset)
  {
      int current_offset = mem->origin_offset;
-     mem_node *lastp;
      mem_node *p = mem->head;
      while (p && ((current_offset + p->len) <= target_offset)) {
  	if (p == mem->tail) {
--- 69,74 ----
***************
*** 64,77 ****
  	    mem->origin_offset = current_offset;
  	    return current_offset;
  	} else {
! 	    lastp = p;
  	    p = p->next;
  	    current_offset += lastp->len;
  	    store_mem_size -= SM_PAGE_SIZE;
! 	    if (lastp) {
! 		memFree(lastp, MEM_MEM_NODE);
! 		lastp = NULL;
! 	    }
  	}
      }
      mem->head = p;
--- 77,87 ----
  	    mem->origin_offset = current_offset;
  	    return current_offset;
  	} else {
! 	    mem_node *lastp = p;
  	    p = p->next;
  	    current_offset += lastp->len;
  	    store_mem_size -= SM_PAGE_SIZE;
! 	    stmemNodeFree(lastp);
  	}
      }
      mem->head = p;
Index: squid/src/store_swapout.c
diff -c squid/src/store_swapout.c:1.85.2.1 squid/src/store_swapout.c:1.85.2.2
*** squid/src/store_swapout.c:1.85.2.1	Sat Apr 13 15:47:21 2002
--- squid/src/store_swapout.c	Fri Mar 18 17:01:52 2005
***************
*** 256,262 ****
  	debug(20, 3) ("storeSwapOut: swapping out %ld bytes from %ld\n",
  	    (long int) swap_buf_len, (long int) mem->swapout.queue_offset);
  	mem->swapout.queue_offset += swap_buf_len;
! 	storeWrite(mem->swapout.sio, mem->swapout.memnode->data, swap_buf_len, -1, NULL);
  	/* the storeWrite() call might generate an error */
  	if (e->swap_status != SWAPOUT_WRITING)
  	    break;
--- 256,262 ----
  	debug(20, 3) ("storeSwapOut: swapping out %ld bytes from %ld\n",
  	    (long int) swap_buf_len, (long int) mem->swapout.queue_offset);
  	mem->swapout.queue_offset += swap_buf_len;
! 	storeWrite(mem->swapout.sio, stmemNodeGet(mem->swapout.memnode), swap_buf_len, -1, stmemNodeFree);
  	/* the storeWrite() call might generate an error */
  	if (e->swap_status != SWAPOUT_WRITING)
  	    break;
Index: squid/src/structs.h
diff -c squid/src/structs.h:1.408.2.38 squid/src/structs.h:1.408.2.39
*** squid/src/structs.h:1.408.2.38	Wed Mar  2 19:18:29 2005
--- squid/src/structs.h	Fri Mar 18 17:01:52 2005
***************
*** 1431,1436 ****
--- 1431,1437 ----
  struct _mem_node {
      char data[SM_PAGE_SIZE];
      int len;
+     int uses;
      mem_node *next;
  };
  
Index: squid/src/fs/aufs/aiops.c
diff -c squid/src/fs/aufs/aiops.c:1.12.2.8 squid/src/fs/aufs/aiops.c:1.12.2.9
*** squid/src/fs/aufs/aiops.c:1.12.2.8	Wed Aug  6 08:16:26 2003
--- squid/src/fs/aufs/aiops.c	Fri Mar 18 17:01:52 2005
***************
*** 92,98 ****
      mode_t mode;
      int fd;
      char *bufferp;
-     char *tmpbufp;
      int buflen;
      off_t offset;
      int whence;
--- 92,97 ----
***************
*** 573,579 ****
      case _AIO_OP_READ:
  	break;
      case _AIO_OP_WRITE:
- 	squidaio_xfree(requestp->tmpbufp, requestp->buflen);
  	break;
      default:
  	break;
--- 572,577 ----
***************
*** 671,678 ****
  	squidaio_init();
      requestp = memPoolAlloc(squidaio_request_pool);
      requestp->fd = fd;
!     requestp->tmpbufp = (char *) squidaio_xmalloc(bufs);
!     xmemcpy(requestp->tmpbufp, bufp, bufs);
      requestp->buflen = bufs;
      requestp->offset = offset;
      requestp->whence = whence;
--- 669,675 ----
  	squidaio_init();
      requestp = memPoolAlloc(squidaio_request_pool);
      requestp->fd = fd;
!     requestp->bufferp = bufp;
      requestp->buflen = bufs;
      requestp->offset = offset;
      requestp->whence = whence;
***************
*** 688,694 ****
  static void
  squidaio_do_write(squidaio_request_t * requestp)
  {
!     requestp->ret = write(requestp->fd, requestp->tmpbufp, requestp->buflen);
      requestp->err = errno;
  }
  
--- 685,691 ----
  static void
  squidaio_do_write(squidaio_request_t * requestp)
  {
!     requestp->ret = write(requestp->fd, requestp->bufferp, requestp->buflen);
      requestp->err = errno;
  }
  
Index: squid/src/fs/aufs/store_asyncufs.h
diff -c squid/src/fs/aufs/store_asyncufs.h:1.9.2.2 squid/src/fs/aufs/store_asyncufs.h:1.9.2.3
*** squid/src/fs/aufs/store_asyncufs.h:1.9.2.2	Wed Aug  6 08:16:26 2003
--- squid/src/fs/aufs/store_asyncufs.h	Fri Mar 18 17:01:52 2005
***************
*** 86,93 ****
  	unsigned int reading:1;
  	unsigned int writing:1;
  	unsigned int opening:1;
  	unsigned int write_kicking:1;
! 	unsigned int read_kicking:1;
  	unsigned int inreaddone:1;
      } flags;
      char *read_buf;
--- 86,94 ----
  	unsigned int reading:1;
  	unsigned int writing:1;
  	unsigned int opening:1;
+ #if !ASYNC_WRITE
  	unsigned int write_kicking:1;
! #endif
  	unsigned int inreaddone:1;
      } flags;
      char *read_buf;
Index: squid/src/fs/aufs/store_io_aufs.c
diff -c squid/src/fs/aufs/store_io_aufs.c:1.15.2.12 squid/src/fs/aufs/store_io_aufs.c:1.15.2.13
*** squid/src/fs/aufs/store_io_aufs.c:1.15.2.12	Sat Jun  5 13:42:14 2004
--- squid/src/fs/aufs/store_io_aufs.c	Fri Mar 18 17:01:52 2005
***************
*** 393,410 ****
      }
      sio->offset += len;
  #if ASYNC_WRITE
!     if (!storeAufsKickWriteQueue(sio))
  	(void) 0;
      else if (aiostate->flags.close_request)
  	storeAufsIOCallback(sio, errflag);
  #else
      if (!aiostate->flags.write_kicking) {
  	aiostate->flags.write_kicking = 1;
  	while (storeAufsKickWriteQueue(sio))
! 	    (void) 0;
! 	aiostate->flags.write_kicking = 0;
! 	if (aiostate->flags.close_request)
! 	    storeAufsIOCallback(sio, errflag);
      }
  #endif
      loop_detect--;
--- 393,421 ----
      }
      sio->offset += len;
  #if ASYNC_WRITE
!     if (storeAufsKickWriteQueue(sio))
  	(void) 0;
      else if (aiostate->flags.close_request)
  	storeAufsIOCallback(sio, errflag);
  #else
+     /* loop around storeAufsKickWriteQueue to break recursion stack
+      * overflow when large amounts of data has been queued for write.
+      * As writes are blocking here we immediately get called again
+      * without going via the I/O event loop..
+      */
      if (!aiostate->flags.write_kicking) {
+ 	/* cbdataLock to protect us from the storeAufsIOCallback on error above */
+ 	cbdataLock(sio);
  	aiostate->flags.write_kicking = 1;
  	while (storeAufsKickWriteQueue(sio))
! 	    if (!cbdataValid(sio))
! 		break;
! 	if (cbdataValid(sio)) {
! 	    aiostate->flags.write_kicking = 0;
! 	    if (aiostate->flags.close_request)
! 		storeAufsIOCallback(sio, errflag);
! 	}
! 	cbdataUnlock(sio);
      }
  #endif
      loop_detect--;
***************
*** 433,440 ****
--- 444,456 ----
      if (fd < 0)
  	return;
      debug(79, 9) ("%s:%d\n", __FILE__, __LINE__);
+ #if ASYNC_CLOSE
      aioClose(fd);
      fd_close(fd);
+ #else
+     aioCancel(fd);
+     file_close(fd);
+ #endif
      store_open_disk_fd--;
      statCounter.syscalls.disk.closes++;
      debug(79, 9) ("%s:%d\n", __FILE__, __LINE__);
Index: squid/src/fs/aufs/async_io.c
diff -c squid/src/fs/aufs/async_io.c:1.10.2.7 squid/src/fs/aufs/async_io.c:1.10.2.8
*** squid/src/fs/aufs/async_io.c:1.10.2.7	Fri Mar 25 19:50:54 2005
--- squid/src/fs/aufs/async_io.c	Tue Mar 29 01:44:14 2005
***************
*** 79,93 ****
  static int initialised = 0;
  static OBJH aioStats;
  static MemPool *squidaio_ctrl_pool;
- static void aioFDWasClosed(int fd);
- 
- static void
- aioFDWasClosed(int fd)
- {
-     if (fd_table[fd].flags.closing)
- 	fd_close(fd);
- }
- 
  
  void
  aioInit(void)
--- 79,84 ----
***************
*** 337,344 ****
  	/* free temporary read buffer */
  	if (ctrlp->operation == _AIO_READ)
  	    squidaio_xfree(ctrlp->bufp, ctrlp->len);
- 	if (ctrlp->operation == _AIO_CLOSE)
- 	    aioFDWasClosed(ctrlp->fd);
  	memPoolFree(squidaio_ctrl_pool, ctrlp);
      }
      return retval;
--- 328,333 ----
