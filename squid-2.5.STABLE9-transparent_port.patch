Index: squid/src/client_side.c
diff -c squid/src/client_side.c:1.561.2.75 squid/src/client_side.c:1.561.2.76
*** squid/src/client_side.c:1.561.2.75	Fri Mar 25 19:50:52 2005
--- squid/src/client_side.c	Wed Apr 20 15:46:06 2005
***************
*** 2728,2778 ****
      }
      /* see if we running in Config2.Accel.on, if so got to convert it to URL */
      else if (Config2.Accel.on && *url == '/') {
! 	/* prepend the accel prefix */
! 	if (Config.onoff.accel_uses_host_header && (t = mime_get_header(req_hdr, "Host"))) {
! 	    int vport;
! 	    char *q;
! 	    const char *protocol_name = "http";
! 	    if (vport_mode)
! 		vport = (int) ntohs(http->conn->me.sin_port);
! 	    else
! 		vport = (int) Config.Accel.port;
! 	    /* If a Host: header was specified, use it to build the URL 
! 	     * instead of the one in the Config file. */
! 	    /*
! 	     * XXX Use of the Host: header here opens a potential
! 	     * security hole.  There are no checks that the Host: value
! 	     * corresponds to one of your servers.  It might, for example,
! 	     * refer to www.playboy.com.  The 'dst' and/or 'dst_domain' ACL 
! 	     * types should be used to prevent httpd-accelerators 
! 	     * handling requests for non-local servers */
! 	    strtok(t, " /;@");
! 	    if ((q = strchr(t, ':'))) {
! 		*q++ = '\0';
! 		if (vport_mode)
! 		    vport = atoi(q);
! 	    }
! 	    url_sz = strlen(url) + 32 + Config.appendDomainLen +
! 		strlen(t);
! 	    http->uri = xcalloc(url_sz, 1);
! 
! #if SSL_FORWARDING_NOT_YET_DONE
! 	    if (Config.Sockaddr.https->s.sin_port == http->conn->me.sin_port) {
! 		protocol_name = "https";
! 		vport = ntohs(http->conn->me.sin_port);
! 	    }
! #endif
! 	    snprintf(http->uri, url_sz, "%s://%s:%d%s",
! 		protocol_name, t, vport, url);
! 	} else if (vhost_mode) {
! 	    int vport;
! 	    /* Put the local socket IP address as the hostname */
! 	    url_sz = strlen(url) + 32 + Config.appendDomainLen;
! 	    http->uri = xcalloc(url_sz, 1);
! 	    if (vport_mode)
! 		vport = (int) ntohs(http->conn->me.sin_port);
! 	    else
! 		vport = (int) Config.Accel.port;
  #if IPF_TRANSPARENT
  	    natLookup.nl_inport = http->conn->me.sin_port;
  	    natLookup.nl_outport = http->conn->peer.sin_port;
--- 2728,2735 ----
      }
      /* see if we running in Config2.Accel.on, if so got to convert it to URL */
      else if (Config2.Accel.on && *url == '/') {
! 	int vport;
! 	if (vhost_mode) {
  #if IPF_TRANSPARENT
  	    natLookup.nl_inport = http->conn->me.sin_port;
  	    natLookup.nl_outport = http->conn->peer.sin_port;
***************
*** 2782,2788 ****
--- 2739,2749 ----
  	    if (natfd < 0) {
  		int save_errno;
  		enter_suid();
+ #ifdef IPL_NAME
+ 		natfd = open(IPL_NAME, O_RDONLY, 0);
+ #else
  		natfd = open(IPL_NAT, O_RDONLY, 0);
+ #endif
  		save_errno = errno;
  		leave_suid();
  		errno = save_errno;
***************
*** 2794,2834 ****
  		xfree(http->uri);
  		cbdataFree(http);
  		xfree(inbuf);
- 		return parseHttpRequestAbort(conn, "error:nat-open-failed");
- 	    }
- 	    /*
- 	     * IP-Filter changed the type for SIOCGNATL between
- 	     * 3.3 and 3.4.  It also changed the cmd value for
- 	     * SIOCGNATL, so at least we can detect it.  We could
- 	     * put something in configure and use ifdefs here, but
- 	     * this seems simpler.
- 	     */
- 	    if (63 == siocgnatl_cmd) {
- 		struct natlookup *nlp = &natLookup;
- 		x = ioctl(natfd, SIOCGNATL, &nlp);
  	    } else {
! 		x = ioctl(natfd, SIOCGNATL, &natLookup);
! 	    }
! 	    if (x < 0) {
! 		if (errno != ESRCH) {
! 		    debug(50, 1) ("parseHttpRequest: NAT lookup failed: ioctl(SIOCGNATL)\n");
! 		    close(natfd);
! 		    natfd = -1;
! 		    dlinkDelete(&http->active, &ClientActiveRequests);
! 		    xfree(http->uri);
! 		    cbdataFree(http);
! 		    xfree(inbuf);
! 		    return parseHttpRequestAbort(conn, "error:nat-lookup-failed");
! 		} else
! 		    snprintf(http->uri, url_sz, "http://%s:%d%s",
! 			inet_ntoa(http->conn->me.sin_addr),
! 			vport, url);
! 	    } else {
! 		if (vport_mode)
! 		    vport = ntohs(natLookup.nl_realport);
! 		snprintf(http->uri, url_sz, "http://%s:%d%s",
! 		    inet_ntoa(natLookup.nl_realip),
! 		    vport, url);
  	    }
  #elif PF_TRANSPARENT
  	    if (pffd < 0)
--- 2755,2788 ----
  		xfree(http->uri);
  		cbdataFree(http);
  		xfree(inbuf);
  	    } else {
! 		/*
! 		 * IP-Filter changed the type for SIOCGNATL between
! 		 * 3.3 and 3.4.  It also changed the cmd value for
! 		 * SIOCGNATL, so at least we can detect it.  We could
! 		 * put something in configure and use ifdefs here, but
! 		 * this seems simpler.
! 		 */
! 		if (63 == siocgnatl_cmd) {
! 		    struct natlookup *nlp = &natLookup;
! 		    x = ioctl(natfd, SIOCGNATL, &nlp);
! 		} else {
! 		    x = ioctl(natfd, SIOCGNATL, &natLookup);
! 		}
! 		if (x < 0) {
! 		    if (errno != ESRCH) {
! 			debug(50, 1) ("parseHttpRequest: NAT lookup failed: ioctl(SIOCGNATL)\n");
! 			close(natfd);
! 			natfd = -1;
! 			dlinkDelete(&http->active, &ClientActiveRequests);
! 			xfree(http->uri);
! 			cbdataFree(http);
! 			xfree(inbuf);
! 		    }
! 		} else {
! 		    conn->me.sin_port = natLookup.nl_realport;
! 		    http->conn->me.sin_addr = natLookup.nl_realip;
! 		}
  	    }
  #elif PF_TRANSPARENT
  	    if (pffd < 0)
***************
*** 2851,2882 ****
  		    debug(50, 1) ("parseHttpRequest: PF lookup failed: ioctl(DIOCNATLOOK)\n");
  		    close(pffd);
  		    pffd = -1;
! 		    return parseHttpRequestAbort(conn, "error:pf-lookup-failed");
! 		} else
! 		    snprintf(http->uri, url_sz, "http://%s:%d%s",
! 			inet_ntoa(http->conn->me.sin_addr),
! 			vport, url);
! 	    } else
! 		snprintf(http->uri, url_sz, "http://%s:%d%s",
! 		    inet_ntoa(nl.rdaddr.v4),
! 		    ntohs(nl.rdport), url);
! #else
! #if LINUX_NETFILTER
  	    /* If the call fails the address structure will be unchanged */
  	    getsockopt(conn->fd, SOL_IP, SO_ORIGINAL_DST, &conn->me, &sock_sz);
- 	    debug(33, 5) ("parseHttpRequest: addr = %s\n", inet_ntoa(conn->me.sin_addr));
- 	    if (vport_mode)
- 		vport = (int) ntohs(http->conn->me.sin_port);
  #endif
  	    snprintf(http->uri, url_sz, "http://%s:%d%s",
  		inet_ntoa(http->conn->me.sin_addr),
  		vport, url);
- #endif
  	    debug(33, 5) ("VHOST REWRITE: '%s'\n", http->uri);
  	} else if (vport_mode) {
- 	    int vport;
  	    const char *protocol_name = "http";
- 	    vport = (int) ntohs(http->conn->me.sin_port);
  	    url_sz = strlen(url) + 32 + Config.appendDomainLen +
  		strlen(Config.Accel.host);
  	    http->uri = xcalloc(url_sz, 1);
--- 2805,2865 ----
  		    debug(50, 1) ("parseHttpRequest: PF lookup failed: ioctl(DIOCNATLOOK)\n");
  		    close(pffd);
  		    pffd = -1;
! 		}
! 	    } else {
! 		conn->me.sin_port = nl.rdport;
! 		http->conn->me.sin_addr = nl.rdaddr.v4;
! 	    }
! #elif LINUX_NETFILTER
  	    /* If the call fails the address structure will be unchanged */
  	    getsockopt(conn->fd, SOL_IP, SO_ORIGINAL_DST, &conn->me, &sock_sz);
  #endif
+ 	}
+ 	if (vport_mode)
+ 	    vport = (int) ntohs(http->conn->me.sin_port);
+ 	else
+ 	    vport = (int) Config.Accel.port;
+ 	/* prepend the accel prefix */
+ 	if (Config.onoff.accel_uses_host_header && (t = mime_get_header(req_hdr, "Host"))) {
+ 	    char *q;
+ 	    const char *protocol_name = "http";
+ 	    /* If a Host: header was specified, use it to build the URL 
+ 	     * instead of the one in the Config file. */
+ 	    /*
+ 	     * XXX Use of the Host: header here opens a potential
+ 	     * security hole.  There are no checks that the Host: value
+ 	     * corresponds to one of your servers.  It might, for example,
+ 	     * refer to www.playboy.com.  The 'dst' and/or 'dst_domain' ACL 
+ 	     * types should be used to prevent httpd-accelerators 
+ 	     * handling requests for non-local servers */
+ 	    strtok(t, " /;@");
+ 	    if ((q = strchr(t, ':'))) {
+ 		*q++ = '\0';
+ 		if (vport_mode)
+ 		    vport = atoi(q);
+ 	    }
+ 	    url_sz = strlen(url) + 32 + Config.appendDomainLen +
+ 		strlen(t);
+ 	    http->uri = xcalloc(url_sz, 1);
+ 
+ #if SSL_FORWARDING_NOT_YET_DONE
+ 	    if (Config.Sockaddr.https->s.sin_port == http->conn->me.sin_port) {
+ 		protocol_name = "https";
+ 		vport = ntohs(http->conn->me.sin_port);
+ 	    }
+ #endif
+ 	    snprintf(http->uri, url_sz, "%s://%s:%d%s",
+ 		protocol_name, t, vport, url);
+ 	} else if (vhost_mode) {
+ 	    /* Put the local socket IP address as the hostname */
+ 	    url_sz = strlen(url) + 32 + Config.appendDomainLen;
+ 	    http->uri = xcalloc(url_sz, 1);
  	    snprintf(http->uri, url_sz, "http://%s:%d%s",
  		inet_ntoa(http->conn->me.sin_addr),
  		vport, url);
  	    debug(33, 5) ("VHOST REWRITE: '%s'\n", http->uri);
  	} else if (vport_mode) {
  	    const char *protocol_name = "http";
  	    url_sz = strlen(url) + 32 + Config.appendDomainLen +
  		strlen(Config.Accel.host);
  	    http->uri = xcalloc(url_sz, 1);
